// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#ifndef EXAMPLE_PRICE_619B26DC0AB966798152E57555663ECD1612F79A
#define EXAMPLE_PRICE_619B26DC0AB966798152E57555663ECD1612F79A

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
    #define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

    // This is boilerplate that is part of every Atlas interaction file.
    // Nothing to see here, move along.

    #if defined(__cpp_impl_three_way_comparison) && \
        __cpp_impl_three_way_comparison >= 201907L
        #include <compare>
    #endif
    #include <type_traits>
    #include <utility>

namespace atlas {

struct strong_type_tag
{
    #if defined(__cpp_impl_three_way_comparison) && \
        __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
    #endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <typename T, typename = void>
struct IsAtlasType
: std::false_type
{ };

template <typename T>
struct IsAtlasType<T, void_t<typename T::atlas_value_type>>
: std::true_type
{ };

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;
template <typename T, typename U = void>
using enable_if = typename std::enable_if<T::value, U>::type;

template <typename T>
using _t = typename T::type;

void atlas_value();

template <typename T>
constexpr T &
value(T & val, PriorityTag<0>)
{
    return val;
}

template <typename T, typename U = typename T::atlas_value_type>
using val_t = _t<std::conditional<std::is_const<T>::value, U const &, U &>>;

template <typename T, typename U = val_t<T>>
constexpr auto
value(T & val, PriorityTag<1>)
-> decltype(atlas::atlas_detail::value(static_cast<U>(val), value_tag{}))
{
    return atlas::atlas_detail::value(static_cast<U>(val), value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<2>)
-> decltype(atlas_value(t, atlas::value_tag{}))
{
    return atlas_value(t, atlas::value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<3>)
-> decltype(atlas_value(t))
{
    return atlas_value(t);
}

class Value
{
    template <
        typename U,
        typename T,
        typename V = _t<std::conditional<is_lref<U &&>::value, T &, T>>>
    static constexpr V rval(T && t)
    {
        return t;
    }

public:
    template <typename T>
    constexpr auto operator () (T && t) const
    -> decltype(rval<T>(atlas_detail::value(t, atlas_detail::value_tag{})))
    {
        return rval<T>(atlas_detail::value(t, atlas_detail::value_tag{}));
    }
};

} // namespace atlas_detail

    #if defined(__cpp_inline_variables) && __cpp_inline_variables >= 9201606L
inline constexpr auto value = atlas_detail::Value{};
    #else
template <typename T>
constexpr auto
value(T && t)
-> decltype(atlas_detail::Value{}(std::forward<T>(t)))
{
    return atlas_detail::Value{}(std::forward<T>(t));
}
    #endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////

#include <compare>
#include <ostream>
#include <type_traits>
#include <utility>

namespace example {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: example
 * - type_name: Price
 * - description: strong double; +, -, <=>, out
 * - default_value: "0.0"
 */
struct Price
: private atlas::strong_type_tag
{
    double value{0.0};

    using atlas_value_type = double;

    constexpr explicit Price() = default;
    constexpr Price(Price const &) = default;
    constexpr Price(Price &&) = default;
    constexpr Price & operator = (Price const &) = default;
    constexpr Price & operator = (Price &&) = default;
    constexpr ~Price() = default;

    template <
        typename... ArgTs,
        std::enable_if_t<std::is_constructible_v<double, ArgTs...>, bool> =
            true>
    constexpr explicit Price(ArgTs &&... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator double const & () const { return value; }

    constexpr explicit operator double & () { return value; }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr Price & operator += (Price & lhs, Price const & rhs)
    {
        lhs.value += rhs.value;
        return lhs;
    }

    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr Price operator + (Price lhs, Price const & rhs)
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr Price & operator -= (Price & lhs, Price const & rhs)
    {
        lhs.value -= rhs.value;
        return lhs;
    }

    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr Price operator - (Price lhs, Price const & rhs)
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (Price const &, Price const &) = default;

    /**
     * Insert the wrapped object into an ostream.
     */
    friend std::ostream & operator << (std::ostream & strm, Price const & t)
    {
        return strm << t.value;
    }
};

} // namespace example
#endif // EXAMPLE_PRICE_619B26DC0AB966798152E57555663ECD1612F79A
