#ifndef EXAMPLE_INTERACTIONS_9117164626BE44E4F68F5D2676C61DCF66202C3D
#define EXAMPLE_INTERACTIONS_9117164626BE44E4F68F5D2676C61DCF66202C3D

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Interaction Generator v1.0.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#if __has_include(<version>)
#include <version>
#endif

#include <type_traits>
#include <utility>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// ======================================================================
// ATLAS STRONG TYPE BOILERPLATE
// ----------------------------------------------------------------------
//
// This section provides the infrastructure for Atlas strong types.
// It is identical across all Atlas-generated files and uses a shared
// header guard (WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90) to ensure
// the boilerplate is only included once even when multiple generated
// files are used in the same translation unit.
//
// The boilerplate is intentionally inlined to make generated code
// self-contained with zero external dependencies.
//
// Components:
// - atlas::strong_type_tag: Base class for strong types
// - atlas::undress(): Universal value accessor for strong types
// - atlas_detail::*: Internal implementation utilities
//
// For projects using multiple Atlas-generated files, this boilerplate
// will only be compiled once per translation unit thanks to the shared
// header guard below.
//
// ----------------------------------------------------------------------
// DO NOT EDIT THIS SECTION
// ======================================================================

// Atlas feature detection macros
#ifndef ATLAS_NODISCARD
#if defined(__cpp_attributes) && __cpp_attributes >= 201603L
#define ATLAS_NODISCARD [[nodiscard]]
#else
#define ATLAS_NODISCARD
#endif
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif

#if defined(__cpp_lib_format) && __cpp_lib_format >= 202110L
#include <format>
#endif

namespace atlas {

template<typename T>
struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;

template <typename T>
using remove_cv_t = typename std::remove_cv<T>::type;
template <typename T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <typename T>
using remove_cvref_t = remove_cv_t<remove_reference_t<T>>;
template <bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;
template <bool B>
using when = enable_if_t<B, bool>;

template <typename T>
using _t = typename T::type;

template <typename T, typename = void>
struct has_atlas_value_type
: std::false_type
{ };

template <typename T>
struct has_atlas_value_type<
    T,
    enable_if_t<not std::is_same<
        typename remove_cvref_t<T>::atlas_value_type,
        void>::value>>
: std::true_type
{ };

void atlas_value_for();
struct value_by_ref
{ };
struct value_by_val
{ };

// ----------------------------------------------------------------------------
// Base case: T does not have atlas_value_type
// These are the termination cases for the recursion.
// ----------------------------------------------------------------------------
template <typename T>
constexpr T &
value_impl(T & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T const &
value_impl(T const & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T
value_impl(T & t, PriorityTag<0>, value_by_val)
{
    return std::move(t);
}
template <typename T>
constexpr T
value_impl(T const & t, PriorityTag<0>, value_by_val)
{
    return t;
}

// ----------------------------------------------------------------------------
// Enum case: T is an enum - convert to underlying type
// Always returns by value since conversion creates a distinct value.
// ----------------------------------------------------------------------------
template <typename T>
constexpr auto
value_impl(T t, PriorityTag<2>, value_by_ref)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}
template <typename T>
constexpr auto
value_impl(T t, PriorityTag<2>, value_by_val)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}

// ----------------------------------------------------------------------------
// Recursive case: T has atlas_value_for() hidden friend
// Use ADL to call atlas_value_for() and recurse.
// ----------------------------------------------------------------------------
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_ref{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_ref{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    atlas_value_for(std::move(t)),
    value_tag{},
    value_by_val{}))
{
    return value_impl(atlas_value_for(std::move(t)), value_tag{}, value_by_val{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_val{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_val{});
}

struct ToUnderlying
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_val{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_val{});
    }
};

// ----------------------------------------------------------------------------
// Unwrap: Remove exactly one layer from atlas types or enums
// Unlike undress, this does NOT recurse.
// ----------------------------------------------------------------------------

template <typename T>
constexpr auto
unwrap_impl(T & t, PriorityTag<2>)
-> decltype(atlas_value_for(t))
{
    return atlas_value_for(t);
}

template <typename T>
constexpr auto
unwrap_impl(T const & t, PriorityTag<2>)
-> decltype(atlas_value_for(t))
{
    return atlas_value_for(t);
}

template <typename T>
constexpr auto
unwrap_impl(T && t, PriorityTag<2>)
-> typename std::enable_if<
    not std::is_lvalue_reference<T>::value,
    decltype(atlas_value_for(std::move(t)))>::type
{
    return atlas_value_for(std::move(t));
}

// Enum fallback - convert to underlying type
template <typename T>
constexpr auto
unwrap_impl(T t, PriorityTag<1>)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}

// No PriorityTag<0> - SFINAE failure for non-atlas/non-enum types

struct Unwrap
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(unwrap_impl(t, PriorityTag<2>{}))
    {
        return unwrap_impl(t, PriorityTag<2>{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(unwrap_impl(t, PriorityTag<2>{}))
    {
        return unwrap_impl(t, PriorityTag<2>{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(unwrap_impl(std::forward<T>(t), PriorityTag<2>{}))
    {
        return unwrap_impl(std::forward<T>(t), PriorityTag<2>{});
    }
};

// ----------------------------------------------------------------------------
// UndressEnum: Drill through atlas types and stop at enum
// Like undress, but stops at enum instead of converting to underlying type.
// SFINAE fails if the drill does not resolve to an enum.
// ----------------------------------------------------------------------------
using undress_enum_tag = PriorityTag<1>;

// Base case: T is an enum - return it (don't convert to underlying)
template <typename T>
constexpr auto
undress_enum_impl(T & t, PriorityTag<0>)
-> typename std::enable_if<std::is_enum<T>::value, T &>::type
{
    return t;
}

template <typename T>
constexpr auto
undress_enum_impl(T const & t, PriorityTag<0>)
-> typename std::enable_if<std::is_enum<T>::value, T const &>::type
{
    return t;
}

// Recursive case: drill through atlas types
template <typename T>
constexpr auto
undress_enum_impl(T & t, PriorityTag<1>)
-> decltype(undress_enum_impl(atlas_value_for(t), undress_enum_tag{}))
{
    return undress_enum_impl(atlas_value_for(t), undress_enum_tag{});
}

template <typename T>
constexpr auto
undress_enum_impl(T const & t, PriorityTag<1>)
-> decltype(undress_enum_impl(atlas_value_for(t), undress_enum_tag{}))
{
    return undress_enum_impl(atlas_value_for(t), undress_enum_tag{});
}

template <typename T>
constexpr auto
undress_enum_impl(T && t, PriorityTag<1>)
-> typename std::enable_if<
    not std::is_lvalue_reference<T>::value,
    decltype(undress_enum_impl(atlas_value_for(std::move(t)), undress_enum_tag{}))>::type
{
    return undress_enum_impl(atlas_value_for(std::move(t)), undress_enum_tag{});
}

struct UndressEnum
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(undress_enum_impl(t, undress_enum_tag{}))
    {
        return undress_enum_impl(t, undress_enum_tag{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(undress_enum_impl(t, undress_enum_tag{}))
    {
        return undress_enum_impl(t, undress_enum_tag{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(undress_enum_impl(std::forward<T>(t), undress_enum_tag{}))
    {
        return undress_enum_impl(std::forward<T>(t), undress_enum_tag{});
    }
};

// ----------------------------------------------------------------------------
// Type trait: holds_enum - true if undress_enum would succeed
// Uses the same mechanism as undress_enum to ensure consistency.
// ----------------------------------------------------------------------------
template <typename T, typename = void>
struct holds_enum_impl : std::false_type {};

template <typename T>
struct holds_enum_impl<
    T,
    void_t<decltype(undress_enum_impl(
        std::declval<remove_cvref_t<T> &>(),
        undress_enum_tag{}))>>
: std::true_type {};

using cast_tag = PriorityTag<1>;

// ----------------------------------------------------------------------------
// cast_impl: Drill down to find the first type castable to TargetT
// ----------------------------------------------------------------------------
template <typename TargetT, typename U>
constexpr auto
cast_impl(U && u, PriorityTag<1>)
-> decltype(static_cast<TargetT>(std::forward<U>(u)))
{
    return static_cast<TargetT>(std::forward<U>(u));
}

template <typename TargetT, typename U>
constexpr auto
cast_impl(U && u, PriorityTag<0>)
-> decltype(cast_impl<TargetT>(atlas_value_for(std::forward<U>(u)), cast_tag{}))
{
    return cast_impl<TargetT>(atlas_value_for(std::forward<U>(u)), cast_tag{});
}

template <typename TargetT>
struct CastTo
{
    template <typename U>
    constexpr auto
    operator () (U && u) const
    -> decltype(cast_impl<TargetT>(std::forward<U>(u), cast_tag{}))
    {
        return cast_impl<TargetT>(std::forward<U>(u), cast_tag{});
    }
};

void begin();
void end();

template <typename T>
constexpr auto
begin_(T && t) noexcept(noexcept(begin(std::forward<T>(t))))
-> decltype(begin(std::forward<T>(t)))
{
    return begin(std::forward<T>(t));
}

template <typename T>
constexpr auto
end_(T && t) noexcept(noexcept(end(std::forward<T>(t))))
-> decltype(end(std::forward<T>(t)))
{
    return end(std::forward<T>(t));
}

} // namespace atlas_detail

using atlas_detail::enable_if_t;
using atlas_detail::remove_cv_t;
using atlas_detail::remove_cvref_t;
using atlas_detail::when;

template <typename T>
using is_atlas_type = atlas_detail::has_atlas_value_type<T>;

template <typename T>
using holds_enum = atlas_detail::holds_enum_impl<atlas_detail::remove_cvref_t<T>>;

#if defined(__cpp_concepts) && __cpp_concepts >= 201907L
template <typename T>
concept AtlasTypeC = is_atlas_type<T>::value;

template <typename T>
concept HoldsEnumC = holds_enum<T>::value;
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto undress = atlas_detail::ToUnderlying{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto undress = atlas_detail::ToUnderlying{};
#else
// fallback: not nice, but not terrible and prevents ADL
namespace {
constexpr atlas_detail::ToUnderlying undress{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto unwrap = atlas_detail::Unwrap{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto unwrap = atlas_detail::Unwrap{};
#else
namespace {
constexpr atlas_detail::Unwrap unwrap{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto undress_enum = atlas_detail::UndressEnum{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto undress_enum = atlas_detail::UndressEnum{};
#else
namespace {
constexpr atlas_detail::UndressEnum undress_enum{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
template <typename TargetT>
inline constexpr atlas_detail::CastTo<TargetT> cast{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
template <typename TargetT>
constexpr atlas_detail::CastTo<TargetT> cast{};
#else
// fallback: function template (ADL still possible, but unavoidable in C++11)
template <typename TargetT, typename U>
constexpr auto
cast(U && u)
-> decltype(atlas_detail::cast_impl<TargetT>(
    std::forward<U>(u),
    atlas_detail::cast_tag{}))
{
    return atlas_detail::cast_impl<TargetT>(
        std::forward<U>(u),
        atlas_detail::cast_tag{});
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////


// Custom value accessors for non-Atlas types
// These allow atlas::undress() to work with external library types
// Users can override by providing atlas_value_for(T const&) without the tag parameter
namespace atlas {
inline auto
atlas_value_for(::concurrency::ThreadId const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::data::ByteCount const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::finance::core::Money const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::geo::Latitude const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::geo::Longitude const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::graphics::color::RedChannel const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::math::rational::Denominator const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::math::rational::Numerator const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::net::ipv4::Octet const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::physics::units::Meters const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::physics::units::MetersPerSecond const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::physics::units::Seconds const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

inline constexpr auto
atlas_value_for(::security::EncryptedData const& v, value_tag)
-> decltype(v.value)
{
    return v.value;
}

} // namespace atlas


// Compound assignment operators for cross-type interactions
// These use ADL to be found automatically for atlas strong types
// The decltype ensures they only match when the binary operator is defined
namespace atlas {

namespace atlas_detail {
template <typename L, typename R, typename = void>
struct has_compound_op_modulo
: std::false_type
{ };

template <typename L, typename R>
struct has_compound_op_modulo<
    L,
    R,
    decltype((void)(atlas::undress(std::declval<L&>()) %=
        atlas::undress(std::declval<R const&>())))>
: std::true_type
{ };

template <typename L, typename R>
constexpr L &
compound_assign_impl_modulo(L & lhs, R const & rhs, std::true_type)
noexcept(noexcept(atlas::undress(lhs) %= atlas::undress(rhs)))
{
    atlas::undress(lhs) %= atlas::undress(rhs);
    return lhs;
}

template <typename L, typename R>
constexpr L &
compound_assign_impl_modulo(L & lhs, R const & rhs, std::false_type)
noexcept(noexcept(atlas::undress(lhs) = atlas::undress(lhs % rhs)))
{
    atlas::undress(lhs) = atlas::undress(lhs % rhs);
    return lhs;
}
}

template <
    typename L,
    typename R,
    typename std::enable_if<
        atlas::is_atlas_type<L>::value,
        bool>::type = true>
inline auto
operator%=(L & lhs, R const & rhs)
noexcept(noexcept(atlas_detail::compound_assign_impl_modulo(
    lhs,
    rhs,
    atlas_detail::has_compound_op_modulo<L, R>{})))
-> decltype(atlas_detail::compound_assign_impl_modulo(
    lhs,
    rhs,
    atlas_detail::has_compound_op_modulo<L, R>{}))
{
    return atlas_detail::compound_assign_impl_modulo(
        lhs,
        rhs,
        atlas_detail::has_compound_op_modulo<L, R>{});
}

namespace atlas_detail {
template <typename L, typename R, typename = void>
struct has_compound_op_bitand
: std::false_type
{ };

template <typename L, typename R>
struct has_compound_op_bitand<
    L,
    R,
    decltype((void)(atlas::undress(std::declval<L&>()) &=
        atlas::undress(std::declval<R const&>())))>
: std::true_type
{ };

template <typename L, typename R>
constexpr L &
compound_assign_impl_bitand(L & lhs, R const & rhs, std::true_type)
noexcept(noexcept(atlas::undress(lhs) &= atlas::undress(rhs)))
{
    atlas::undress(lhs) &= atlas::undress(rhs);
    return lhs;
}

template <typename L, typename R>
constexpr L &
compound_assign_impl_bitand(L & lhs, R const & rhs, std::false_type)
noexcept(noexcept(atlas::undress(lhs) = atlas::undress(lhs & rhs)))
{
    atlas::undress(lhs) = atlas::undress(lhs & rhs);
    return lhs;
}
}

template <
    typename L,
    typename R,
    typename std::enable_if<
        atlas::is_atlas_type<L>::value,
        bool>::type = true>
inline auto
operator&=(L & lhs, R const & rhs)
noexcept(noexcept(atlas_detail::compound_assign_impl_bitand(
    lhs,
    rhs,
    atlas_detail::has_compound_op_bitand<L, R>{})))
-> decltype(atlas_detail::compound_assign_impl_bitand(
    lhs,
    rhs,
    atlas_detail::has_compound_op_bitand<L, R>{}))
{
    return atlas_detail::compound_assign_impl_bitand(
        lhs,
        rhs,
        atlas_detail::has_compound_op_bitand<L, R>{});
}

namespace atlas_detail {
template <typename L, typename R, typename = void>
struct has_compound_op_times
: std::false_type
{ };

template <typename L, typename R>
struct has_compound_op_times<
    L,
    R,
    decltype((void)(atlas::undress(std::declval<L&>()) *=
        atlas::undress(std::declval<R const&>())))>
: std::true_type
{ };

template <typename L, typename R>
constexpr L &
compound_assign_impl_times(L & lhs, R const & rhs, std::true_type)
noexcept(noexcept(atlas::undress(lhs) *= atlas::undress(rhs)))
{
    atlas::undress(lhs) *= atlas::undress(rhs);
    return lhs;
}

template <typename L, typename R>
constexpr L &
compound_assign_impl_times(L & lhs, R const & rhs, std::false_type)
noexcept(noexcept(atlas::undress(lhs) = atlas::undress(lhs * rhs)))
{
    atlas::undress(lhs) = atlas::undress(lhs * rhs);
    return lhs;
}
}

template <
    typename L,
    typename R,
    typename std::enable_if<
        atlas::is_atlas_type<L>::value,
        bool>::type = true>
inline auto
operator*=(L & lhs, R const & rhs)
noexcept(noexcept(atlas_detail::compound_assign_impl_times(
    lhs,
    rhs,
    atlas_detail::has_compound_op_times<L, R>{})))
-> decltype(atlas_detail::compound_assign_impl_times(
    lhs,
    rhs,
    atlas_detail::has_compound_op_times<L, R>{}))
{
    return atlas_detail::compound_assign_impl_times(
        lhs,
        rhs,
        atlas_detail::has_compound_op_times<L, R>{});
}

namespace atlas_detail {
template <typename L, typename R, typename = void>
struct has_compound_op_plus
: std::false_type
{ };

template <typename L, typename R>
struct has_compound_op_plus<
    L,
    R,
    decltype((void)(atlas::undress(std::declval<L&>()) +=
        atlas::undress(std::declval<R const&>())))>
: std::true_type
{ };

template <typename L, typename R>
constexpr L &
compound_assign_impl_plus(L & lhs, R const & rhs, std::true_type)
noexcept(noexcept(atlas::undress(lhs) += atlas::undress(rhs)))
{
    atlas::undress(lhs) += atlas::undress(rhs);
    return lhs;
}

template <typename L, typename R>
constexpr L &
compound_assign_impl_plus(L & lhs, R const & rhs, std::false_type)
noexcept(noexcept(atlas::undress(lhs) = atlas::undress(lhs + rhs)))
{
    atlas::undress(lhs) = atlas::undress(lhs + rhs);
    return lhs;
}
}

template <
    typename L,
    typename R,
    typename std::enable_if<
        atlas::is_atlas_type<L>::value,
        bool>::type = true>
inline auto
operator+=(L & lhs, R const & rhs)
noexcept(noexcept(atlas_detail::compound_assign_impl_plus(
    lhs,
    rhs,
    atlas_detail::has_compound_op_plus<L, R>{})))
-> decltype(atlas_detail::compound_assign_impl_plus(
    lhs,
    rhs,
    atlas_detail::has_compound_op_plus<L, R>{}))
{
    return atlas_detail::compound_assign_impl_plus(
        lhs,
        rhs,
        atlas_detail::has_compound_op_plus<L, R>{});
}

namespace atlas_detail {
template <typename L, typename R, typename = void>
struct has_compound_op_minus
: std::false_type
{ };

template <typename L, typename R>
struct has_compound_op_minus<
    L,
    R,
    decltype((void)(atlas::undress(std::declval<L&>()) -=
        atlas::undress(std::declval<R const&>())))>
: std::true_type
{ };

template <typename L, typename R>
constexpr L &
compound_assign_impl_minus(L & lhs, R const & rhs, std::true_type)
noexcept(noexcept(atlas::undress(lhs) -= atlas::undress(rhs)))
{
    atlas::undress(lhs) -= atlas::undress(rhs);
    return lhs;
}

template <typename L, typename R>
constexpr L &
compound_assign_impl_minus(L & lhs, R const & rhs, std::false_type)
noexcept(noexcept(atlas::undress(lhs) = atlas::undress(lhs - rhs)))
{
    atlas::undress(lhs) = atlas::undress(lhs - rhs);
    return lhs;
}
}

template <
    typename L,
    typename R,
    typename std::enable_if<
        atlas::is_atlas_type<L>::value,
        bool>::type = true>
inline auto
operator-=(L & lhs, R const & rhs)
noexcept(noexcept(atlas_detail::compound_assign_impl_minus(
    lhs,
    rhs,
    atlas_detail::has_compound_op_minus<L, R>{})))
-> decltype(atlas_detail::compound_assign_impl_minus(
    lhs,
    rhs,
    atlas_detail::has_compound_op_minus<L, R>{}))
{
    return atlas_detail::compound_assign_impl_minus(
        lhs,
        rhs,
        atlas_detail::has_compound_op_minus<L, R>{});
}

namespace atlas_detail {
template <typename L, typename R, typename = void>
struct has_compound_op_divide
: std::false_type
{ };

template <typename L, typename R>
struct has_compound_op_divide<
    L,
    R,
    decltype((void)(atlas::undress(std::declval<L&>()) /=
        atlas::undress(std::declval<R const&>())))>
: std::true_type
{ };

template <typename L, typename R>
constexpr L &
compound_assign_impl_divide(L & lhs, R const & rhs, std::true_type)
noexcept(noexcept(atlas::undress(lhs) /= atlas::undress(rhs)))
{
    atlas::undress(lhs) /= atlas::undress(rhs);
    return lhs;
}

template <typename L, typename R>
constexpr L &
compound_assign_impl_divide(L & lhs, R const & rhs, std::false_type)
noexcept(noexcept(atlas::undress(lhs) = atlas::undress(lhs / rhs)))
{
    atlas::undress(lhs) = atlas::undress(lhs / rhs);
    return lhs;
}
}

template <
    typename L,
    typename R,
    typename std::enable_if<
        atlas::is_atlas_type<L>::value,
        bool>::type = true>
inline auto
operator/=(L & lhs, R const & rhs)
noexcept(noexcept(atlas_detail::compound_assign_impl_divide(
    lhs,
    rhs,
    atlas_detail::has_compound_op_divide<L, R>{})))
-> decltype(atlas_detail::compound_assign_impl_divide(
    lhs,
    rhs,
    atlas_detail::has_compound_op_divide<L, R>{}))
{
    return atlas_detail::compound_assign_impl_divide(
        lhs,
        rhs,
        atlas_detail::has_compound_op_divide<L, R>{});
}

namespace atlas_detail {
template <typename L, typename R, typename = void>
struct has_compound_op_lshift
: std::false_type
{ };

template <typename L, typename R>
struct has_compound_op_lshift<
    L,
    R,
    decltype((void)(atlas::undress(std::declval<L&>()) <<=
        atlas::undress(std::declval<R const&>())))>
: std::true_type
{ };

template <typename L, typename R>
constexpr L &
compound_assign_impl_lshift(L & lhs, R const & rhs, std::true_type)
noexcept(noexcept(atlas::undress(lhs) <<= atlas::undress(rhs)))
{
    atlas::undress(lhs) <<= atlas::undress(rhs);
    return lhs;
}

template <typename L, typename R>
constexpr L &
compound_assign_impl_lshift(L & lhs, R const & rhs, std::false_type)
noexcept(noexcept(atlas::undress(lhs) = atlas::undress(lhs << rhs)))
{
    atlas::undress(lhs) = atlas::undress(lhs << rhs);
    return lhs;
}
}

template <
    typename L,
    typename R,
    typename std::enable_if<
        atlas::is_atlas_type<L>::value,
        bool>::type = true>
inline auto
operator<<=(L & lhs, R const & rhs)
noexcept(noexcept(atlas_detail::compound_assign_impl_lshift(
    lhs,
    rhs,
    atlas_detail::has_compound_op_lshift<L, R>{})))
-> decltype(atlas_detail::compound_assign_impl_lshift(
    lhs,
    rhs,
    atlas_detail::has_compound_op_lshift<L, R>{}))
{
    return atlas_detail::compound_assign_impl_lshift(
        lhs,
        rhs,
        atlas_detail::has_compound_op_lshift<L, R>{});
}

namespace atlas_detail {
template <typename L, typename R, typename = void>
struct has_compound_op_rshift
: std::false_type
{ };

template <typename L, typename R>
struct has_compound_op_rshift<
    L,
    R,
    decltype((void)(atlas::undress(std::declval<L&>()) >>=
        atlas::undress(std::declval<R const&>())))>
: std::true_type
{ };

template <typename L, typename R>
constexpr L &
compound_assign_impl_rshift(L & lhs, R const & rhs, std::true_type)
noexcept(noexcept(atlas::undress(lhs) >>= atlas::undress(rhs)))
{
    atlas::undress(lhs) >>= atlas::undress(rhs);
    return lhs;
}

template <typename L, typename R>
constexpr L &
compound_assign_impl_rshift(L & lhs, R const & rhs, std::false_type)
noexcept(noexcept(atlas::undress(lhs) = atlas::undress(lhs >> rhs)))
{
    atlas::undress(lhs) = atlas::undress(lhs >> rhs);
    return lhs;
}
}

template <
    typename L,
    typename R,
    typename std::enable_if<
        atlas::is_atlas_type<L>::value,
        bool>::type = true>
inline auto
operator>>=(L & lhs, R const & rhs)
noexcept(noexcept(atlas_detail::compound_assign_impl_rshift(
    lhs,
    rhs,
    atlas_detail::has_compound_op_rshift<L, R>{})))
-> decltype(atlas_detail::compound_assign_impl_rshift(
    lhs,
    rhs,
    atlas_detail::has_compound_op_rshift<L, R>{}))
{
    return atlas_detail::compound_assign_impl_rshift(
        lhs,
        rhs,
        atlas_detail::has_compound_op_rshift<L, R>{});
}

namespace atlas_detail {
template <typename L, typename R, typename = void>
struct has_compound_op_bitxor
: std::false_type
{ };

template <typename L, typename R>
struct has_compound_op_bitxor<
    L,
    R,
    decltype((void)(atlas::undress(std::declval<L&>()) ^=
        atlas::undress(std::declval<R const&>())))>
: std::true_type
{ };

template <typename L, typename R>
constexpr L &
compound_assign_impl_bitxor(L & lhs, R const & rhs, std::true_type)
noexcept(noexcept(atlas::undress(lhs) ^= atlas::undress(rhs)))
{
    atlas::undress(lhs) ^= atlas::undress(rhs);
    return lhs;
}

template <typename L, typename R>
constexpr L &
compound_assign_impl_bitxor(L & lhs, R const & rhs, std::false_type)
noexcept(noexcept(atlas::undress(lhs) = atlas::undress(lhs ^ rhs)))
{
    atlas::undress(lhs) = atlas::undress(lhs ^ rhs);
    return lhs;
}
}

template <
    typename L,
    typename R,
    typename std::enable_if<
        atlas::is_atlas_type<L>::value,
        bool>::type = true>
inline auto
operator^=(L & lhs, R const & rhs)
noexcept(noexcept(atlas_detail::compound_assign_impl_bitxor(
    lhs,
    rhs,
    atlas_detail::has_compound_op_bitxor<L, R>{})))
-> decltype(atlas_detail::compound_assign_impl_bitxor(
    lhs,
    rhs,
    atlas_detail::has_compound_op_bitxor<L, R>{}))
{
    return atlas_detail::compound_assign_impl_bitxor(
        lhs,
        rhs,
        atlas_detail::has_compound_op_bitxor<L, R>{});
}

namespace atlas_detail {
template <typename L, typename R, typename = void>
struct has_compound_op_bitor
: std::false_type
{ };

template <typename L, typename R>
struct has_compound_op_bitor<
    L,
    R,
    decltype((void)(atlas::undress(std::declval<L&>()) |=
        atlas::undress(std::declval<R const&>())))>
: std::true_type
{ };

template <typename L, typename R>
constexpr L &
compound_assign_impl_bitor(L & lhs, R const & rhs, std::true_type)
noexcept(noexcept(atlas::undress(lhs) |= atlas::undress(rhs)))
{
    atlas::undress(lhs) |= atlas::undress(rhs);
    return lhs;
}

template <typename L, typename R>
constexpr L &
compound_assign_impl_bitor(L & lhs, R const & rhs, std::false_type)
noexcept(noexcept(atlas::undress(lhs) = atlas::undress(lhs | rhs)))
{
    atlas::undress(lhs) = atlas::undress(lhs | rhs);
    return lhs;
}
}

template <
    typename L,
    typename R,
    typename std::enable_if<
        atlas::is_atlas_type<L>::value,
        bool>::type = true>
inline auto
operator|=(L & lhs, R const & rhs)
noexcept(noexcept(atlas_detail::compound_assign_impl_bitor(
    lhs,
    rhs,
    atlas_detail::has_compound_op_bitor<L, R>{})))
-> decltype(atlas_detail::compound_assign_impl_bitor(
    lhs,
    rhs,
    atlas_detail::has_compound_op_bitor<L, R>{}))
{
    return atlas_detail::compound_assign_impl_bitor(
        lhs,
        rhs,
        atlas_detail::has_compound_op_bitor<L, R>{});
}

} // namespace atlas


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////
inline constexpr finance::core::Money
operator*(physics::units::Meters lhs, finance::core::Money rhs)
noexcept(
    noexcept(lhs.value * rhs.value) &&
    std::is_nothrow_constructible<finance::core::Money, decltype(lhs.value * rhs.value)>::value)
{
    return finance::core::Money{lhs.value * rhs.value};
}

namespace app::config {

inline constexpr ConfigKey
operator+(ConfigKey lhs, std::string rhs)
noexcept(
    noexcept(lhs.value + rhs) &&
    std::is_nothrow_constructible<ConfigKey, decltype(lhs.value + rhs)>::value)
{
    return ConfigKey{lhs.value + rhs};
}

inline constexpr ConfigKey
operator+(std::string lhs, ConfigKey rhs)
noexcept(
    noexcept(lhs + atlas::undress(rhs)) &&
    std::is_nothrow_constructible<ConfigKey, decltype(lhs + atlas::undress(rhs))>::value)
{
    return ConfigKey{lhs + atlas::undress(rhs)};
}

} // namespace app::config

namespace concurrency {

inline ThreadId
operator+(ThreadId lhs, ThreadId rhs)
noexcept(
    noexcept(lhs.value + rhs.value) &&
    std::is_nothrow_constructible<ThreadId, decltype(lhs.value + rhs.value)>::value)
{
    return ThreadId{lhs.value + rhs.value};
}

} // namespace concurrency

namespace data {

inline constexpr ByteCount
operator+(ByteCount lhs, ByteCount rhs)
noexcept(
    noexcept(lhs.value + rhs.value) &&
    std::is_nothrow_constructible<ByteCount, decltype(lhs.value + rhs.value)>::value)
{
    return ByteCount{lhs.value + rhs.value};
}

inline constexpr ByteCount
operator-(ByteCount lhs, ByteCount rhs)
noexcept(
    noexcept(lhs.value - rhs.value) &&
    std::is_nothrow_constructible<ByteCount, decltype(lhs.value - rhs.value)>::value)
{
    return ByteCount{lhs.value - rhs.value};
}

inline constexpr ByteCount
operator*(ByteCount lhs, size_t rhs)
noexcept(
    noexcept(lhs.value * rhs) &&
    std::is_nothrow_constructible<ByteCount, decltype(lhs.value * rhs)>::value)
{
    return ByteCount{lhs.value * rhs};
}

inline constexpr ByteCount
operator/(ByteCount lhs, size_t rhs)
noexcept(
    noexcept(lhs.value / rhs) &&
    std::is_nothrow_constructible<ByteCount, decltype(lhs.value / rhs)>::value)
{
    return ByteCount{lhs.value / rhs};
}

inline constexpr ByteCount
operator%(ByteCount lhs, ByteCount rhs)
noexcept(
    noexcept(lhs.value % rhs.value) &&
    std::is_nothrow_constructible<ByteCount, decltype(lhs.value % rhs.value)>::value)
{
    return ByteCount{lhs.value % rhs.value};
}

} // namespace data

namespace finance::core {

inline constexpr Money
operator+(Money lhs, Money rhs)
noexcept(
    noexcept(lhs.value + rhs.value) &&
    std::is_nothrow_constructible<Money, decltype(lhs.value + rhs.value)>::value)
{
    return Money{lhs.value + rhs.value};
}

inline constexpr Money
operator-(Money lhs, Money rhs)
noexcept(
    noexcept(lhs.value - rhs.value) &&
    std::is_nothrow_constructible<Money, decltype(lhs.value - rhs.value)>::value)
{
    return Money{lhs.value - rhs.value};
}

inline constexpr Money
operator*(Money lhs, double rhs)
noexcept(
    noexcept(lhs.value * rhs) &&
    std::is_nothrow_constructible<Money, decltype(lhs.value * rhs)>::value)
{
    return Money{lhs.value * rhs};
}

inline constexpr Money
operator/(Money lhs, double rhs)
noexcept(
    noexcept(lhs.value / rhs) &&
    std::is_nothrow_constructible<Money, decltype(lhs.value / rhs)>::value)
{
    return Money{lhs.value / rhs};
}

inline constexpr double
operator/(Money lhs, Money rhs)
noexcept(
    noexcept(lhs.value / rhs.value) &&
    std::is_nothrow_constructible<double, decltype(lhs.value / rhs.value)>::value)
{
    return double{lhs.value / rhs.value};
}

} // namespace finance::core

namespace geo {

inline constexpr Latitude
operator+(Latitude lhs, double rhs)
noexcept(
    noexcept(lhs.value + rhs) &&
    std::is_nothrow_constructible<Latitude, decltype(lhs.value + rhs)>::value)
{
    return Latitude{lhs.value + rhs};
}

inline constexpr Longitude
operator+(Longitude lhs, double rhs)
noexcept(
    noexcept(lhs.value + rhs) &&
    std::is_nothrow_constructible<Longitude, decltype(lhs.value + rhs)>::value)
{
    return Longitude{lhs.value + rhs};
}

inline constexpr double
operator-(Latitude lhs, Latitude rhs)
noexcept(
    noexcept(lhs.value - rhs.value) &&
    std::is_nothrow_constructible<double, decltype(lhs.value - rhs.value)>::value)
{
    return double{lhs.value - rhs.value};
}

inline constexpr double
operator-(Longitude lhs, Longitude rhs)
noexcept(
    noexcept(lhs.value - rhs.value) &&
    std::is_nothrow_constructible<double, decltype(lhs.value - rhs.value)>::value)
{
    return double{lhs.value - rhs.value};
}

} // namespace geo

namespace graphics::color {

inline constexpr RedChannel
operator+(RedChannel lhs, RedChannel rhs)
noexcept(
    noexcept(lhs.value + rhs.value) &&
    std::is_nothrow_constructible<RedChannel, decltype(lhs.value + rhs.value)>::value)
{
    return RedChannel{lhs.value + rhs.value};
}

inline constexpr RedChannel
operator|(RedChannel lhs, RedChannel rhs)
noexcept(
    noexcept(lhs.value | rhs.value) &&
    std::is_nothrow_constructible<RedChannel, decltype(lhs.value | rhs.value)>::value)
{
    return RedChannel{lhs.value | rhs.value};
}

inline constexpr RedChannel
operator&(RedChannel lhs, RedChannel rhs)
noexcept(
    noexcept(lhs.value & rhs.value) &&
    std::is_nothrow_constructible<RedChannel, decltype(lhs.value & rhs.value)>::value)
{
    return RedChannel{lhs.value & rhs.value};
}

inline constexpr RedChannel
operator^(RedChannel lhs, RedChannel rhs)
noexcept(
    noexcept(lhs.value ^ rhs.value) &&
    std::is_nothrow_constructible<RedChannel, decltype(lhs.value ^ rhs.value)>::value)
{
    return RedChannel{lhs.value ^ rhs.value};
}

} // namespace graphics::color

namespace math {

template <std::integral T>
constexpr T
operator+(T lhs, T rhs)
noexcept(
    noexcept(lhs.value + atlas::undress(rhs)) &&
    std::is_nothrow_constructible<T, decltype(lhs.value + atlas::undress(rhs))>::value)
{
    return T{lhs.value + atlas::undress(rhs)};
}

template <typename U, typename std::enable_if<std::is_floating_point<U>::value, bool>::type = true>
constexpr U
operator*(U lhs, U rhs)
noexcept(
    noexcept(lhs.value * atlas::undress(rhs)) &&
    std::is_nothrow_constructible<U, decltype(lhs.value * atlas::undress(rhs))>::value)
{
    return U{lhs.value * atlas::undress(rhs)};
}

#if __cpp_concepts >= 201907L
template <std::integral V>
#else
template <typename V, typename std::enable_if<sizeof(V) <= 8, bool>::type = true>
#endif
constexpr V
operator-(V lhs, V rhs)
noexcept(
    noexcept(lhs.value - atlas::undress(rhs)) &&
    std::is_nothrow_constructible<V, decltype(lhs.value - atlas::undress(rhs))>::value)
{
    return V{lhs.value - atlas::undress(rhs)};
}

} // namespace math

namespace math::rational {

inline constexpr Numerator
operator+(Numerator lhs, Numerator rhs)
noexcept(
    noexcept(lhs.value + rhs.value) &&
    std::is_nothrow_constructible<Numerator, decltype(lhs.value + rhs.value)>::value)
{
    return Numerator{lhs.value + rhs.value};
}

inline constexpr Numerator
operator-(Numerator lhs, Numerator rhs)
noexcept(
    noexcept(lhs.value - rhs.value) &&
    std::is_nothrow_constructible<Numerator, decltype(lhs.value - rhs.value)>::value)
{
    return Numerator{lhs.value - rhs.value};
}

inline constexpr Numerator
operator*(Numerator lhs, Numerator rhs)
noexcept(
    noexcept(lhs.value * rhs.value) &&
    std::is_nothrow_constructible<Numerator, decltype(lhs.value * rhs.value)>::value)
{
    return Numerator{lhs.value * rhs.value};
}

inline constexpr Numerator
operator*(Numerator lhs, Denominator rhs)
noexcept(
    noexcept(lhs.value * rhs.value) &&
    std::is_nothrow_constructible<Numerator, decltype(lhs.value * rhs.value)>::value)
{
    return Numerator{lhs.value * rhs.value};
}

inline constexpr Denominator
operator*(Denominator lhs, Denominator rhs)
noexcept(
    noexcept(lhs.value * rhs.value) &&
    std::is_nothrow_constructible<Denominator, decltype(lhs.value * rhs.value)>::value)
{
    return Denominator{lhs.value * rhs.value};
}

} // namespace math::rational

namespace net::ipv4 {

inline constexpr Octet
operator&(Octet lhs, Octet rhs)
noexcept(
    noexcept(lhs.value & rhs.value) &&
    std::is_nothrow_constructible<Octet, decltype(lhs.value & rhs.value)>::value)
{
    return Octet{lhs.value & rhs.value};
}

inline constexpr Octet
operator|(Octet lhs, Octet rhs)
noexcept(
    noexcept(lhs.value | rhs.value) &&
    std::is_nothrow_constructible<Octet, decltype(lhs.value | rhs.value)>::value)
{
    return Octet{lhs.value | rhs.value};
}

inline constexpr Octet
operator^(Octet lhs, Octet rhs)
noexcept(
    noexcept(lhs.value ^ rhs.value) &&
    std::is_nothrow_constructible<Octet, decltype(lhs.value ^ rhs.value)>::value)
{
    return Octet{lhs.value ^ rhs.value};
}

inline constexpr Octet
operator<<(Octet lhs, int rhs)
noexcept(
    noexcept(lhs.value << rhs) &&
    std::is_nothrow_constructible<Octet, decltype(lhs.value << rhs)>::value)
{
    return Octet{lhs.value << rhs};
}

inline constexpr Octet
operator>>(Octet lhs, int rhs)
noexcept(
    noexcept(lhs.value >> rhs) &&
    std::is_nothrow_constructible<Octet, decltype(lhs.value >> rhs)>::value)
{
    return Octet{lhs.value >> rhs};
}

} // namespace net::ipv4

namespace physics::units {

inline constexpr Meters
operator+(Meters lhs, Meters rhs)
noexcept(
    noexcept(lhs.value + rhs.value) &&
    std::is_nothrow_constructible<Meters, decltype(lhs.value + rhs.value)>::value)
{
    return Meters{lhs.value + rhs.value};
}

inline constexpr Meters
operator-(Meters lhs, Meters rhs)
noexcept(
    noexcept(lhs.value - rhs.value) &&
    std::is_nothrow_constructible<Meters, decltype(lhs.value - rhs.value)>::value)
{
    return Meters{lhs.value - rhs.value};
}

inline constexpr Meters
operator*(Meters lhs, double rhs)
noexcept(
    noexcept(lhs.value * rhs) &&
    std::is_nothrow_constructible<Meters, decltype(lhs.value * rhs)>::value)
{
    return Meters{lhs.value * rhs};
}

inline constexpr Meters
operator*(double lhs, Meters rhs)
noexcept(
    noexcept(lhs * rhs.value) &&
    std::is_nothrow_constructible<Meters, decltype(lhs * rhs.value)>::value)
{
    return Meters{lhs * rhs.value};
}

inline constexpr Meters
operator/(Meters lhs, double rhs)
noexcept(
    noexcept(lhs.value / rhs) &&
    std::is_nothrow_constructible<Meters, decltype(lhs.value / rhs)>::value)
{
    return Meters{lhs.value / rhs};
}

inline constexpr double
operator/(Meters lhs, Meters rhs)
noexcept(
    noexcept(lhs.value / rhs.value) &&
    std::is_nothrow_constructible<double, decltype(lhs.value / rhs.value)>::value)
{
    return double{lhs.value / rhs.value};
}

inline constexpr Seconds
operator+(Seconds lhs, Seconds rhs)
noexcept(
    noexcept(lhs.value + rhs.value) &&
    std::is_nothrow_constructible<Seconds, decltype(lhs.value + rhs.value)>::value)
{
    return Seconds{lhs.value + rhs.value};
}

inline constexpr Seconds
operator-(Seconds lhs, Seconds rhs)
noexcept(
    noexcept(lhs.value - rhs.value) &&
    std::is_nothrow_constructible<Seconds, decltype(lhs.value - rhs.value)>::value)
{
    return Seconds{lhs.value - rhs.value};
}

inline constexpr Seconds
operator*(Seconds lhs, double rhs)
noexcept(
    noexcept(lhs.value * rhs) &&
    std::is_nothrow_constructible<Seconds, decltype(lhs.value * rhs)>::value)
{
    return Seconds{lhs.value * rhs};
}

inline constexpr Seconds
operator*(double lhs, Seconds rhs)
noexcept(
    noexcept(lhs * rhs.value) &&
    std::is_nothrow_constructible<Seconds, decltype(lhs * rhs.value)>::value)
{
    return Seconds{lhs * rhs.value};
}

inline constexpr Seconds
operator/(Seconds lhs, double rhs)
noexcept(
    noexcept(lhs.value / rhs) &&
    std::is_nothrow_constructible<Seconds, decltype(lhs.value / rhs)>::value)
{
    return Seconds{lhs.value / rhs};
}

inline constexpr double
operator/(Seconds lhs, Seconds rhs)
noexcept(
    noexcept(lhs.value / rhs.value) &&
    std::is_nothrow_constructible<double, decltype(lhs.value / rhs.value)>::value)
{
    return double{lhs.value / rhs.value};
}

inline constexpr MetersPerSecond
operator/(Meters lhs, Seconds rhs)
noexcept(
    noexcept(lhs.value / rhs.value) &&
    std::is_nothrow_constructible<MetersPerSecond, decltype(lhs.value / rhs.value)>::value)
{
    return MetersPerSecond{lhs.value / rhs.value};
}

inline constexpr Meters
operator*(MetersPerSecond lhs, Seconds rhs)
noexcept(
    noexcept(lhs.value * rhs.value) &&
    std::is_nothrow_constructible<Meters, decltype(lhs.value * rhs.value)>::value)
{
    return Meters{lhs.value * rhs.value};
}

inline constexpr Seconds
operator/(Meters lhs, MetersPerSecond rhs)
noexcept(
    noexcept(lhs.value / rhs.value) &&
    std::is_nothrow_constructible<Seconds, decltype(lhs.value / rhs.value)>::value)
{
    return Seconds{lhs.value / rhs.value};
}

} // namespace physics::units

namespace security {

inline constexpr EncryptedData
operator+(EncryptedData lhs, EncryptedData rhs)
noexcept(
    noexcept(lhs.value + rhs.value) &&
    std::is_nothrow_constructible<EncryptedData, decltype(lhs.value + rhs.value)>::value)
{
    return EncryptedData{lhs.value + rhs.value};
}

} // namespace security

#endif // EXAMPLE_INTERACTIONS_9117164626BE44E4F68F5D2676C61DCF66202C3D
