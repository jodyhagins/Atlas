#ifndef EXAMPLE_714EA71F36DDFEAD94BBAEF0E27280AAE0D6D0B7
#define EXAMPLE_714EA71F36DDFEAD94BBAEF0E27280AAE0D6D0B7

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v0.1.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#include <functional>
#include <string>
#include <type_traits>
#include <utility>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// This is boilerplate that is part of every Atlas interaction file.
// Nothing to see here, move along.

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif
#include <type_traits>
#include <utility>

namespace atlas {

struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <typename T, typename = void>
struct IsAtlasType
: std::false_type
{ };

template <typename T>
struct IsAtlasType<T, void_t<typename T::atlas_value_type>>
: std::true_type
{ };

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;
template <typename T, typename U = void>
using enable_if = typename std::enable_if<T::value, U>::type;

template <typename T>
using _t = typename T::type;

void atlas_value();

template <typename T>
constexpr T &
value(T & val, PriorityTag<0>)
{
    return val;
}

template <typename T, typename U = typename T::atlas_value_type>
using val_t = _t<std::conditional<std::is_const<T>::value, U const &, U &>>;

template <typename T, typename U = val_t<T>>
constexpr auto
value(T & val, PriorityTag<1>)
-> decltype(atlas::atlas_detail::value(static_cast<U>(val), value_tag{}))
{
    return atlas::atlas_detail::value(static_cast<U>(val), value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<2>)
-> decltype(atlas_value(t, atlas::value_tag{}))
{
    return atlas_value(t, atlas::value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<3>)
-> decltype(atlas_value(t))
{
    return atlas_value(t);
}

class Value
{
    template <
        typename U,
        typename T,
        typename V = _t<std::conditional<is_lref<U &&>::value, T &, T>>>
    static constexpr V rval(T && t)
    {
        return t;
    }

public:
    template <typename T>
    constexpr auto operator () (T && t) const
    -> decltype(rval<T>(atlas_detail::value(t, atlas_detail::value_tag{})))
    {
        return rval<T>(atlas_detail::value(t, atlas_detail::value_tag{}));
    }
};

} // namespace atlas_detail

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto value = atlas_detail::Value{};
#else
template <typename T>
constexpr auto
value(T && t)
-> decltype(atlas_detail::Value{}(std::forward<T>(t)))
{
    return atlas_detail::Value{}(std::forward<T>(t));
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////

namespace finance {
namespace core {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: finance::core
 * - type_name: Money
 * - description: strong double; +, -, *, /, ==, !=, <, <=, >, >=, <<, hash
 * - default_value: "0.0"
 */
struct Money
: private atlas::strong_type_tag
{
    double value{0.0};

    using atlas_value_type = double;

    constexpr explicit Money() = default;
    constexpr Money(Money const &) = default;
    constexpr Money(Money &&) = default;
    constexpr Money & operator = (Money const &) = default;
    constexpr Money & operator = (Money &&) = default;
    constexpr ~Money() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<double, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Money(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator double const & () const { return value; }
    constexpr explicit operator double & () { return value; }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr Money & operator *= (
        Money & lhs,
        Money const & rhs)
    noexcept(noexcept(std::declval<double&>() *= std::declval<double const&>()))
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr Money operator * (
        Money lhs,
        Money const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr Money & operator += (
        Money & lhs,
        Money const & rhs)
    noexcept(noexcept(std::declval<double&>() += std::declval<double const&>()))
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr Money operator + (
        Money lhs,
        Money const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr Money & operator -= (
        Money & lhs,
        Money const & rhs)
    noexcept(noexcept(std::declval<double&>() -= std::declval<double const&>()))
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr Money operator - (
        Money lhs,
        Money const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr Money & operator /= (
        Money & lhs,
        Money const & rhs)
    noexcept(noexcept(std::declval<double&>() /= std::declval<double const&>()))
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr Money operator / (
        Money lhs,
        Money const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

    /**
     * Apply << assignment to the wrapped objects.
     */
    friend constexpr Money & operator <<= (
        Money & lhs,
        Money const & rhs)
    noexcept(noexcept(std::declval<double&>() <<= std::declval<double const&>()))
    {
        lhs.value <<= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator << to the wrapped object.
     */
    friend constexpr Money operator << (
        Money lhs,
        Money const & rhs)
    noexcept(noexcept(lhs <<= rhs))
    {
        lhs <<= rhs;
        return lhs;
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Money const & lhs,
        Money const & rhs)
    noexcept(noexcept(std::declval<double const&>() != std::declval<double const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value < @p rhs.value?
     */
    friend constexpr bool operator < (
        Money const & lhs,
        Money const & rhs)
    noexcept(noexcept(std::declval<double const&>() < std::declval<double const&>()))
    {
        return lhs.value < rhs.value;
    }

    /**
     * Is @p lhs.value <= @p rhs.value?
     */
    friend constexpr bool operator <= (
        Money const & lhs,
        Money const & rhs)
    noexcept(noexcept(std::declval<double const&>() <= std::declval<double const&>()))
    {
        return lhs.value <= rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Money const & lhs,
        Money const & rhs)
    noexcept(noexcept(std::declval<double const&>() == std::declval<double const&>()))
    {
        return lhs.value == rhs.value;
    }

    /**
     * Is @p lhs.value > @p rhs.value?
     */
    friend constexpr bool operator > (
        Money const & lhs,
        Money const & rhs)
    noexcept(noexcept(std::declval<double const&>() > std::declval<double const&>()))
    {
        return lhs.value > rhs.value;
    }

    /**
     * Is @p lhs.value >= @p rhs.value?
     */
    friend constexpr bool operator >= (
        Money const & lhs,
        Money const & rhs)
    noexcept(noexcept(std::declval<double const&>() >= std::declval<double const&>()))
    {
        return lhs.value >= rhs.value;
    }
};
} // namespace core
} // namespace finance


/**
 * @brief std::hash specialization for finance::core::Money
 *
 * Delegates to std::hash of the underlying type double
 */
template <>
struct std::hash<finance::core::Money>
{
    constexpr std::size_t operator () (finance::core::Money const & t) const
    noexcept(
        noexcept(std::hash<double>{}(
            std::declval<double const &>())))
    {
        return std::hash<double>{}(
            static_cast<double const &>(t));
    }
};
namespace ids {
namespace v1 {

/**
 * @brief Strong type wrapper for unsigned long
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: ids::v1
 * - type_name: UserId
 * - description: strong unsigned long; ==, !=, <=>, hash, no-constexpr-hash
 * - default_value: "0"
 */
class UserId
: private atlas::strong_type_tag
{
    unsigned long value{0};

public:
    using atlas_value_type = unsigned long;

    constexpr explicit UserId() = default;
    constexpr UserId(UserId const &) = default;
    constexpr UserId(UserId &&) = default;
    constexpr UserId & operator = (UserId const &) = default;
    constexpr UserId & operator = (UserId &&) = default;
    constexpr ~UserId() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<unsigned long, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit UserId(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator unsigned long const & () const { return value; }
    constexpr explicit operator unsigned long & () { return value; }

    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        UserId const &,
        UserId const &) = default;

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        UserId const & lhs,
        UserId const & rhs)
    noexcept(noexcept(std::declval<unsigned long const&>() != std::declval<unsigned long const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        UserId const & lhs,
        UserId const & rhs)
    noexcept(noexcept(std::declval<unsigned long const&>() == std::declval<unsigned long const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace v1
} // namespace ids


/**
 * @brief std::hash specialization for ids::v1::UserId
 *
 * Delegates to std::hash of the underlying type unsigned long
 */
template <>
struct std::hash<ids::v1::UserId>
{
    std::size_t operator () (ids::v1::UserId const & t) const
    noexcept(
        noexcept(std::hash<unsigned long>{}(
            std::declval<unsigned long const &>())))
    {
        return std::hash<unsigned long>{}(
            static_cast<unsigned long const &>(t));
    }
};
namespace physics {
namespace units {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: physics::units
 * - type_name: Meters
 * - description: strong double; +, -, *, /, u-, ==, !=, <=>
 * - default_value: ""
 */
struct Meters
: private atlas::strong_type_tag
{
    double value;

    using atlas_value_type = double;

    constexpr explicit Meters() = default;
    constexpr Meters(Meters const &) = default;
    constexpr Meters(Meters &&) = default;
    constexpr Meters & operator = (Meters const &) = default;
    constexpr Meters & operator = (Meters &&) = default;
    constexpr ~Meters() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<double, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Meters(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator double const & () const { return value; }
    constexpr explicit operator double & () { return value; }

    /**
     * Apply the unary - operator to the wrapped object.
     */
    friend constexpr Meters operator - (Meters const & t)
    noexcept(
        noexcept(- std::declval<double const&>()) &&
        std::is_nothrow_assignable<
            double&,
            decltype(- std::declval<double const&>())>::value)
    {
        auto result = t;
        result.value = - t.value;
        return result;
    }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr Meters & operator *= (
        Meters & lhs,
        Meters const & rhs)
    noexcept(noexcept(std::declval<double&>() *= std::declval<double const&>()))
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr Meters operator * (
        Meters lhs,
        Meters const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr Meters & operator += (
        Meters & lhs,
        Meters const & rhs)
    noexcept(noexcept(std::declval<double&>() += std::declval<double const&>()))
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr Meters operator + (
        Meters lhs,
        Meters const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr Meters & operator -= (
        Meters & lhs,
        Meters const & rhs)
    noexcept(noexcept(std::declval<double&>() -= std::declval<double const&>()))
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr Meters operator - (
        Meters lhs,
        Meters const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr Meters & operator /= (
        Meters & lhs,
        Meters const & rhs)
    noexcept(noexcept(std::declval<double&>() /= std::declval<double const&>()))
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr Meters operator / (
        Meters lhs,
        Meters const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        Meters const &,
        Meters const &) = default;

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Meters const & lhs,
        Meters const & rhs)
    noexcept(noexcept(std::declval<double const&>() != std::declval<double const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Meters const & lhs,
        Meters const & rhs)
    noexcept(noexcept(std::declval<double const&>() == std::declval<double const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace units
} // namespace physics

namespace physics {
namespace units {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: physics::units
 * - type_name: Seconds
 * - description: strong double; +, -, *, /, u-, ==, !=, <=>
 * - default_value: ""
 */
struct Seconds
: private atlas::strong_type_tag
{
    double value;

    using atlas_value_type = double;

    constexpr explicit Seconds() = default;
    constexpr Seconds(Seconds const &) = default;
    constexpr Seconds(Seconds &&) = default;
    constexpr Seconds & operator = (Seconds const &) = default;
    constexpr Seconds & operator = (Seconds &&) = default;
    constexpr ~Seconds() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<double, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Seconds(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator double const & () const { return value; }
    constexpr explicit operator double & () { return value; }

    /**
     * Apply the unary - operator to the wrapped object.
     */
    friend constexpr Seconds operator - (Seconds const & t)
    noexcept(
        noexcept(- std::declval<double const&>()) &&
        std::is_nothrow_assignable<
            double&,
            decltype(- std::declval<double const&>())>::value)
    {
        auto result = t;
        result.value = - t.value;
        return result;
    }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr Seconds & operator *= (
        Seconds & lhs,
        Seconds const & rhs)
    noexcept(noexcept(std::declval<double&>() *= std::declval<double const&>()))
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr Seconds operator * (
        Seconds lhs,
        Seconds const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr Seconds & operator += (
        Seconds & lhs,
        Seconds const & rhs)
    noexcept(noexcept(std::declval<double&>() += std::declval<double const&>()))
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr Seconds operator + (
        Seconds lhs,
        Seconds const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr Seconds & operator -= (
        Seconds & lhs,
        Seconds const & rhs)
    noexcept(noexcept(std::declval<double&>() -= std::declval<double const&>()))
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr Seconds operator - (
        Seconds lhs,
        Seconds const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr Seconds & operator /= (
        Seconds & lhs,
        Seconds const & rhs)
    noexcept(noexcept(std::declval<double&>() /= std::declval<double const&>()))
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr Seconds operator / (
        Seconds lhs,
        Seconds const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        Seconds const &,
        Seconds const &) = default;

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Seconds const & lhs,
        Seconds const & rhs)
    noexcept(noexcept(std::declval<double const&>() != std::declval<double const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Seconds const & lhs,
        Seconds const & rhs)
    noexcept(noexcept(std::declval<double const&>() == std::declval<double const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace units
} // namespace physics

namespace physics {
namespace units {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: physics::units
 * - type_name: MetersPerSecond
 * - description: strong double; +, -, *, /, u-, ==, !=, <=>
 * - default_value: ""
 */
struct MetersPerSecond
: private atlas::strong_type_tag
{
    double value;

    using atlas_value_type = double;

    constexpr explicit MetersPerSecond() = default;
    constexpr MetersPerSecond(MetersPerSecond const &) = default;
    constexpr MetersPerSecond(MetersPerSecond &&) = default;
    constexpr MetersPerSecond & operator = (MetersPerSecond const &) = default;
    constexpr MetersPerSecond & operator = (MetersPerSecond &&) = default;
    constexpr ~MetersPerSecond() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<double, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit MetersPerSecond(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator double const & () const { return value; }
    constexpr explicit operator double & () { return value; }

    /**
     * Apply the unary - operator to the wrapped object.
     */
    friend constexpr MetersPerSecond operator - (MetersPerSecond const & t)
    noexcept(
        noexcept(- std::declval<double const&>()) &&
        std::is_nothrow_assignable<
            double&,
            decltype(- std::declval<double const&>())>::value)
    {
        auto result = t;
        result.value = - t.value;
        return result;
    }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr MetersPerSecond & operator *= (
        MetersPerSecond & lhs,
        MetersPerSecond const & rhs)
    noexcept(noexcept(std::declval<double&>() *= std::declval<double const&>()))
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr MetersPerSecond operator * (
        MetersPerSecond lhs,
        MetersPerSecond const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr MetersPerSecond & operator += (
        MetersPerSecond & lhs,
        MetersPerSecond const & rhs)
    noexcept(noexcept(std::declval<double&>() += std::declval<double const&>()))
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr MetersPerSecond operator + (
        MetersPerSecond lhs,
        MetersPerSecond const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr MetersPerSecond & operator -= (
        MetersPerSecond & lhs,
        MetersPerSecond const & rhs)
    noexcept(noexcept(std::declval<double&>() -= std::declval<double const&>()))
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr MetersPerSecond operator - (
        MetersPerSecond lhs,
        MetersPerSecond const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr MetersPerSecond & operator /= (
        MetersPerSecond & lhs,
        MetersPerSecond const & rhs)
    noexcept(noexcept(std::declval<double&>() /= std::declval<double const&>()))
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr MetersPerSecond operator / (
        MetersPerSecond lhs,
        MetersPerSecond const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        MetersPerSecond const &,
        MetersPerSecond const &) = default;

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        MetersPerSecond const & lhs,
        MetersPerSecond const & rhs)
    noexcept(noexcept(std::declval<double const&>() != std::declval<double const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        MetersPerSecond const & lhs,
        MetersPerSecond const & rhs)
    noexcept(noexcept(std::declval<double const&>() == std::declval<double const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace units
} // namespace physics

namespace data {

/**
 * @brief Strong type wrapper for size_t
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: data
 * - type_name: ByteCount
 * - description: strong size_t; +, -, *, /, %, ==, !=, <, <=, >, >=, ++, --, <<
 * - default_value: "0"
 */
struct ByteCount
: private atlas::strong_type_tag
{
    size_t value{0};

    using atlas_value_type = size_t;

    constexpr explicit ByteCount() = default;
    constexpr ByteCount(ByteCount const &) = default;
    constexpr ByteCount(ByteCount &&) = default;
    constexpr ByteCount & operator = (ByteCount const &) = default;
    constexpr ByteCount & operator = (ByteCount &&) = default;
    constexpr ~ByteCount() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<size_t, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ByteCount(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator size_t const & () const { return value; }
    constexpr explicit operator size_t & () { return value; }

    /**
     * Apply the prefix ++ operator to the wrapped object.
     */
    friend constexpr ByteCount & operator ++ (ByteCount & t)
    noexcept(noexcept(++std::declval<size_t&>()))
    {
        ++t.value;
        return t;
    }
    /**
     * Apply the postfix ++ operator to the wrapped object.
     */
    friend constexpr ByteCount operator ++ (ByteCount & t, int)
    noexcept(noexcept(++std::declval<size_t&>()))
    {
        auto result = t;
        ++t.value;
        return result;
    }

    /**
     * Apply the prefix -- operator to the wrapped object.
     */
    friend constexpr ByteCount & operator -- (ByteCount & t)
    noexcept(noexcept(--std::declval<size_t&>()))
    {
        --t.value;
        return t;
    }
    /**
     * Apply the postfix -- operator to the wrapped object.
     */
    friend constexpr ByteCount operator -- (ByteCount & t, int)
    noexcept(noexcept(--std::declval<size_t&>()))
    {
        auto result = t;
        --t.value;
        return result;
    }

    /**
     * Apply % assignment to the wrapped objects.
     */
    friend constexpr ByteCount & operator %= (
        ByteCount & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t&>() %= std::declval<size_t const&>()))
    {
        lhs.value %= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator % to the wrapped object.
     */
    friend constexpr ByteCount operator % (
        ByteCount lhs,
        ByteCount const & rhs)
    noexcept(noexcept(lhs %= rhs))
    {
        lhs %= rhs;
        return lhs;
    }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr ByteCount & operator *= (
        ByteCount & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t&>() *= std::declval<size_t const&>()))
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr ByteCount operator * (
        ByteCount lhs,
        ByteCount const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr ByteCount & operator += (
        ByteCount & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t&>() += std::declval<size_t const&>()))
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr ByteCount operator + (
        ByteCount lhs,
        ByteCount const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr ByteCount & operator -= (
        ByteCount & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t&>() -= std::declval<size_t const&>()))
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr ByteCount operator - (
        ByteCount lhs,
        ByteCount const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr ByteCount & operator /= (
        ByteCount & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t&>() /= std::declval<size_t const&>()))
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr ByteCount operator / (
        ByteCount lhs,
        ByteCount const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

    /**
     * Apply << assignment to the wrapped objects.
     */
    friend constexpr ByteCount & operator <<= (
        ByteCount & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t&>() <<= std::declval<size_t const&>()))
    {
        lhs.value <<= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator << to the wrapped object.
     */
    friend constexpr ByteCount operator << (
        ByteCount lhs,
        ByteCount const & rhs)
    noexcept(noexcept(lhs <<= rhs))
    {
        lhs <<= rhs;
        return lhs;
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        ByteCount const & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t const&>() != std::declval<size_t const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value < @p rhs.value?
     */
    friend constexpr bool operator < (
        ByteCount const & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t const&>() < std::declval<size_t const&>()))
    {
        return lhs.value < rhs.value;
    }

    /**
     * Is @p lhs.value <= @p rhs.value?
     */
    friend constexpr bool operator <= (
        ByteCount const & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t const&>() <= std::declval<size_t const&>()))
    {
        return lhs.value <= rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ByteCount const & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t const&>() == std::declval<size_t const&>()))
    {
        return lhs.value == rhs.value;
    }

    /**
     * Is @p lhs.value > @p rhs.value?
     */
    friend constexpr bool operator > (
        ByteCount const & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t const&>() > std::declval<size_t const&>()))
    {
        return lhs.value > rhs.value;
    }

    /**
     * Is @p lhs.value >= @p rhs.value?
     */
    friend constexpr bool operator >= (
        ByteCount const & lhs,
        ByteCount const & rhs)
    noexcept(noexcept(std::declval<size_t const&>() >= std::declval<size_t const&>()))
    {
        return lhs.value >= rhs.value;
    }
};
} // namespace data

namespace graphics {
namespace color {

/**
 * @brief Strong type wrapper for uint8_t
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: graphics::color
 * - type_name: RedChannel
 * - description: strong uint8_t; +, -, *, /, &, |, ^, ~, ==, !=, <=>
 * - default_value: "0"
 */
struct RedChannel
: private atlas::strong_type_tag
{
    uint8_t value{0};

    using atlas_value_type = uint8_t;

    constexpr explicit RedChannel() = default;
    constexpr RedChannel(RedChannel const &) = default;
    constexpr RedChannel(RedChannel &&) = default;
    constexpr RedChannel & operator = (RedChannel const &) = default;
    constexpr RedChannel & operator = (RedChannel &&) = default;
    constexpr ~RedChannel() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<uint8_t, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit RedChannel(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator uint8_t const & () const { return value; }
    constexpr explicit operator uint8_t & () { return value; }

    /**
     * Apply the unary ~ operator to the wrapped object.
     */
    friend constexpr RedChannel operator ~ (RedChannel const & t)
    noexcept(
        noexcept(~ std::declval<uint8_t const&>()) &&
        std::is_nothrow_assignable<
            uint8_t&,
            decltype(~ std::declval<uint8_t const&>())>::value)
    {
        auto result = t;
        result.value = ~ t.value;
        return result;
    }

    /**
     * Apply & assignment to the wrapped objects.
     */
    friend constexpr RedChannel & operator &= (
        RedChannel & lhs,
        RedChannel const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() &= std::declval<uint8_t const&>()))
    {
        lhs.value &= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator & to the wrapped object.
     */
    friend constexpr RedChannel operator & (
        RedChannel lhs,
        RedChannel const & rhs)
    noexcept(noexcept(lhs &= rhs))
    {
        lhs &= rhs;
        return lhs;
    }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr RedChannel & operator *= (
        RedChannel & lhs,
        RedChannel const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() *= std::declval<uint8_t const&>()))
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr RedChannel operator * (
        RedChannel lhs,
        RedChannel const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr RedChannel & operator += (
        RedChannel & lhs,
        RedChannel const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() += std::declval<uint8_t const&>()))
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr RedChannel operator + (
        RedChannel lhs,
        RedChannel const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr RedChannel & operator -= (
        RedChannel & lhs,
        RedChannel const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() -= std::declval<uint8_t const&>()))
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr RedChannel operator - (
        RedChannel lhs,
        RedChannel const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr RedChannel & operator /= (
        RedChannel & lhs,
        RedChannel const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() /= std::declval<uint8_t const&>()))
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr RedChannel operator / (
        RedChannel lhs,
        RedChannel const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

    /**
     * Apply ^ assignment to the wrapped objects.
     */
    friend constexpr RedChannel & operator ^= (
        RedChannel & lhs,
        RedChannel const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() ^= std::declval<uint8_t const&>()))
    {
        lhs.value ^= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator ^ to the wrapped object.
     */
    friend constexpr RedChannel operator ^ (
        RedChannel lhs,
        RedChannel const & rhs)
    noexcept(noexcept(lhs ^= rhs))
    {
        lhs ^= rhs;
        return lhs;
    }

    /**
     * Apply | assignment to the wrapped objects.
     */
    friend constexpr RedChannel & operator |= (
        RedChannel & lhs,
        RedChannel const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() |= std::declval<uint8_t const&>()))
    {
        lhs.value |= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator | to the wrapped object.
     */
    friend constexpr RedChannel operator | (
        RedChannel lhs,
        RedChannel const & rhs)
    noexcept(noexcept(lhs |= rhs))
    {
        lhs |= rhs;
        return lhs;
    }

    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        RedChannel const &,
        RedChannel const &) = default;

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        RedChannel const & lhs,
        RedChannel const & rhs)
    noexcept(noexcept(std::declval<uint8_t const&>() != std::declval<uint8_t const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        RedChannel const & lhs,
        RedChannel const & rhs)
    noexcept(noexcept(std::declval<uint8_t const&>() == std::declval<uint8_t const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace color
} // namespace graphics

namespace security {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: security
 * - type_name: EncryptedData
 * - description: strong std::string; ==, !=, <<, hash
 * - default_value: ""
 */
class EncryptedData
: private atlas::strong_type_tag
{
    std::string value;

public:
    using atlas_value_type = std::string;

    constexpr explicit EncryptedData() = default;
    constexpr EncryptedData(EncryptedData const &) = default;
    constexpr EncryptedData(EncryptedData &&) = default;
    constexpr EncryptedData & operator = (EncryptedData const &) = default;
    constexpr EncryptedData & operator = (EncryptedData &&) = default;
    constexpr ~EncryptedData() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit EncryptedData(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::string const & () const { return value; }
    constexpr explicit operator std::string & () { return value; }

    /**
     * Apply << assignment to the wrapped objects.
     */
    friend constexpr EncryptedData & operator <<= (
        EncryptedData & lhs,
        EncryptedData const & rhs)
    noexcept(noexcept(std::declval<std::string&>() <<= std::declval<std::string const&>()))
    {
        lhs.value <<= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator << to the wrapped object.
     */
    friend constexpr EncryptedData operator << (
        EncryptedData lhs,
        EncryptedData const & rhs)
    noexcept(noexcept(lhs <<= rhs))
    {
        lhs <<= rhs;
        return lhs;
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        EncryptedData const & lhs,
        EncryptedData const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        EncryptedData const & lhs,
        EncryptedData const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace security


/**
 * @brief std::hash specialization for security::EncryptedData
 *
 * Delegates to std::hash of the underlying type std::string
 */
template <>
struct std::hash<security::EncryptedData>
{
    constexpr std::size_t operator () (security::EncryptedData const & t) const
    noexcept(
        noexcept(std::hash<std::string>{}(
            std::declval<std::string const &>())))
    {
        return std::hash<std::string>{}(
            static_cast<std::string const &>(t));
    }
};
namespace geo {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: geo
 * - type_name: Latitude
 * - description: strong double; ==, !=, <, <=, >, >=, u-, <<
 * - default_value: "0.0"
 */
struct Latitude
: private atlas::strong_type_tag
{
    double value{0.0};

    using atlas_value_type = double;

    constexpr explicit Latitude() = default;
    constexpr Latitude(Latitude const &) = default;
    constexpr Latitude(Latitude &&) = default;
    constexpr Latitude & operator = (Latitude const &) = default;
    constexpr Latitude & operator = (Latitude &&) = default;
    constexpr ~Latitude() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<double, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Latitude(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator double const & () const { return value; }
    constexpr explicit operator double & () { return value; }

    /**
     * Apply the unary - operator to the wrapped object.
     */
    friend constexpr Latitude operator - (Latitude const & t)
    noexcept(
        noexcept(- std::declval<double const&>()) &&
        std::is_nothrow_assignable<
            double&,
            decltype(- std::declval<double const&>())>::value)
    {
        auto result = t;
        result.value = - t.value;
        return result;
    }

    /**
     * Apply << assignment to the wrapped objects.
     */
    friend constexpr Latitude & operator <<= (
        Latitude & lhs,
        Latitude const & rhs)
    noexcept(noexcept(std::declval<double&>() <<= std::declval<double const&>()))
    {
        lhs.value <<= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator << to the wrapped object.
     */
    friend constexpr Latitude operator << (
        Latitude lhs,
        Latitude const & rhs)
    noexcept(noexcept(lhs <<= rhs))
    {
        lhs <<= rhs;
        return lhs;
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Latitude const & lhs,
        Latitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() != std::declval<double const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value < @p rhs.value?
     */
    friend constexpr bool operator < (
        Latitude const & lhs,
        Latitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() < std::declval<double const&>()))
    {
        return lhs.value < rhs.value;
    }

    /**
     * Is @p lhs.value <= @p rhs.value?
     */
    friend constexpr bool operator <= (
        Latitude const & lhs,
        Latitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() <= std::declval<double const&>()))
    {
        return lhs.value <= rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Latitude const & lhs,
        Latitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() == std::declval<double const&>()))
    {
        return lhs.value == rhs.value;
    }

    /**
     * Is @p lhs.value > @p rhs.value?
     */
    friend constexpr bool operator > (
        Latitude const & lhs,
        Latitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() > std::declval<double const&>()))
    {
        return lhs.value > rhs.value;
    }

    /**
     * Is @p lhs.value >= @p rhs.value?
     */
    friend constexpr bool operator >= (
        Latitude const & lhs,
        Latitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() >= std::declval<double const&>()))
    {
        return lhs.value >= rhs.value;
    }
};
} // namespace geo

namespace geo {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: geo
 * - type_name: Longitude
 * - description: strong double; ==, !=, <, <=, >, >=, u-, <<
 * - default_value: "0.0"
 */
struct Longitude
: private atlas::strong_type_tag
{
    double value{0.0};

    using atlas_value_type = double;

    constexpr explicit Longitude() = default;
    constexpr Longitude(Longitude const &) = default;
    constexpr Longitude(Longitude &&) = default;
    constexpr Longitude & operator = (Longitude const &) = default;
    constexpr Longitude & operator = (Longitude &&) = default;
    constexpr ~Longitude() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<double, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Longitude(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator double const & () const { return value; }
    constexpr explicit operator double & () { return value; }

    /**
     * Apply the unary - operator to the wrapped object.
     */
    friend constexpr Longitude operator - (Longitude const & t)
    noexcept(
        noexcept(- std::declval<double const&>()) &&
        std::is_nothrow_assignable<
            double&,
            decltype(- std::declval<double const&>())>::value)
    {
        auto result = t;
        result.value = - t.value;
        return result;
    }

    /**
     * Apply << assignment to the wrapped objects.
     */
    friend constexpr Longitude & operator <<= (
        Longitude & lhs,
        Longitude const & rhs)
    noexcept(noexcept(std::declval<double&>() <<= std::declval<double const&>()))
    {
        lhs.value <<= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator << to the wrapped object.
     */
    friend constexpr Longitude operator << (
        Longitude lhs,
        Longitude const & rhs)
    noexcept(noexcept(lhs <<= rhs))
    {
        lhs <<= rhs;
        return lhs;
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Longitude const & lhs,
        Longitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() != std::declval<double const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value < @p rhs.value?
     */
    friend constexpr bool operator < (
        Longitude const & lhs,
        Longitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() < std::declval<double const&>()))
    {
        return lhs.value < rhs.value;
    }

    /**
     * Is @p lhs.value <= @p rhs.value?
     */
    friend constexpr bool operator <= (
        Longitude const & lhs,
        Longitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() <= std::declval<double const&>()))
    {
        return lhs.value <= rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Longitude const & lhs,
        Longitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() == std::declval<double const&>()))
    {
        return lhs.value == rhs.value;
    }

    /**
     * Is @p lhs.value > @p rhs.value?
     */
    friend constexpr bool operator > (
        Longitude const & lhs,
        Longitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() > std::declval<double const&>()))
    {
        return lhs.value > rhs.value;
    }

    /**
     * Is @p lhs.value >= @p rhs.value?
     */
    friend constexpr bool operator >= (
        Longitude const & lhs,
        Longitude const & rhs)
    noexcept(noexcept(std::declval<double const&>() >= std::declval<double const&>()))
    {
        return lhs.value >= rhs.value;
    }
};
} // namespace geo

namespace concurrency {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: concurrency
 * - type_name: ThreadId
 * - description: strong int; ==, !=, <<, hash, no-constexpr, no-constexpr-hash
 * - default_value: ""
 */
struct ThreadId
: private atlas::strong_type_tag
{
    int value;

    using atlas_value_type = int;

    explicit ThreadId() = default;
    ThreadId(ThreadId const &) = default;
    ThreadId(ThreadId &&) = default;
    ThreadId & operator = (ThreadId const &) = default;
    ThreadId & operator = (ThreadId &&) = default;
    ~ThreadId() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    explicit ThreadId(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    explicit operator int const & () const { return value; }
    explicit operator int & () { return value; }

    /**
     * Apply << assignment to the wrapped objects.
     */
    friend ThreadId & operator <<= (
        ThreadId & lhs,
        ThreadId const & rhs)
    noexcept(noexcept(std::declval<int&>() <<= std::declval<int const&>()))
    {
        lhs.value <<= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator << to the wrapped object.
     */
    friend ThreadId operator << (
        ThreadId lhs,
        ThreadId const & rhs)
    noexcept(noexcept(lhs <<= rhs))
    {
        lhs <<= rhs;
        return lhs;
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend bool operator != (
        ThreadId const & lhs,
        ThreadId const & rhs)
    noexcept(noexcept(std::declval<int const&>() != std::declval<int const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend bool operator == (
        ThreadId const & lhs,
        ThreadId const & rhs)
    noexcept(noexcept(std::declval<int const&>() == std::declval<int const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace concurrency


/**
 * @brief std::hash specialization for concurrency::ThreadId
 *
 * Delegates to std::hash of the underlying type int
 */
template <>
struct std::hash<concurrency::ThreadId>
{
    std::size_t operator () (concurrency::ThreadId const & t) const
    noexcept(
        noexcept(std::hash<int>{}(
            std::declval<int const &>())))
    {
        return std::hash<int>{}(
            static_cast<int const &>(t));
    }
};
namespace math {
namespace rational {

/**
 * @brief Strong type wrapper for long
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: math::rational
 * - type_name: Numerator
 * - description: strong long; +, -, *, ==, !=, <=>
 * - default_value: ""
 */
struct Numerator
: private atlas::strong_type_tag
{
    long value;

    using atlas_value_type = long;

    constexpr explicit Numerator() = default;
    constexpr Numerator(Numerator const &) = default;
    constexpr Numerator(Numerator &&) = default;
    constexpr Numerator & operator = (Numerator const &) = default;
    constexpr Numerator & operator = (Numerator &&) = default;
    constexpr ~Numerator() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<long, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Numerator(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator long const & () const { return value; }
    constexpr explicit operator long & () { return value; }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr Numerator & operator *= (
        Numerator & lhs,
        Numerator const & rhs)
    noexcept(noexcept(std::declval<long&>() *= std::declval<long const&>()))
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr Numerator operator * (
        Numerator lhs,
        Numerator const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr Numerator & operator += (
        Numerator & lhs,
        Numerator const & rhs)
    noexcept(noexcept(std::declval<long&>() += std::declval<long const&>()))
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr Numerator operator + (
        Numerator lhs,
        Numerator const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr Numerator & operator -= (
        Numerator & lhs,
        Numerator const & rhs)
    noexcept(noexcept(std::declval<long&>() -= std::declval<long const&>()))
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr Numerator operator - (
        Numerator lhs,
        Numerator const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        Numerator const &,
        Numerator const &) = default;

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Numerator const & lhs,
        Numerator const & rhs)
    noexcept(noexcept(std::declval<long const&>() != std::declval<long const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Numerator const & lhs,
        Numerator const & rhs)
    noexcept(noexcept(std::declval<long const&>() == std::declval<long const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace rational
} // namespace math

namespace math {
namespace rational {

/**
 * @brief Strong type wrapper for long
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: math::rational
 * - type_name: Denominator
 * - description: strong long; *, /, ==, !=, <=>
 * - default_value: "1"
 */
struct Denominator
: private atlas::strong_type_tag
{
    long value{1};

    using atlas_value_type = long;

    constexpr explicit Denominator() = default;
    constexpr Denominator(Denominator const &) = default;
    constexpr Denominator(Denominator &&) = default;
    constexpr Denominator & operator = (Denominator const &) = default;
    constexpr Denominator & operator = (Denominator &&) = default;
    constexpr ~Denominator() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<long, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Denominator(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator long const & () const { return value; }
    constexpr explicit operator long & () { return value; }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr Denominator & operator *= (
        Denominator & lhs,
        Denominator const & rhs)
    noexcept(noexcept(std::declval<long&>() *= std::declval<long const&>()))
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr Denominator operator * (
        Denominator lhs,
        Denominator const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr Denominator & operator /= (
        Denominator & lhs,
        Denominator const & rhs)
    noexcept(noexcept(std::declval<long&>() /= std::declval<long const&>()))
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr Denominator operator / (
        Denominator lhs,
        Denominator const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        Denominator const &,
        Denominator const &) = default;

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Denominator const & lhs,
        Denominator const & rhs)
    noexcept(noexcept(std::declval<long const&>() != std::declval<long const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Denominator const & lhs,
        Denominator const & rhs)
    noexcept(noexcept(std::declval<long const&>() == std::declval<long const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace rational
} // namespace math

namespace net {
namespace ipv4 {

/**
 * @brief Strong type wrapper for uint8_t
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: net::ipv4
 * - type_name: Octet
 * - description: strong uint8_t; &, |, ^, ~, <<, >>, ==, !=
 * - default_value: "0"
 */
struct Octet
: private atlas::strong_type_tag
{
    uint8_t value{0};

    using atlas_value_type = uint8_t;

    constexpr explicit Octet() = default;
    constexpr Octet(Octet const &) = default;
    constexpr Octet(Octet &&) = default;
    constexpr Octet & operator = (Octet const &) = default;
    constexpr Octet & operator = (Octet &&) = default;
    constexpr ~Octet() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<uint8_t, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Octet(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator uint8_t const & () const { return value; }
    constexpr explicit operator uint8_t & () { return value; }

    /**
     * Apply the unary ~ operator to the wrapped object.
     */
    friend constexpr Octet operator ~ (Octet const & t)
    noexcept(
        noexcept(~ std::declval<uint8_t const&>()) &&
        std::is_nothrow_assignable<
            uint8_t&,
            decltype(~ std::declval<uint8_t const&>())>::value)
    {
        auto result = t;
        result.value = ~ t.value;
        return result;
    }

    /**
     * Apply & assignment to the wrapped objects.
     */
    friend constexpr Octet & operator &= (
        Octet & lhs,
        Octet const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() &= std::declval<uint8_t const&>()))
    {
        lhs.value &= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator & to the wrapped object.
     */
    friend constexpr Octet operator & (
        Octet lhs,
        Octet const & rhs)
    noexcept(noexcept(lhs &= rhs))
    {
        lhs &= rhs;
        return lhs;
    }

    /**
     * Apply << assignment to the wrapped objects.
     */
    friend constexpr Octet & operator <<= (
        Octet & lhs,
        Octet const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() <<= std::declval<uint8_t const&>()))
    {
        lhs.value <<= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator << to the wrapped object.
     */
    friend constexpr Octet operator << (
        Octet lhs,
        Octet const & rhs)
    noexcept(noexcept(lhs <<= rhs))
    {
        lhs <<= rhs;
        return lhs;
    }

    /**
     * Apply >> assignment to the wrapped objects.
     */
    friend constexpr Octet & operator >>= (
        Octet & lhs,
        Octet const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() >>= std::declval<uint8_t const&>()))
    {
        lhs.value >>= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator >> to the wrapped object.
     */
    friend constexpr Octet operator >> (
        Octet lhs,
        Octet const & rhs)
    noexcept(noexcept(lhs >>= rhs))
    {
        lhs >>= rhs;
        return lhs;
    }

    /**
     * Apply ^ assignment to the wrapped objects.
     */
    friend constexpr Octet & operator ^= (
        Octet & lhs,
        Octet const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() ^= std::declval<uint8_t const&>()))
    {
        lhs.value ^= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator ^ to the wrapped object.
     */
    friend constexpr Octet operator ^ (
        Octet lhs,
        Octet const & rhs)
    noexcept(noexcept(lhs ^= rhs))
    {
        lhs ^= rhs;
        return lhs;
    }

    /**
     * Apply | assignment to the wrapped objects.
     */
    friend constexpr Octet & operator |= (
        Octet & lhs,
        Octet const & rhs)
    noexcept(noexcept(std::declval<uint8_t&>() |= std::declval<uint8_t const&>()))
    {
        lhs.value |= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator | to the wrapped object.
     */
    friend constexpr Octet operator | (
        Octet lhs,
        Octet const & rhs)
    noexcept(noexcept(lhs |= rhs))
    {
        lhs |= rhs;
        return lhs;
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Octet const & lhs,
        Octet const & rhs)
    noexcept(noexcept(std::declval<uint8_t const&>() != std::declval<uint8_t const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Octet const & lhs,
        Octet const & rhs)
    noexcept(noexcept(std::declval<uint8_t const&>() == std::declval<uint8_t const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace ipv4
} // namespace net

namespace app {
namespace config {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: app::config
 * - type_name: ConfigKey
 * - description: strong std::string; +, ==, !=, <, <<, hash, []
 * - default_value: ""
 */
class ConfigKey
: private atlas::strong_type_tag
{
    std::string value;

public:
    using atlas_value_type = std::string;

    constexpr explicit ConfigKey() = default;
    constexpr ConfigKey(ConfigKey const &) = default;
    constexpr ConfigKey(ConfigKey &&) = default;
    constexpr ConfigKey & operator = (ConfigKey const &) = default;
    constexpr ConfigKey & operator = (ConfigKey &&) = default;
    constexpr ~ConfigKey() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ConfigKey(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::string const & () const { return value; }
    constexpr explicit operator std::string & () { return value; }

    /**
     * Subscript operator that forwards to the wrapped object.
     */
#if __cpp_multidimensional_subscript >= 202110L
    template <typename ArgT, typename... ArgTs>
    constexpr decltype(auto) operator [] (ArgT && arg, ArgTs && ... args)
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
    template <typename ArgT, typename... ArgTs>
    constexpr decltype(auto) operator [] (ArgT && arg, ArgTs && ... args) const
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
#else
    template <typename ArgT>
    constexpr auto operator [] (ArgT && arg)
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
    template <typename ArgT>
    constexpr auto operator [] (ArgT && arg) const
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
#endif

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr ConfigKey & operator += (
        ConfigKey & lhs,
        ConfigKey const & rhs)
    noexcept(noexcept(std::declval<std::string&>() += std::declval<std::string const&>()))
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr ConfigKey operator + (
        ConfigKey lhs,
        ConfigKey const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply << assignment to the wrapped objects.
     */
    friend constexpr ConfigKey & operator <<= (
        ConfigKey & lhs,
        ConfigKey const & rhs)
    noexcept(noexcept(std::declval<std::string&>() <<= std::declval<std::string const&>()))
    {
        lhs.value <<= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator << to the wrapped object.
     */
    friend constexpr ConfigKey operator << (
        ConfigKey lhs,
        ConfigKey const & rhs)
    noexcept(noexcept(lhs <<= rhs))
    {
        lhs <<= rhs;
        return lhs;
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        ConfigKey const & lhs,
        ConfigKey const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value < @p rhs.value?
     */
    friend constexpr bool operator < (
        ConfigKey const & lhs,
        ConfigKey const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() < std::declval<std::string const&>()))
    {
        return lhs.value < rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ConfigKey const & lhs,
        ConfigKey const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace config
} // namespace app


/**
 * @brief std::hash specialization for app::config::ConfigKey
 *
 * Delegates to std::hash of the underlying type std::string
 */
template <>
struct std::hash<app::config::ConfigKey>
{
    constexpr std::size_t operator () (app::config::ConfigKey const & t) const
    noexcept(
        noexcept(std::hash<std::string>{}(
            std::declval<std::string const &>())))
    {
        return std::hash<std::string>{}(
            static_cast<std::string const &>(t));
    }
};
#endif // EXAMPLE_714EA71F36DDFEAD94BBAEF0E27280AAE0D6D0B7
