# Memfn Forwarding Tutorial

Memfn forwarding is one of Atlas's most powerful features, allowing you to create strong types that feel natural to use by selectively exposing memfns from the wrapped type.

## Table of Contents

- [Why Memfn Forwarding?](#why-memfn-forwarding)
- [Basic Usage](#basic-usage)
- [Memfn Aliasing](#memfn-aliasing)
- [Const-Only Memfns](#const-only-memfns)
- [Real-World Examples](#real-world-examples)
- [Advanced Patterns](#advanced-patterns)
- [How It Works](#how-it-works)

## Why Memfn Forwarding?

Without memfn forwarding, using strong types can be awkward:

```cpp
struct Username {
    std::string value;
};

Username user{"alice"};

// Verbose and exposes implementation
if (user.value.empty()) { ... }
size_t len = user.value.size();
```

With memfn forwarding, strong types become ergonomic:

```cpp
// Generated by Atlas with: forward=size,empty
Username user{"alice"};

// Natural and type-safe
if (user.empty()) { ... }
size_t len = user.size();
```

## Basic Usage

### Inline Syntax

Specify forwarded memfns directly in the description:

```
[struct Username]
description=std::string; forward=size,empty,clear; ==, !=
```

### Separate Line Syntax

Or use a dedicated `forward=` line for better organization:

```
[struct Username]
description=std::string; ==, !=
forward=size,empty,clear
```

Both syntaxes produce identical results. Choose based on your preference and description complexity.

### Multiple Forward Lines

For complex types, group related memfns:

```
[struct SafeString]
description=std::string; ==, !=, hash
forward=size,empty,length       # Query memfns
forward=clear,append,push_back  # Modification memfns
```

## Memfn Aliasing

Rename forwarded memfns to better match your domain:

```
[struct Distance]
description=double; forward=abs:magnitude; +, -, <=>
```

This forwards the `abs()` memfn but calls it `magnitude()`:

```cpp
Distance d{-10.5};
double mag = d.magnitude();  // Calls std::abs(-10.5)
```

### Real-World Aliasing Examples

**String length:**
```
forward=size:length,empty:is_empty
```

**Container operations:**
```
forward=push_back:add,pop_back:remove,size:count
```

**Smart pointer access:**
```
forward=get:raw_ptr,reset:release
```

## Const-Only Memfns

Sometimes you want to expose query memfns but prevent modification:

```
[struct ImmutableConfig]
description=std::map<std::string, std::string>; forward=const,at,find,size,empty; ==
```

The `const` keyword ensures only const-qualified overloads are generated. This prevents accidental modification:

```cpp
ImmutableConfig config = load_config();
auto val = config.at("key");     // ✓ Works
config.find("key");               // ✓ Works
config.size();                    // ✓ Works
// config.clear();                // ✗ Would not compile - not forwarded
```

### Mixing Const and Non-Const

You can specify const-only for some memfns and unrestricted for others using multiple forward lines:

```
[struct PartiallyMutable]
description=std::vector<int>
forward=const,size,empty,at      # Read-only access
forward=push_back,pop_back       # Modification allowed
```

## Real-World Examples

### String Wrappers

**Username validation:**
```
[struct Username]
namespace=auth
description=std::string; forward=size:length,empty:is_empty,const,find; ==, !=, hash

void validate(Username const& user) {
    if (user.is_empty()) {
        throw ValidationError("Username cannot be empty");
    }
    if (user.length() > 32) {
        throw ValidationError("Username too long");
    }
    if (user.find('@') != std::string::npos) {
        throw ValidationError("Username cannot contain @");
    }
}
```

### Container Wrappers

**Type-safe task queue:**
```
[struct TaskQueue]
namespace=scheduler
description=std::deque<Task>; forward=push_back:enqueue,pop_front:dequeue,size,empty; ==, iterable
```

Usage:
```cpp
TaskQueue queue;
queue.enqueue(task1);
queue.enqueue(task2);

while (!queue.empty()) {
    auto task = queue.dequeue();
    process(task);
}
```

### Smart Pointer Wrappers

**Resource handle with controlled access:**
```
[struct ResourceHandle]
namespace=resources
description=std::unique_ptr<Resource>; forward=get,reset; ->, @, bool
```

Usage:
```cpp
ResourceHandle handle = acquire_resource();

if (handle) {                    // bool operator
    handle->process();           // -> operator
    auto* raw = handle.get();    // forwarded get()
    handle.reset();              // forwarded reset()
}
```

### Numeric Types with Math Operations

**Distance with magnitude:**
```
[struct Distance]
namespace=geometry
description=double; forward=abs:magnitude; +, -, *, /, <=>
```

Usage:
```cpp
Distance d1{-10.5};
Distance d2{3.5};

auto sum = d1 + d2;              // Arithmetic operators
auto mag = d1.magnitude();        // Forwarded abs() as magnitude()
if (d1 < d2) { ... }             // Comparison operators
```

## Advanced Patterns

### Selective API Exposure

Expose only the safe subset of a complex API:

```
[struct SafeFile]
description=std::fstream
forward=is_open,good,eof,read    # Safe read operations only
# Not forwarding write, close, etc. - controlled by wrapper
```

### Layered Forwarding

Build abstractions on top of forwarding:

```
[struct EmailAddress]
description=std::string; forward=size,empty,const,find; ==, !=, hash

class EmailValidator {
    bool validate(EmailAddress const& email) {
        return !email.empty() &&
               email.find('@') != std::string::npos &&
               email.find('@') == email.rfind('@');  // Need to add rfind to forwards!
    }
};
```

### Performance-Sensitive Code

Forward size/empty for zero-overhead abstractions:

```
[struct Pixels]
description=std::vector<uint32_t>; forward=size,empty,data,const,at; [], ==, iterable
```

The forwarded memfns compile to direct calls with no overhead:

```cpp
void process_image(Pixels const& pixels) {
    for (size_t i = 0; i < pixels.size(); ++i) {  // Zero overhead
        auto pixel = pixels.at(i);                  // Direct access
        // ...
    }
}
```

## How It Works

Atlas generates perfect forwarding wrappers that preserve all properties of the original memfn.

### C++11-20: Four Ref-Qualified Overloads

```cpp
template <typename... Args>
constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
{
    return value.size(std::forward<Args>(args)...);
}

// Plus three more overloads:
// - const && for rvalue access
// - & for mutable lvalue access
// - && for mutable rvalue access
```

### C++23: Deducing This

For C++23+, Atlas generates a single elegant overload using deducing `this`:

```cpp
template <typename Self, typename... Args>
constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
{
    return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
}
```

### What Gets Preserved

The forwarding wrappers preserve:

- ✅ **Const-correctness**: const and non-const overloads
- ✅ **Reference qualifiers**: lvalue and rvalue semantics
- ✅ **noexcept specifications**: Exception safety guarantees
- ✅ **Return types**: Exact return type via `decltype`
- ✅ **Parameter forwarding**: Perfect forwarding with `std::forward`
- ✅ **constexpr**: Propagates from underlying type

### When to Use Each Feature

| Scenario | Recommendation |
|----------|---------------|
| Read-only wrapper | Use `const` keyword: `forward=const,size,at` |
| Need renaming | Use aliases: `forward=size:length` |
| Many memfns | Use multiple forward lines for organization |
| Template memfns | Just list the name - forwarding handles templates |
| Overloaded memfns | Just list the name - forwarding handles overloads |

## Best Practices

1. **Forward conservatively** - Only expose memfns you actually need
2. **Use aliases for clarity** - Make the API match your domain
3. **Document forwarded behavior** - Users should know what's available
4. **Consider const-only** - Prevent accidental modification when appropriate
5. **Test the API** - Verify forwarded memfns work as expected

## Common Pitfalls

### Forwarding Too Much

```
# Bad - exposes entire std::string API
forward=size,empty,clear,append,push_back,pop_back,insert,erase,replace,...
```

Better to use composition and expose specific functionality:

```
# Good - minimal, purposeful API
forward=size,empty,const
# Provide custom memfns for mutations
```

### Forgetting Const

```
[struct Config]
description=std::map<std::string, int>; forward=at,find,size
```

If you want immutability, add `const`:

```
forward=const,at,find,size
```

### Not Using Aliases

```
forward=size  # On a Distance type - confusing!
```

Better with aliasing:

```
forward=size:length  # Clear intent
```

## See Also

- [Description Language Reference](description-language.md#memfn-forwarding) - Complete syntax reference
- [Examples](../examples/strong_types_showcase.atlas) - More real-world examples
- [Generated Header Guards](generated-header-guards.md) - Understanding generated code
