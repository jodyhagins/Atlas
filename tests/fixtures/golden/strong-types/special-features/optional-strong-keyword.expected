#ifndef TEST_OPTIONAL_STRONG_A5E529EB6D3A2860CC9414D660D28E0DCF1CD9E1
#define TEST_OPTIONAL_STRONG_A5E529EB6D3A2860CC9414D660D28E0DCF1CD9E1

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v0.1.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#if __has_include(<version>)
#include <version>
#endif
#include <functional>
#include <type_traits>
#include <utility>
#include <vector>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// ======================================================================
// ATLAS STRONG TYPE BOILERPLATE
// ----------------------------------------------------------------------
//
// This section provides the infrastructure for Atlas strong types.
// It is identical across all Atlas-generated files and uses a shared
// header guard (WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90) to ensure
// the boilerplate is only included once even when multiple generated
// files are used in the same translation unit.
//
// The boilerplate is intentionally inlined to make generated code
// self-contained with zero external dependencies.
//
// Components:
// - atlas::strong_type_tag: Base class for strong types
// - atlas::value(): Universal value accessor for strong types
// - atlas_detail::*: Internal implementation utilities
//
// For projects using multiple Atlas-generated files, this boilerplate
// will only be compiled once per translation unit thanks to the shared
// header guard below.
//
// ----------------------------------------------------------------------
// DO NOT EDIT THIS SECTION
// ======================================================================

// Atlas feature detection macros
#ifndef ATLAS_NODISCARD
#if defined(__cpp_attributes) && __cpp_attributes >= 201603L
#define ATLAS_NODISCARD [[nodiscard]]
#else
#define ATLAS_NODISCARD
#endif
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif

namespace atlas {

struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <typename T, typename = void>
struct IsAtlasType
: std::false_type
{ };

template <typename T>
struct IsAtlasType<T, void_t<typename T::atlas_value_type>>
: std::true_type
{ };

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;
template <typename T, typename U = void>
using enable_if = typename std::enable_if<T::value, U>::type;

template <typename T>
using _t = typename T::type;

void atlas_value();

template <typename T>
constexpr T &
value(T & val, PriorityTag<0>)
{
    return val;
}

template <typename T, typename U = typename T::atlas_value_type>
using val_t = _t<std::conditional<std::is_const<T>::value, U const &, U &>>;

template <typename T, typename U = val_t<T>>
constexpr auto
value(T & val, PriorityTag<1>)
-> decltype(atlas::atlas_detail::value(static_cast<U>(val), value_tag{}))
{
    return atlas::atlas_detail::value(static_cast<U>(val), value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<2>)
-> decltype(atlas_value(t, atlas::value_tag{}))
{
    return atlas_value(t, atlas::value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<3>)
-> decltype(atlas_value(t))
{
    return atlas_value(t);
}

class Value
{
    template <
        typename U,
        typename T,
        typename V = _t<std::conditional<is_lref<U &&>::value, T &, T>>>
    static constexpr V rval(T && t)
    {
        return t;
    }

public:
    template <typename T>
    constexpr auto operator () (T && t) const
    -> decltype(rval<T>(atlas_detail::value(t, atlas_detail::value_tag{})))
    {
        return rval<T>(atlas_detail::value(t, atlas_detail::value_tag{}));
    }
};

void begin();
void end();

template <typename T>
constexpr auto
begin_(T && t) noexcept(noexcept(begin(std::forward<T>(t))))
-> decltype(begin(std::forward<T>(t)))
{
    return begin(std::forward<T>(t));
}

template <typename T>
constexpr auto
end_(T && t) noexcept(noexcept(end(std::forward<T>(t))))
-> decltype(end(std::forward<T>(t)))
{
    return end(std::forward<T>(t));
}

} // namespace atlas_detail

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto value = atlas_detail::Value{};
#else
template <typename T>
constexpr auto
value(T && t)
-> decltype(atlas_detail::Value{}(std::forward<T>(t)))
{
    return atlas_detail::Value{}(std::forward<T>(t));
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////


namespace test {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: WithStrong
 * - description: strong double; *, +, -, /, <=>
 * - default_value: ""
 */
struct WithStrong
: private atlas::strong_type_tag
{
    double value;

    using atlas_value_type = double;

    constexpr explicit WithStrong() = default;
    constexpr WithStrong(WithStrong const &) = default;
    constexpr WithStrong(WithStrong &&) = default;
    constexpr WithStrong & operator = (WithStrong const &) = default;
    constexpr WithStrong & operator = (WithStrong &&) = default;
    constexpr ~WithStrong() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<double, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit WithStrong(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator double const & () const { return value; }
    constexpr explicit operator double & () { return value; }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr WithStrong & operator *= (
        WithStrong & lhs,
        WithStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<double &>() *= std::declval<double const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr WithStrong operator * (
        WithStrong lhs,
        WithStrong const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr WithStrong & operator += (
        WithStrong & lhs,
        WithStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<double &>() += std::declval<double const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr WithStrong operator + (
        WithStrong lhs,
        WithStrong const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr WithStrong & operator -= (
        WithStrong & lhs,
        WithStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<double &>() -= std::declval<double const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr WithStrong operator - (
        WithStrong lhs,
        WithStrong const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr WithStrong & operator /= (
        WithStrong & lhs,
        WithStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<double &>() /= std::declval<double const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr WithStrong operator / (
        WithStrong lhs,
        WithStrong const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        WithStrong const &,
        WithStrong const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        WithStrong const & lhs,
        WithStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() <
        std::declval<double const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        WithStrong const & lhs,
        WithStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() <=
        std::declval<double const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        WithStrong const & lhs,
        WithStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() >
        std::declval<double const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        WithStrong const & lhs,
        WithStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() >=
        std::declval<double const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        WithStrong const &,
        WithStrong const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        WithStrong const & lhs,
        WithStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() ==
        std::declval<double const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        WithStrong const & lhs,
        WithStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() !=
        std::declval<double const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: WithoutStrong
 * - description: double; *, +, -, /, <=>
 * - default_value: ""
 */
struct WithoutStrong
: private atlas::strong_type_tag
{
    double value;

    using atlas_value_type = double;

    constexpr explicit WithoutStrong() = default;
    constexpr WithoutStrong(WithoutStrong const &) = default;
    constexpr WithoutStrong(WithoutStrong &&) = default;
    constexpr WithoutStrong & operator = (WithoutStrong const &) = default;
    constexpr WithoutStrong & operator = (WithoutStrong &&) = default;
    constexpr ~WithoutStrong() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<double, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit WithoutStrong(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator double const & () const { return value; }
    constexpr explicit operator double & () { return value; }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr WithoutStrong & operator *= (
        WithoutStrong & lhs,
        WithoutStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<double &>() *= std::declval<double const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr WithoutStrong operator * (
        WithoutStrong lhs,
        WithoutStrong const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr WithoutStrong & operator += (
        WithoutStrong & lhs,
        WithoutStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<double &>() += std::declval<double const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr WithoutStrong operator + (
        WithoutStrong lhs,
        WithoutStrong const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr WithoutStrong & operator -= (
        WithoutStrong & lhs,
        WithoutStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<double &>() -= std::declval<double const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr WithoutStrong operator - (
        WithoutStrong lhs,
        WithoutStrong const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr WithoutStrong & operator /= (
        WithoutStrong & lhs,
        WithoutStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<double &>() /= std::declval<double const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr WithoutStrong operator / (
        WithoutStrong lhs,
        WithoutStrong const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        WithoutStrong const &,
        WithoutStrong const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        WithoutStrong const & lhs,
        WithoutStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() <
        std::declval<double const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        WithoutStrong const & lhs,
        WithoutStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() <=
        std::declval<double const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        WithoutStrong const & lhs,
        WithoutStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() >
        std::declval<double const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        WithoutStrong const & lhs,
        WithoutStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() >=
        std::declval<double const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        WithoutStrong const &,
        WithoutStrong const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        WithoutStrong const & lhs,
        WithoutStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() ==
        std::declval<double const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        WithoutStrong const & lhs,
        WithoutStrong const & rhs)
    noexcept(noexcept(std::declval<double const &>() !=
        std::declval<double const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::vector<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ComplexWithStrong
 * - description: strong std::vector<int>; !=, ==, [], iterable
 * - default_value: ""
 */
struct ComplexWithStrong
: private atlas::strong_type_tag
{
    std::vector<int> value;

    using atlas_value_type = std::vector<int>;

    constexpr explicit ComplexWithStrong() = default;
    constexpr ComplexWithStrong(ComplexWithStrong const &) = default;
    constexpr ComplexWithStrong(ComplexWithStrong &&) = default;
    constexpr ComplexWithStrong & operator = (ComplexWithStrong const &) = default;
    constexpr ComplexWithStrong & operator = (ComplexWithStrong &&) = default;
    constexpr ~ComplexWithStrong() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::vector<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ComplexWithStrong(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::vector<int> const & () const { return value; }
    constexpr explicit operator std::vector<int> & () { return value; }

    /**
     * Subscript operator that forwards to the wrapped object.
     */
#if __cpp_multidimensional_subscript >= 202110L
    template <typename ArgT, typename... ArgTs>
    constexpr decltype(auto) operator [] (ArgT && arg, ArgTs && ... args)
    noexcept(noexcept(value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...]))
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
    template <typename ArgT, typename... ArgTs>
    constexpr decltype(auto) operator [] (ArgT && arg, ArgTs && ... args) const
    noexcept(noexcept(value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...]))
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
#else
    template <typename ArgT>
    constexpr auto operator [] (ArgT && arg)
    noexcept(noexcept(value[std::forward<ArgT>(arg)]))
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
    template <typename ArgT>
    constexpr auto operator [] (ArgT && arg) const
    noexcept(noexcept(value[std::forward<ArgT>(arg)]))
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
#endif

    /**
     * Iterator type aliases for container-like interface.
     */
    using iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<std::vector<int>&>()));
    using const_iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<std::vector<int> const&>()));
    using value_type = typename std::remove_reference<decltype(
        *atlas::atlas_detail::begin_(
            std::declval<std::vector<int>&>()))>::type;

    /**
     * Member functions for iterator access.
     * Enables both explicit calls (e.g., s.begin()) and range-based for loops.
     * Uses ADL-enabled helpers that work in decltype/noexcept contexts.
     */
    constexpr auto begin()
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    constexpr auto end()
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    constexpr auto begin() const
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    constexpr auto end() const
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        ComplexWithStrong const & lhs,
        ComplexWithStrong const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() != std::declval<std::vector<int> const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ComplexWithStrong const & lhs,
        ComplexWithStrong const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() == std::declval<std::vector<int> const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::vector<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ComplexWithoutStrong
 * - description: std::vector<int>; !=, ==, [], iterable
 * - default_value: ""
 */
struct ComplexWithoutStrong
: private atlas::strong_type_tag
{
    std::vector<int> value;

    using atlas_value_type = std::vector<int>;

    constexpr explicit ComplexWithoutStrong() = default;
    constexpr ComplexWithoutStrong(ComplexWithoutStrong const &) = default;
    constexpr ComplexWithoutStrong(ComplexWithoutStrong &&) = default;
    constexpr ComplexWithoutStrong & operator = (ComplexWithoutStrong const &) = default;
    constexpr ComplexWithoutStrong & operator = (ComplexWithoutStrong &&) = default;
    constexpr ~ComplexWithoutStrong() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::vector<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ComplexWithoutStrong(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::vector<int> const & () const { return value; }
    constexpr explicit operator std::vector<int> & () { return value; }

    /**
     * Subscript operator that forwards to the wrapped object.
     */
#if __cpp_multidimensional_subscript >= 202110L
    template <typename ArgT, typename... ArgTs>
    constexpr decltype(auto) operator [] (ArgT && arg, ArgTs && ... args)
    noexcept(noexcept(value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...]))
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
    template <typename ArgT, typename... ArgTs>
    constexpr decltype(auto) operator [] (ArgT && arg, ArgTs && ... args) const
    noexcept(noexcept(value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...]))
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
#else
    template <typename ArgT>
    constexpr auto operator [] (ArgT && arg)
    noexcept(noexcept(value[std::forward<ArgT>(arg)]))
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
    template <typename ArgT>
    constexpr auto operator [] (ArgT && arg) const
    noexcept(noexcept(value[std::forward<ArgT>(arg)]))
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
#endif

    /**
     * Iterator type aliases for container-like interface.
     */
    using iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<std::vector<int>&>()));
    using const_iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<std::vector<int> const&>()));
    using value_type = typename std::remove_reference<decltype(
        *atlas::atlas_detail::begin_(
            std::declval<std::vector<int>&>()))>::type;

    /**
     * Member functions for iterator access.
     * Enables both explicit calls (e.g., s.begin()) and range-based for loops.
     * Uses ADL-enabled helpers that work in decltype/noexcept contexts.
     */
    constexpr auto begin()
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    constexpr auto end()
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    constexpr auto begin() const
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    constexpr auto end() const
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        ComplexWithoutStrong const & lhs,
        ComplexWithoutStrong const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() != std::declval<std::vector<int> const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ComplexWithoutStrong const & lhs,
        ComplexWithoutStrong const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() == std::declval<std::vector<int> const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace global {

/**
 * @brief Strong type wrapper for geo::Point
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: global
 * - type_name: InlineNsWithStrong
 * - description: strong geo::Point; !=, ==
 * - default_value: ""
 */
struct InlineNsWithStrong
: private atlas::strong_type_tag
{
    geo::Point value;

    using atlas_value_type = geo::Point;

    constexpr explicit InlineNsWithStrong() = default;
    constexpr InlineNsWithStrong(InlineNsWithStrong const &) = default;
    constexpr InlineNsWithStrong(InlineNsWithStrong &&) = default;
    constexpr InlineNsWithStrong & operator = (InlineNsWithStrong const &) = default;
    constexpr InlineNsWithStrong & operator = (InlineNsWithStrong &&) = default;
    constexpr ~InlineNsWithStrong() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<geo::Point, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit InlineNsWithStrong(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator geo::Point const & () const { return value; }
    constexpr explicit operator geo::Point & () { return value; }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        InlineNsWithStrong const & lhs,
        InlineNsWithStrong const & rhs)
    noexcept(noexcept(std::declval<geo::Point const&>() != std::declval<geo::Point const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        InlineNsWithStrong const & lhs,
        InlineNsWithStrong const & rhs)
    noexcept(noexcept(std::declval<geo::Point const&>() == std::declval<geo::Point const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace global


namespace global {

/**
 * @brief Strong type wrapper for geo::Distance
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: global
 * - type_name: InlineNsWithoutStrong
 * - description: geo::Distance; !=, ==
 * - default_value: ""
 */
struct InlineNsWithoutStrong
: private atlas::strong_type_tag
{
    geo::Distance value;

    using atlas_value_type = geo::Distance;

    constexpr explicit InlineNsWithoutStrong() = default;
    constexpr InlineNsWithoutStrong(InlineNsWithoutStrong const &) = default;
    constexpr InlineNsWithoutStrong(InlineNsWithoutStrong &&) = default;
    constexpr InlineNsWithoutStrong & operator = (InlineNsWithoutStrong const &) = default;
    constexpr InlineNsWithoutStrong & operator = (InlineNsWithoutStrong &&) = default;
    constexpr ~InlineNsWithoutStrong() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<geo::Distance, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit InlineNsWithoutStrong(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator geo::Distance const & () const { return value; }
    constexpr explicit operator geo::Distance & () { return value; }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        InlineNsWithoutStrong const & lhs,
        InlineNsWithoutStrong const & rhs)
    noexcept(noexcept(std::declval<geo::Distance const&>() != std::declval<geo::Distance const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        InlineNsWithoutStrong const & lhs,
        InlineNsWithoutStrong const & rhs)
    noexcept(noexcept(std::declval<geo::Distance const&>() == std::declval<geo::Distance const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace global


namespace test {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: AllOpsStrong
 * - description: strong int; !=, %, *, +, ++, -, --, /, <, <=, ==, >, >=, hash
 * - default_value: ""
 */
struct AllOpsStrong
: private atlas::strong_type_tag
{
    int value;

    using atlas_value_type = int;

    constexpr explicit AllOpsStrong() = default;
    constexpr AllOpsStrong(AllOpsStrong const &) = default;
    constexpr AllOpsStrong(AllOpsStrong &&) = default;
    constexpr AllOpsStrong & operator = (AllOpsStrong const &) = default;
    constexpr AllOpsStrong & operator = (AllOpsStrong &&) = default;
    constexpr ~AllOpsStrong() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit AllOpsStrong(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int const & () const { return value; }
    constexpr explicit operator int & () { return value; }

    /**
     * Apply the prefix ++ operator to the wrapped object.
     */
    friend constexpr AllOpsStrong &
    operator ++ (AllOpsStrong & t)
    noexcept(noexcept(++std::declval<int&>()))
    {
        ++t.value;
        return t;
    }
    /**
     * Apply the postfix ++ operator to the wrapped object.
     */
    friend constexpr AllOpsStrong
    operator ++ (AllOpsStrong & t, int)
    noexcept(
        std::is_nothrow_copy_constructible<int>::value &&
        noexcept(++std::declval<int&>()))
    {
        auto result = t;
        ++t.value;
        return result;
    }

    /**
     * Apply the prefix -- operator to the wrapped object.
     */
    friend constexpr AllOpsStrong &
    operator -- (AllOpsStrong & t)
    noexcept(noexcept(--std::declval<int&>()))
    {
        --t.value;
        return t;
    }
    /**
     * Apply the postfix -- operator to the wrapped object.
     */
    friend constexpr AllOpsStrong
    operator -- (AllOpsStrong & t, int)
    noexcept(
        std::is_nothrow_copy_constructible<int>::value &&
        noexcept(--std::declval<int&>()))
    {
        auto result = t;
        --t.value;
        return result;
    }

    /**
     * Apply % assignment to the wrapped objects.
     */
    friend constexpr AllOpsStrong & operator %= (
        AllOpsStrong & lhs,
        AllOpsStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<int &>() %= std::declval<int const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value %= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator % to the wrapped object.
     */
    friend constexpr AllOpsStrong operator % (
        AllOpsStrong lhs,
        AllOpsStrong const & rhs)
    noexcept(noexcept(lhs %= rhs))
    {
        lhs %= rhs;
        return lhs;
    }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr AllOpsStrong & operator *= (
        AllOpsStrong & lhs,
        AllOpsStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<int &>() *= std::declval<int const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr AllOpsStrong operator * (
        AllOpsStrong lhs,
        AllOpsStrong const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr AllOpsStrong & operator += (
        AllOpsStrong & lhs,
        AllOpsStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<int &>() += std::declval<int const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr AllOpsStrong operator + (
        AllOpsStrong lhs,
        AllOpsStrong const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr AllOpsStrong & operator -= (
        AllOpsStrong & lhs,
        AllOpsStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<int &>() -= std::declval<int const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr AllOpsStrong operator - (
        AllOpsStrong lhs,
        AllOpsStrong const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr AllOpsStrong & operator /= (
        AllOpsStrong & lhs,
        AllOpsStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<int &>() /= std::declval<int const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr AllOpsStrong operator / (
        AllOpsStrong lhs,
        AllOpsStrong const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        AllOpsStrong const & lhs,
        AllOpsStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() != std::declval<int const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value < @p rhs.value?
     */
    friend constexpr bool operator < (
        AllOpsStrong const & lhs,
        AllOpsStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() < std::declval<int const&>()))
    {
        return lhs.value < rhs.value;
    }

    /**
     * Is @p lhs.value <= @p rhs.value?
     */
    friend constexpr bool operator <= (
        AllOpsStrong const & lhs,
        AllOpsStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() <= std::declval<int const&>()))
    {
        return lhs.value <= rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        AllOpsStrong const & lhs,
        AllOpsStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() == std::declval<int const&>()))
    {
        return lhs.value == rhs.value;
    }

    /**
     * Is @p lhs.value > @p rhs.value?
     */
    friend constexpr bool operator > (
        AllOpsStrong const & lhs,
        AllOpsStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() > std::declval<int const&>()))
    {
        return lhs.value > rhs.value;
    }

    /**
     * Is @p lhs.value >= @p rhs.value?
     */
    friend constexpr bool operator >= (
        AllOpsStrong const & lhs,
        AllOpsStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() >= std::declval<int const&>()))
    {
        return lhs.value >= rhs.value;
    }
};
} // namespace test


/**
 * @brief std::hash specialization for test::AllOpsStrong
 *
 * Delegates to std::hash of the underlying type int
 */
template <>
struct std::hash<test::AllOpsStrong>
{
    ATLAS_NODISCARD
    constexpr std::size_t operator () (test::AllOpsStrong const & t) const
    noexcept(
        noexcept(std::hash<int>{}(
            std::declval<int const &>())))
    {
        return std::hash<int>{}(
            static_cast<int const &>(t));
    }
};

namespace test {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: AllOpsNoStrong
 * - description: int; !=, %, *, +, ++, -, --, /, <, <=, ==, >, >=, hash
 * - default_value: ""
 */
struct AllOpsNoStrong
: private atlas::strong_type_tag
{
    int value;

    using atlas_value_type = int;

    constexpr explicit AllOpsNoStrong() = default;
    constexpr AllOpsNoStrong(AllOpsNoStrong const &) = default;
    constexpr AllOpsNoStrong(AllOpsNoStrong &&) = default;
    constexpr AllOpsNoStrong & operator = (AllOpsNoStrong const &) = default;
    constexpr AllOpsNoStrong & operator = (AllOpsNoStrong &&) = default;
    constexpr ~AllOpsNoStrong() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit AllOpsNoStrong(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int const & () const { return value; }
    constexpr explicit operator int & () { return value; }

    /**
     * Apply the prefix ++ operator to the wrapped object.
     */
    friend constexpr AllOpsNoStrong &
    operator ++ (AllOpsNoStrong & t)
    noexcept(noexcept(++std::declval<int&>()))
    {
        ++t.value;
        return t;
    }
    /**
     * Apply the postfix ++ operator to the wrapped object.
     */
    friend constexpr AllOpsNoStrong
    operator ++ (AllOpsNoStrong & t, int)
    noexcept(
        std::is_nothrow_copy_constructible<int>::value &&
        noexcept(++std::declval<int&>()))
    {
        auto result = t;
        ++t.value;
        return result;
    }

    /**
     * Apply the prefix -- operator to the wrapped object.
     */
    friend constexpr AllOpsNoStrong &
    operator -- (AllOpsNoStrong & t)
    noexcept(noexcept(--std::declval<int&>()))
    {
        --t.value;
        return t;
    }
    /**
     * Apply the postfix -- operator to the wrapped object.
     */
    friend constexpr AllOpsNoStrong
    operator -- (AllOpsNoStrong & t, int)
    noexcept(
        std::is_nothrow_copy_constructible<int>::value &&
        noexcept(--std::declval<int&>()))
    {
        auto result = t;
        --t.value;
        return result;
    }

    /**
     * Apply % assignment to the wrapped objects.
     */
    friend constexpr AllOpsNoStrong & operator %= (
        AllOpsNoStrong & lhs,
        AllOpsNoStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<int &>() %= std::declval<int const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value %= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator % to the wrapped object.
     */
    friend constexpr AllOpsNoStrong operator % (
        AllOpsNoStrong lhs,
        AllOpsNoStrong const & rhs)
    noexcept(noexcept(lhs %= rhs))
    {
        lhs %= rhs;
        return lhs;
    }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr AllOpsNoStrong & operator *= (
        AllOpsNoStrong & lhs,
        AllOpsNoStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<int &>() *= std::declval<int const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr AllOpsNoStrong operator * (
        AllOpsNoStrong lhs,
        AllOpsNoStrong const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr AllOpsNoStrong & operator += (
        AllOpsNoStrong & lhs,
        AllOpsNoStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<int &>() += std::declval<int const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr AllOpsNoStrong operator + (
        AllOpsNoStrong lhs,
        AllOpsNoStrong const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr AllOpsNoStrong & operator -= (
        AllOpsNoStrong & lhs,
        AllOpsNoStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<int &>() -= std::declval<int const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr AllOpsNoStrong operator - (
        AllOpsNoStrong lhs,
        AllOpsNoStrong const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr AllOpsNoStrong & operator /= (
        AllOpsNoStrong & lhs,
        AllOpsNoStrong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<int &>() /= std::declval<int const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr AllOpsNoStrong operator / (
        AllOpsNoStrong lhs,
        AllOpsNoStrong const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        AllOpsNoStrong const & lhs,
        AllOpsNoStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() != std::declval<int const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value < @p rhs.value?
     */
    friend constexpr bool operator < (
        AllOpsNoStrong const & lhs,
        AllOpsNoStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() < std::declval<int const&>()))
    {
        return lhs.value < rhs.value;
    }

    /**
     * Is @p lhs.value <= @p rhs.value?
     */
    friend constexpr bool operator <= (
        AllOpsNoStrong const & lhs,
        AllOpsNoStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() <= std::declval<int const&>()))
    {
        return lhs.value <= rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        AllOpsNoStrong const & lhs,
        AllOpsNoStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() == std::declval<int const&>()))
    {
        return lhs.value == rhs.value;
    }

    /**
     * Is @p lhs.value > @p rhs.value?
     */
    friend constexpr bool operator > (
        AllOpsNoStrong const & lhs,
        AllOpsNoStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() > std::declval<int const&>()))
    {
        return lhs.value > rhs.value;
    }

    /**
     * Is @p lhs.value >= @p rhs.value?
     */
    friend constexpr bool operator >= (
        AllOpsNoStrong const & lhs,
        AllOpsNoStrong const & rhs)
    noexcept(noexcept(std::declval<int const&>() >= std::declval<int const&>()))
    {
        return lhs.value >= rhs.value;
    }
};
} // namespace test


/**
 * @brief std::hash specialization for test::AllOpsNoStrong
 *
 * Delegates to std::hash of the underlying type int
 */
template <>
struct std::hash<test::AllOpsNoStrong>
{
    ATLAS_NODISCARD
    constexpr std::size_t operator () (test::AllOpsNoStrong const & t) const
    noexcept(
        noexcept(std::hash<int>{}(
            std::declval<int const &>())))
    {
        return std::hash<int>{}(
            static_cast<int const &>(t));
    }
};
#endif // TEST_OPTIONAL_STRONG_A5E529EB6D3A2860CC9414D660D28E0DCF1CD9E1

