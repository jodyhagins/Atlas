#ifndef FOO_BAR_106A4CA2FDA9252D5A184EAB9AF3555C0EB1F003
#define FOO_BAR_106A4CA2FDA9252D5A184EAB9AF3555C0EB1F003

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v1.0.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#if __has_include(<version>)
#include <version>
#endif
#include <concepts>
#include <functional>
#include <memory>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// ======================================================================
// ATLAS STRONG TYPE BOILERPLATE
// ----------------------------------------------------------------------
//
// This section provides the infrastructure for Atlas strong types.
// It is identical across all Atlas-generated files and uses a shared
// header guard (WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90) to ensure
// the boilerplate is only included once even when multiple generated
// files are used in the same translation unit.
//
// The boilerplate is intentionally inlined to make generated code
// self-contained with zero external dependencies.
//
// Components:
// - atlas::strong_type_tag: Base class for strong types
// - atlas::undress(): Universal value accessor for strong types
// - atlas_detail::*: Internal implementation utilities
//
// For projects using multiple Atlas-generated files, this boilerplate
// will only be compiled once per translation unit thanks to the shared
// header guard below.
//
// ----------------------------------------------------------------------
// DO NOT EDIT THIS SECTION
// ======================================================================

// Atlas feature detection macros
#ifndef ATLAS_NODISCARD
#if defined(__cpp_attributes) && __cpp_attributes >= 201603L
#define ATLAS_NODISCARD [[nodiscard]]
#else
#define ATLAS_NODISCARD
#endif
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif

#if defined(__cpp_lib_format) && __cpp_lib_format >= 202110L
#include <format>
#endif

namespace atlas {

struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;

template <typename T>
using remove_cv_t = typename std::remove_cv<T>::type;
template <typename T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <typename T>
using remove_cvref_t = remove_cv_t<remove_reference_t<T>>;
template <bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;
template <bool B>
using when = enable_if_t<B, bool>;

template <typename T>
using _t = typename T::type;

template <typename T, typename = void>
struct has_atlas_value_type
: std::false_type
{ };

template <typename T>
struct has_atlas_value_type<
    T,
    enable_if_t<not std::is_same<
        typename remove_cvref_t<T>::atlas_value_type,
        void>::value>>
: std::true_type
{ };

void atlas_value_for();
struct value_by_ref
{ };
struct value_by_val
{ };

// ----------------------------------------------------------------------------
// Base case: T does not have atlas_value_type
// These are the termination cases for the recursion.
// ----------------------------------------------------------------------------
template <typename T>
constexpr T &
value_impl(T & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T const &
value_impl(T const & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T
value_impl(T & t, PriorityTag<0>, value_by_val)
{
    return std::move(t);
}
template <typename T>
constexpr T
value_impl(T const & t, PriorityTag<0>, value_by_val)
{
    return t;
}

// ----------------------------------------------------------------------------
// Enum case: T is an enum - convert to underlying type
// Always returns by value since conversion creates a distinct value.
// ----------------------------------------------------------------------------
template <typename T>
constexpr auto
value_impl(T t, PriorityTag<2>, value_by_ref)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}
template <typename T>
constexpr auto
value_impl(T t, PriorityTag<2>, value_by_val)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}

// ----------------------------------------------------------------------------
// Recursive case: T has atlas_value_for() hidden friend
// Use ADL to call atlas_value_for() and recurse.
// ----------------------------------------------------------------------------
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_ref{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_ref{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    atlas_value_for(std::move(t)),
    value_tag{},
    value_by_val{}))
{
    return value_impl(atlas_value_for(std::move(t)), value_tag{}, value_by_val{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_val{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_val{});
}

struct ToUnderlying
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_val{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_val{});
    }
};

// ----------------------------------------------------------------------------
// Unwrap: Remove exactly one layer from atlas types or enums
// Unlike undress, this does NOT recurse.
// ----------------------------------------------------------------------------

template <typename T>
constexpr auto
unwrap_impl(T & t, PriorityTag<2>)
-> decltype(atlas_value_for(t))
{
    return atlas_value_for(t);
}

template <typename T>
constexpr auto
unwrap_impl(T const & t, PriorityTag<2>)
-> decltype(atlas_value_for(t))
{
    return atlas_value_for(t);
}

template <typename T>
constexpr auto
unwrap_impl(T && t, PriorityTag<2>)
-> typename std::enable_if<
    not std::is_lvalue_reference<T>::value,
    decltype(atlas_value_for(std::move(t)))>::type
{
    return atlas_value_for(std::move(t));
}

// Enum fallback - convert to underlying type
template <typename T>
constexpr auto
unwrap_impl(T t, PriorityTag<1>)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}

// No PriorityTag<0> - SFINAE failure for non-atlas/non-enum types

struct Unwrap
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(unwrap_impl(t, PriorityTag<2>{}))
    {
        return unwrap_impl(t, PriorityTag<2>{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(unwrap_impl(t, PriorityTag<2>{}))
    {
        return unwrap_impl(t, PriorityTag<2>{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(unwrap_impl(std::forward<T>(t), PriorityTag<2>{}))
    {
        return unwrap_impl(std::forward<T>(t), PriorityTag<2>{});
    }
};

// ----------------------------------------------------------------------------
// UndressEnum: Drill through atlas types and stop at enum
// Like undress, but stops at enum instead of converting to underlying type.
// SFINAE fails if the drill does not resolve to an enum.
// ----------------------------------------------------------------------------
using undress_enum_tag = PriorityTag<1>;

// Base case: T is an enum - return it (don't convert to underlying)
template <typename T>
constexpr auto
undress_enum_impl(T & t, PriorityTag<0>)
-> typename std::enable_if<std::is_enum<T>::value, T &>::type
{
    return t;
}

template <typename T>
constexpr auto
undress_enum_impl(T const & t, PriorityTag<0>)
-> typename std::enable_if<std::is_enum<T>::value, T const &>::type
{
    return t;
}

// Recursive case: drill through atlas types
template <typename T>
constexpr auto
undress_enum_impl(T & t, PriorityTag<1>)
-> decltype(undress_enum_impl(atlas_value_for(t), undress_enum_tag{}))
{
    return undress_enum_impl(atlas_value_for(t), undress_enum_tag{});
}

template <typename T>
constexpr auto
undress_enum_impl(T const & t, PriorityTag<1>)
-> decltype(undress_enum_impl(atlas_value_for(t), undress_enum_tag{}))
{
    return undress_enum_impl(atlas_value_for(t), undress_enum_tag{});
}

template <typename T>
constexpr auto
undress_enum_impl(T && t, PriorityTag<1>)
-> typename std::enable_if<
    not std::is_lvalue_reference<T>::value,
    decltype(undress_enum_impl(atlas_value_for(std::move(t)), undress_enum_tag{}))>::type
{
    return undress_enum_impl(atlas_value_for(std::move(t)), undress_enum_tag{});
}

struct UndressEnum
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(undress_enum_impl(t, undress_enum_tag{}))
    {
        return undress_enum_impl(t, undress_enum_tag{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(undress_enum_impl(t, undress_enum_tag{}))
    {
        return undress_enum_impl(t, undress_enum_tag{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(undress_enum_impl(std::forward<T>(t), undress_enum_tag{}))
    {
        return undress_enum_impl(std::forward<T>(t), undress_enum_tag{});
    }
};

// ----------------------------------------------------------------------------
// Type trait: holds_enum - true if undress_enum would succeed
// Uses the same mechanism as undress_enum to ensure consistency.
// ----------------------------------------------------------------------------
template <typename T, typename = void>
struct holds_enum_impl : std::false_type {};

template <typename T>
struct holds_enum_impl<
    T,
    void_t<decltype(undress_enum_impl(
        std::declval<remove_cvref_t<T> &>(),
        undress_enum_tag{}))>>
: std::true_type {};

using cast_tag = PriorityTag<1>;

// ----------------------------------------------------------------------------
// cast_impl: Drill down to find the first type castable to TargetT
// ----------------------------------------------------------------------------
template <typename TargetT, typename U>
constexpr auto
cast_impl(U && u, PriorityTag<1>)
-> decltype(static_cast<TargetT>(std::forward<U>(u)))
{
    return static_cast<TargetT>(std::forward<U>(u));
}

template <typename TargetT, typename U>
constexpr auto
cast_impl(U && u, PriorityTag<0>)
-> decltype(cast_impl<TargetT>(atlas_value_for(std::forward<U>(u)), cast_tag{}))
{
    return cast_impl<TargetT>(atlas_value_for(std::forward<U>(u)), cast_tag{});
}

template <typename TargetT>
struct CastTo
{
    template <typename U>
    constexpr auto
    operator () (U && u) const
    -> decltype(cast_impl<TargetT>(std::forward<U>(u), cast_tag{}))
    {
        return cast_impl<TargetT>(std::forward<U>(u), cast_tag{});
    }
};

void begin();
void end();

template <typename T>
constexpr auto
begin_(T && t) noexcept(noexcept(begin(std::forward<T>(t))))
-> decltype(begin(std::forward<T>(t)))
{
    return begin(std::forward<T>(t));
}

template <typename T>
constexpr auto
end_(T && t) noexcept(noexcept(end(std::forward<T>(t))))
-> decltype(end(std::forward<T>(t)))
{
    return end(std::forward<T>(t));
}

} // namespace atlas_detail

using atlas_detail::enable_if_t;
using atlas_detail::remove_cv_t;
using atlas_detail::remove_cvref_t;
using atlas_detail::when;

template <typename T>
using is_atlas_type = atlas_detail::has_atlas_value_type<T>;

template <typename T>
using holds_enum = atlas_detail::holds_enum_impl<atlas_detail::remove_cvref_t<T>>;

#if defined(__cpp_concepts) && __cpp_concepts >= 201907L
template <typename T>
concept AtlasTypeC = is_atlas_type<T>::value;

template <typename T>
concept HoldsEnumC = holds_enum<T>::value;
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto undress = atlas_detail::ToUnderlying{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto undress = atlas_detail::ToUnderlying{};
#else
// fallback: not nice, but not terrible and prevents ADL
namespace {
constexpr atlas_detail::ToUnderlying undress{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto unwrap = atlas_detail::Unwrap{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto unwrap = atlas_detail::Unwrap{};
#else
namespace {
constexpr atlas_detail::Unwrap unwrap{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto undress_enum = atlas_detail::UndressEnum{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto undress_enum = atlas_detail::UndressEnum{};
#else
namespace {
constexpr atlas_detail::UndressEnum undress_enum{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
template <typename TargetT>
inline constexpr atlas_detail::CastTo<TargetT> cast{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
template <typename TargetT>
constexpr atlas_detail::CastTo<TargetT> cast{};
#else
// fallback: function template (ADL still possible, but unavoidable in C++11)
template <typename TargetT, typename U>
constexpr auto
cast(U && u)
-> decltype(atlas_detail::cast_impl<TargetT>(
    std::forward<U>(u),
    atlas_detail::cast_tag{}))
{
    return atlas_detail::cast_impl<TargetT>(
        std::forward<U>(u),
        atlas_detail::cast_tag{});
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

#ifndef WJH_ATLAS_771333B44A11491895F986933BB2FB41
#define WJH_ATLAS_771333B44A11491895F986933BB2FB41
namespace atlas {
namespace atlas_detail {
// ----------------------------------------------------------------------------
// Hash drilling support
// ----------------------------------------------------------------------------

// is_hashable<T>: detects if std::hash<T> is valid
template <typename T, typename = void>
struct is_hashable
: std::false_type
{ };

template <typename T>
struct is_hashable<
    T,
    void_t<decltype(std::hash<T>{}(std::declval<T const &>()))>>
: std::true_type
{ };

// Base case: T is directly hashable
template <typename T>
auto hash_drill(T const & t, PriorityTag<2>)
-> typename std::enable_if<
    is_hashable<T>::value,
    std::size_t>::type
{
    return std::hash<T>{}(t);
}

// Enum fallback: T is an enum without std::hash, use underlying type
template <typename T>
auto hash_drill(T const & t, PriorityTag<1>)
-> typename std::enable_if<
    std::is_enum<T>::value &&
    not is_hashable<T>::value,
    std::size_t>::type
{
    return std::hash<typename std::underlying_type<T>::type>{}(
        static_cast<typename std::underlying_type<T>::type>(t));
}

// Recursive case: T is an atlas type, drill down
template <typename T>
auto hash_drill(T const & t, PriorityTag<0>)
-> decltype(hash_drill(atlas_value_for(t), PriorityTag<2>{}))
{
    return hash_drill(atlas_value_for(t), PriorityTag<2>{});
}
} // namespace atlas_detail
} // namespace atlas
#endif // WJH_ATLAS_771333B44A11491895F986933BB2FB41

#ifndef WJH_ATLAS_46CE143CD5E7495DAA505B54DBD417A2
#define WJH_ATLAS_46CE143CD5E7495DAA505B54DBD417A2

namespace atlas {
namespace atlas_detail {

struct const_
{
    template <typename T>
    static T const * _ (T * p) { return p; }
    template <typename T>
    static T const & _ (T const & p) { return p; }
};

struct mutable_
{
    template <typename T>
    static T * _ (T * p) { return p; }
    template <typename T>
    static T && _ (T && p) { return static_cast<T&&>(p); }
};

} // namespace atlas_detail
} // namespace atlas

#endif // WJH_ATLAS_46CE143CD5E7495DAA505B54DBD417A2

#ifndef WJH_ATLAS_A527B9864606413FB036AFD74BF8C8BF
#define WJH_ATLAS_A527B9864606413FB036AFD74BF8C8BF

namespace atlas {
namespace atlas_detail {

template <typename T, typename U>
auto
arrow_impl(U & u, PriorityTag<1>)
-> decltype(T::_(u.operator->()))
{
    return T::_(u.operator->());
}

template <typename T, typename U>
auto
arrow_impl(U * u, PriorityTag<1>)
-> decltype(T::_(u))
{
    return T::_(u);
}

template <typename T, typename U>
U * arrow_impl(U & u, PriorityTag<0>)
{
    return std::addressof(u);
}

} // namespace atlas_detail
} // namespace atlas

#endif // WJH_ATLAS_A527B9864606413FB036AFD74BF8C8BF

#ifndef WJH_ATLAS_05F39F486A854621A7A80EA8B40E7665
#define WJH_ATLAS_05F39F486A854621A7A80EA8B40E7665

namespace atlas {
namespace atlas_detail {

template <typename T, typename U>
auto
star_impl(U & u, PriorityTag<1>)
-> decltype(T::_(u.operator*()))
{
    return T::_(u.operator*());
}

template <typename T, typename U>
auto
star_impl(U * u, PriorityTag<1>)
-> decltype(*T::_(u))
{
    return *T::_(u);
}

template <typename T, typename U>
U & star_impl(U & u, PriorityTag<0>)
{
    return u;
}

} // namespace atlas_detail
} // namespace atlas

#endif // WJH_ATLAS_05F39F486A854621A7A80EA8B40E7665

#ifndef WJH_ATLAS_83B11BF12B6945019DF71C7517A1D6DA
#define WJH_ATLAS_83B11BF12B6945019DF71C7517A1D6DA
#if __cplusplus >= 202002L
namespace atlas::atlas_detail {

// Concept: T is an atlas type whose underlying value chain is eventually
// hashable
template <typename T>
concept atlas_hashable = has_atlas_value_type<T>::value &&
    requires(T const & t) {
        { hash_drill(atlas_value_for(t), PriorityTag<2>{}) }
            -> std::same_as<std::size_t>;
    };

} // namespace atlas::atlas_detail

template <typename T>
    requires atlas::atlas_detail::atlas_hashable<T>
struct std::hash<T>
{
    std::size_t operator()(T const & t) const
    noexcept(noexcept(atlas::atlas_detail::hash_drill(
        atlas_value_for(t), atlas::atlas_detail::PriorityTag<2>{})))
    {
        return atlas::atlas_detail::hash_drill(
            atlas_value_for(t), atlas::atlas_detail::PriorityTag<2>{});
    }
};
#endif // C++20
#endif // WJH_ATLAS_83B11BF12B6945019DF71C7517A1D6DA


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: BasicString
 * - description: std::string; forward=size,empty,clear; !=, ==
 * - default_value: ""
 */
struct BasicString
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit BasicString() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit BasicString(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(BasicString const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(BasicString & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(BasicString && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward clear to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * clear member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto clear(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.clear(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.clear(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.clear(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto clear(Args&&... args) const &
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) const &&
    noexcept(noexcept(std::move(value).clear(std::forward<Args>(args)...)))
    -> decltype(std::move(value).clear(std::forward<Args>(args)...))
    {
        return std::move(value).clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) &
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) &&
    noexcept(noexcept(std::move(value).clear(std::forward<Args>(args)...)))
    -> decltype(std::move(value).clear(std::forward<Args>(args)...))
    {
        return std::move(value).clear(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        BasicString const & lhs,
        BasicString const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        BasicString const & lhs,
        BasicString const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: AliasedString
 * - description: std::string; forward=size:length,empty:is_empty; !=, ==
 * - default_value: ""
 */
struct AliasedString
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit AliasedString() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit AliasedString(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(AliasedString const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(AliasedString & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(AliasedString && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward empty to wrapped object (aliased as is_empty)
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto is_empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object (aliased as length)
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto length(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto length(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        AliasedString const & lhs,
        AliasedString const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        AliasedString const & lhs,
        AliasedString const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: BothNameAndAlias
 * - description: std::string; forward=size,size:length,empty; !=, ==
 * - default_value: ""
 */
struct BothNameAndAlias
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit BothNameAndAlias() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit BothNameAndAlias(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(BothNameAndAlias const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(BothNameAndAlias & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(BothNameAndAlias && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object (aliased as length)
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto length(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto length(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        BothNameAndAlias const & lhs,
        BothNameAndAlias const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        BothNameAndAlias const & lhs,
        BothNameAndAlias const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ConstOnly
 * - description: std::string; forward=const,size,empty; !=, ==
 * - default_value: ""
 */
struct ConstOnly
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit ConstOnly() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ConstOnly(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(ConstOnly const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(ConstOnly & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(ConstOnly && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto empty(Args&&... args) const
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }





    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto size(Args&&... args) const
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }





    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        ConstOnly const & lhs,
        ConstOnly const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ConstOnly const & lhs,
        ConstOnly const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: MultipleLines
 * - description: std::string; !=, ==
 * - default_value: ""
 */
struct MultipleLines
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit MultipleLines() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit MultipleLines(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(MultipleLines const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(MultipleLines & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(MultipleLines && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward clear to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * clear member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto clear(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.clear(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.clear(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.clear(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto clear(Args&&... args) const &
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) const &&
    noexcept(noexcept(std::move(value).clear(std::forward<Args>(args)...)))
    -> decltype(std::move(value).clear(std::forward<Args>(args)...))
    {
        return std::move(value).clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) &
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) &&
    noexcept(noexcept(std::move(value).clear(std::forward<Args>(args)...)))
    -> decltype(std::move(value).clear(std::forward<Args>(args)...))
    {
        return std::move(value).clear(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        MultipleLines const & lhs,
        MultipleLines const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        MultipleLines const & lhs,
        MultipleLines const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::vector<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: IntVector
 * - description: std::vector<int>; forward=push_back,pop_back,size,empty; ==, iterable
 * - default_value: ""
 */
struct IntVector
: private atlas::strong_type_tag
{
    std::vector<int> value;

    using atlas_value_type = std::vector<int>;

    constexpr explicit IntVector() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::vector<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit IntVector(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::vector<int> const & atlas_value_for(IntVector const & self) noexcept {
        return self.value;
    }
    friend constexpr std::vector<int> & atlas_value_for(IntVector & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(IntVector && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::vector<int>>::value,
            std::vector<int>>::type
    {
        return std::move(self.value);
    }

    /**
     * Iterator type aliases for container-like interface.
     */
    using iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<std::vector<int>&>()));
    using const_iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<std::vector<int> const&>()));
    using value_type = typename std::remove_reference<decltype(
        *atlas::atlas_detail::begin_(
            std::declval<std::vector<int>&>()))>::type;

    /**
     * Member functions for iterator access.
     * Enables both explicit calls (e.g., s.begin()) and range-based for loops.
     * Uses ADL-enabled helpers that work in decltype/noexcept contexts.
     */
    constexpr auto begin()
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    constexpr auto end()
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    constexpr auto begin() const
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    constexpr auto end() const
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward pop_back to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * pop_back member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto pop_back(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.pop_back(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.pop_back(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.pop_back(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto pop_back(Args&&... args) const &
    noexcept(noexcept(value.pop_back(std::forward<Args>(args)...)))
    -> decltype(value.pop_back(std::forward<Args>(args)...))
    {
        return value.pop_back(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto pop_back(Args&&... args) const &&
    noexcept(noexcept(std::move(value).pop_back(std::forward<Args>(args)...)))
    -> decltype(std::move(value).pop_back(std::forward<Args>(args)...))
    {
        return std::move(value).pop_back(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto pop_back(Args&&... args) &
    noexcept(noexcept(value.pop_back(std::forward<Args>(args)...)))
    -> decltype(value.pop_back(std::forward<Args>(args)...))
    {
        return value.pop_back(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto pop_back(Args&&... args) &&
    noexcept(noexcept(std::move(value).pop_back(std::forward<Args>(args)...)))
    -> decltype(std::move(value).pop_back(std::forward<Args>(args)...))
    {
        return std::move(value).pop_back(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward push_back to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * push_back member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto push_back(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.push_back(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.push_back(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.push_back(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto push_back(Args&&... args) const &
    noexcept(noexcept(value.push_back(std::forward<Args>(args)...)))
    -> decltype(value.push_back(std::forward<Args>(args)...))
    {
        return value.push_back(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto push_back(Args&&... args) const &&
    noexcept(noexcept(std::move(value).push_back(std::forward<Args>(args)...)))
    -> decltype(std::move(value).push_back(std::forward<Args>(args)...))
    {
        return std::move(value).push_back(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto push_back(Args&&... args) &
    noexcept(noexcept(value.push_back(std::forward<Args>(args)...)))
    -> decltype(value.push_back(std::forward<Args>(args)...))
    {
        return value.push_back(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto push_back(Args&&... args) &&
    noexcept(noexcept(std::move(value).push_back(std::forward<Args>(args)...)))
    -> decltype(std::move(value).push_back(std::forward<Args>(args)...))
    {
        return std::move(value).push_back(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        IntVector const & lhs,
        IntVector const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() == std::declval<std::vector<int> const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::unique_ptr<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ResourceHandle
 * - description: std::unique_ptr<int>; forward=get,reset; ->, @, bool
 * - default_value: ""
 */
struct ResourceHandle
: private atlas::strong_type_tag
{
    std::unique_ptr<int> value;

    using atlas_value_type = std::unique_ptr<int>;

    constexpr explicit ResourceHandle() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::unique_ptr<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ResourceHandle(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::unique_ptr<int> const & atlas_value_for(ResourceHandle const & self) noexcept {
        return self.value;
    }
    friend constexpr std::unique_ptr<int> & atlas_value_for(ResourceHandle & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(ResourceHandle && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::unique_ptr<int>>::value,
            std::unique_ptr<int>>::type
    {
        return std::move(self.value);
    }

    /**
     * Return the result of casting the wrapped object to bool.
     */
    constexpr explicit operator bool () const
    noexcept(noexcept(static_cast<bool>(
        std::declval<std::unique_ptr<int> const&>())))
    {
        return static_cast<bool>(value);
    }

    /**
     * Dereference operator - forwards to wrapped type's operator* if available,
     * otherwise returns reference to wrapped value.
     *
     * Pointer types: dereferences the pointer (returns *ptr)
     * Pointer-like types (smart pointers, iterators, optional): returns *value
     * Other types: returns reference to value (fallback)
     */
    template <typename T = atlas::atlas_detail::const_>
    constexpr auto operator * () const
    -> decltype(atlas::atlas_detail::star_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::star_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    template <typename T = atlas::atlas_detail::mutable_>
    constexpr auto operator * ()
    -> decltype(atlas::atlas_detail::star_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<10>{}))
    {
        return atlas::atlas_detail::star_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<10>{});
    }

    /**
     * Arrow operator - forwards to wrapped type if it's a pointer or
     * pointer-like, otherwise returns pointer to wrapped value.
     *
     * pointer types: returns the pointer itself (built-in -> handles the rest)
     * pointer-like types (smart pointers): returns value.operator->()
     * other types: returns &value
     */
    template <typename T = atlas::atlas_detail::const_>
    constexpr auto operator -> () const
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    template <typename T = atlas::atlas_detail::mutable_>
    constexpr auto operator -> ()
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    /**
     * @brief Forward get to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * get member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto get(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.get(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.get(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.get(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto get(Args&&... args) const &
    noexcept(noexcept(value.get(std::forward<Args>(args)...)))
    -> decltype(value.get(std::forward<Args>(args)...))
    {
        return value.get(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto get(Args&&... args) const &&
    noexcept(noexcept(std::move(value).get(std::forward<Args>(args)...)))
    -> decltype(std::move(value).get(std::forward<Args>(args)...))
    {
        return std::move(value).get(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto get(Args&&... args) &
    noexcept(noexcept(value.get(std::forward<Args>(args)...)))
    -> decltype(value.get(std::forward<Args>(args)...))
    {
        return value.get(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto get(Args&&... args) &&
    noexcept(noexcept(std::move(value).get(std::forward<Args>(args)...)))
    -> decltype(std::move(value).get(std::forward<Args>(args)...))
    {
        return std::move(value).get(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward reset to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * reset member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto reset(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.reset(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.reset(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.reset(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto reset(Args&&... args) const &
    noexcept(noexcept(value.reset(std::forward<Args>(args)...)))
    -> decltype(value.reset(std::forward<Args>(args)...))
    {
        return value.reset(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto reset(Args&&... args) const &&
    noexcept(noexcept(std::move(value).reset(std::forward<Args>(args)...)))
    -> decltype(std::move(value).reset(std::forward<Args>(args)...))
    {
        return std::move(value).reset(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto reset(Args&&... args) &
    noexcept(noexcept(value.reset(std::forward<Args>(args)...)))
    -> decltype(value.reset(std::forward<Args>(args)...))
    {
        return value.reset(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto reset(Args&&... args) &&
    noexcept(noexcept(std::move(value).reset(std::forward<Args>(args)...)))
    -> decltype(std::move(value).reset(std::forward<Args>(args)...))
    {
        return std::move(value).reset(std::forward<Args>(args)...);
    }
#endif
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: AdvancedString
 * - description: std::string; forward=size:length,const,empty:is_empty,clear; !=, ==, hash
 * - default_value: ""
 */
struct AdvancedString
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit AdvancedString() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit AdvancedString(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(AdvancedString const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(AdvancedString & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(AdvancedString && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward clear to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * clear member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto clear(Args&&... args) const
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }





    /**
     * @brief Forward empty to wrapped object (aliased as is_empty)
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto is_empty(Args&&... args) const
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }





    /**
     * @brief Forward size to wrapped object (aliased as length)
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto length(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto length(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        AdvancedString const & lhs,
        AdvancedString const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        AdvancedString const & lhs,
        AdvancedString const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: Username
 * - description: std::string; forward=substr->Username; !=, ==
 * - default_value: ""
 */
struct Username
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit Username() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Username(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(Username const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(Username & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(Username && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward substr to wrapped object,
     * wrapping return value in Username
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Return value is wrapped in Username (requires Username to be
     * constructible from the memfn's return type).
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto substr(this Self&& self, Args&&... args)
    -> Username
    {
        return Username(std::forward<Self>(self).value.substr(std::forward<Args>(args)...));
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto substr(Args&&... args) const &
    -> Username
    {
        return Username(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) const &&
    -> Username
    {
        return Username(std::move(value).substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) &
    -> Username
    {
        return Username(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) &&
    -> Username
    {
        return Username(std::move(value).substr(std::forward<Args>(args)...));
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Username const & lhs,
        Username const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Username const & lhs,
        Username const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: EmailAddress
 * - description: std::string; forward=substr:substring->EmailAddress; !=, ==
 * - default_value: ""
 */
struct EmailAddress
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit EmailAddress() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit EmailAddress(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(EmailAddress const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(EmailAddress & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(EmailAddress && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward substr to wrapped object (aliased as substring),
     * wrapping return value in EmailAddress
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Return value is wrapped in EmailAddress (requires EmailAddress to be
     * constructible from the memfn's return type).
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto substring(this Self&& self, Args&&... args)
    -> EmailAddress
    {
        return EmailAddress(std::forward<Self>(self).value.substr(std::forward<Args>(args)...));
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto substring(Args&&... args) const &
    -> EmailAddress
    {
        return EmailAddress(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substring(Args&&... args) const &&
    -> EmailAddress
    {
        return EmailAddress(std::move(value).substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substring(Args&&... args) &
    -> EmailAddress
    {
        return EmailAddress(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substring(Args&&... args) &&
    -> EmailAddress
    {
        return EmailAddress(std::move(value).substr(std::forward<Args>(args)...));
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        EmailAddress const & lhs,
        EmailAddress const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        EmailAddress const & lhs,
        EmailAddress const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: SafeString
 * - description: std::string; forward=substr->SafeString,find; !=, ==
 * - default_value: ""
 */
struct SafeString
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit SafeString() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit SafeString(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(SafeString const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(SafeString & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(SafeString && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward find to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * find member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto find(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.find(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.find(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.find(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto find(Args&&... args) const &
    noexcept(noexcept(value.find(std::forward<Args>(args)...)))
    -> decltype(value.find(std::forward<Args>(args)...))
    {
        return value.find(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto find(Args&&... args) const &&
    noexcept(noexcept(std::move(value).find(std::forward<Args>(args)...)))
    -> decltype(std::move(value).find(std::forward<Args>(args)...))
    {
        return std::move(value).find(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto find(Args&&... args) &
    noexcept(noexcept(value.find(std::forward<Args>(args)...)))
    -> decltype(value.find(std::forward<Args>(args)...))
    {
        return value.find(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto find(Args&&... args) &&
    noexcept(noexcept(std::move(value).find(std::forward<Args>(args)...)))
    -> decltype(std::move(value).find(std::forward<Args>(args)...))
    {
        return std::move(value).find(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward substr to wrapped object,
     * wrapping return value in SafeString
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Return value is wrapped in SafeString (requires SafeString to be
     * constructible from the memfn's return type).
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto substr(this Self&& self, Args&&... args)
    -> SafeString
    {
        return SafeString(std::forward<Self>(self).value.substr(std::forward<Args>(args)...));
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto substr(Args&&... args) const &
    -> SafeString
    {
        return SafeString(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) const &&
    -> SafeString
    {
        return SafeString(std::move(value).substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) &
    -> SafeString
    {
        return SafeString(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) &&
    -> SafeString
    {
        return SafeString(std::move(value).substr(std::forward<Args>(args)...));
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        SafeString const & lhs,
        SafeString const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        SafeString const & lhs,
        SafeString const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: Name
 * - description: std::string; forward=size,empty,substr->Name; !=, ==
 * - default_value: ""
 */
struct Name
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit Name() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Name(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(Name const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(Name & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(Name && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward substr to wrapped object,
     * wrapping return value in Name
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Return value is wrapped in Name (requires Name to be
     * constructible from the memfn's return type).
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto substr(this Self&& self, Args&&... args)
    -> Name
    {
        return Name(std::forward<Self>(self).value.substr(std::forward<Args>(args)...));
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto substr(Args&&... args) const &
    -> Name
    {
        return Name(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) const &&
    -> Name
    {
        return Name(std::move(value).substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) &
    -> Name
    {
        return Name(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) &&
    -> Name
    {
        return Name(std::move(value).substr(std::forward<Args>(args)...));
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Name const & lhs,
        Name const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Name const & lhs,
        Name const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: Label
 * - description: std::string; !=, ==
 * - default_value: ""
 */
struct Label
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit Label() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Label(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(Label const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(Label & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(Label && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward substr to wrapped object,
     * wrapping return value in Label
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Return value is wrapped in Label (requires Label to be
     * constructible from the memfn's return type).
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto substr(this Self&& self, Args&&... args)
    -> Label
    {
        return Label(std::forward<Self>(self).value.substr(std::forward<Args>(args)...));
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto substr(Args&&... args) const &
    -> Label
    {
        return Label(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) const &&
    -> Label
    {
        return Label(std::move(value).substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) &
    -> Label
    {
        return Label(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto substr(Args&&... args) &&
    -> Label
    {
        return Label(std::move(value).substr(std::forward<Args>(args)...));
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Label const & lhs,
        Label const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Label const & lhs,
        Label const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: UserId
 * - description: std::string; forward=substr:extract->UserId; !=, ==
 * - default_value: ""
 */
struct UserId
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit UserId() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit UserId(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(UserId const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(UserId & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(UserId && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward substr to wrapped object (aliased as extract),
     * wrapping return value in UserId
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Return value is wrapped in UserId (requires UserId to be
     * constructible from the memfn's return type).
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto extract(this Self&& self, Args&&... args)
    -> UserId
    {
        return UserId(std::forward<Self>(self).value.substr(std::forward<Args>(args)...));
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto extract(Args&&... args) const &
    -> UserId
    {
        return UserId(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto extract(Args&&... args) const &&
    -> UserId
    {
        return UserId(std::move(value).substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto extract(Args&&... args) &
    -> UserId
    {
        return UserId(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto extract(Args&&... args) &&
    -> UserId
    {
        return UserId(std::move(value).substr(std::forward<Args>(args)...));
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        UserId const & lhs,
        UserId const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        UserId const & lhs,
        UserId const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: Token
 * - description: std::string; forward=size,substr:extract->Token,empty; !=, ==
 * - default_value: ""
 */
struct Token
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit Token() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Token(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(Token const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(Token & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(Token && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward substr to wrapped object (aliased as extract),
     * wrapping return value in Token
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Return value is wrapped in Token (requires Token to be
     * constructible from the memfn's return type).
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto extract(this Self&& self, Args&&... args)
    -> Token
    {
        return Token(std::forward<Self>(self).value.substr(std::forward<Args>(args)...));
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto extract(Args&&... args) const &
    -> Token
    {
        return Token(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto extract(Args&&... args) const &&
    -> Token
    {
        return Token(std::move(value).substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto extract(Args&&... args) &
    -> Token
    {
        return Token(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto extract(Args&&... args) &&
    -> Token
    {
        return Token(std::move(value).substr(std::forward<Args>(args)...));
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Token const & lhs,
        Token const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Token const & lhs,
        Token const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: Path
 * - description: std::string; forward=substr:segment->Path,find:locate; !=, ==
 * - default_value: ""
 */
struct Path
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit Path() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Path(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(Path const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(Path & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(Path && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward find to wrapped object (aliased as locate)
     *
     * This member function forwards all calls to the underlying type's
     * find member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto locate(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.find(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.find(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.find(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto locate(Args&&... args) const &
    noexcept(noexcept(value.find(std::forward<Args>(args)...)))
    -> decltype(value.find(std::forward<Args>(args)...))
    {
        return value.find(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto locate(Args&&... args) const &&
    noexcept(noexcept(std::move(value).find(std::forward<Args>(args)...)))
    -> decltype(std::move(value).find(std::forward<Args>(args)...))
    {
        return std::move(value).find(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto locate(Args&&... args) &
    noexcept(noexcept(value.find(std::forward<Args>(args)...)))
    -> decltype(value.find(std::forward<Args>(args)...))
    {
        return value.find(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto locate(Args&&... args) &&
    noexcept(noexcept(std::move(value).find(std::forward<Args>(args)...)))
    -> decltype(std::move(value).find(std::forward<Args>(args)...))
    {
        return std::move(value).find(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward substr to wrapped object (aliased as segment),
     * wrapping return value in Path
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Return value is wrapped in Path (requires Path to be
     * constructible from the memfn's return type).
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto segment(this Self&& self, Args&&... args)
    -> Path
    {
        return Path(std::forward<Self>(self).value.substr(std::forward<Args>(args)...));
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto segment(Args&&... args) const &
    -> Path
    {
        return Path(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto segment(Args&&... args) const &&
    -> Path
    {
        return Path(std::move(value).substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto segment(Args&&... args) &
    -> Path
    {
        return Path(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto segment(Args&&... args) &&
    -> Path
    {
        return Path(std::move(value).substr(std::forward<Args>(args)...));
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Path const & lhs,
        Path const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Path const & lhs,
        Path const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: Identifier
 * - description: std::string; !=, ==
 * - default_value: ""
 */
struct Identifier
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit Identifier() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Identifier(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(Identifier const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(Identifier & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(Identifier && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward substr to wrapped object (aliased as slice),
     * wrapping return value in Identifier
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Return value is wrapped in Identifier (requires Identifier to be
     * constructible from the memfn's return type).
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto slice(this Self&& self, Args&&... args)
    -> Identifier
    {
        return Identifier(std::forward<Self>(self).value.substr(std::forward<Args>(args)...));
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto slice(Args&&... args) const &
    -> Identifier
    {
        return Identifier(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto slice(Args&&... args) const &&
    -> Identifier
    {
        return Identifier(std::move(value).substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto slice(Args&&... args) &
    -> Identifier
    {
        return Identifier(value.substr(std::forward<Args>(args)...));
    }

    template <typename... Args>
    constexpr auto slice(Args&&... args) &&
    -> Identifier
    {
        return Identifier(std::move(value).substr(std::forward<Args>(args)...));
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Identifier const & lhs,
        Identifier const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Identifier const & lhs,
        Identifier const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ReadOnlyText
 * - description: std::string; forward=const,substr:portion->ReadOnlyText; !=, ==
 * - default_value: ""
 */
struct ReadOnlyText
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit ReadOnlyText() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ReadOnlyText(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(ReadOnlyText const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(ReadOnlyText & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(ReadOnlyText && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward substr to wrapped object (aliased as portion),
     * wrapping return value in ReadOnlyText
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     * Return value is wrapped in ReadOnlyText (requires ReadOnlyText to be
     * constructible from the memfn's return type).
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto portion(Args&&... args) const
    -> ReadOnlyText
    {
        return ReadOnlyText(value.substr(std::forward<Args>(args)...));
    }





    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        ReadOnlyText const & lhs,
        ReadOnlyText const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ReadOnlyText const & lhs,
        ReadOnlyText const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test

#endif // FOO_BAR_106A4CA2FDA9252D5A184EAB9AF3555C0EB1F003

