#ifndef FOO_BAR_7C85B91EBF83B6AB43C68D229B18A2FB5BDCDB26
#define FOO_BAR_7C85B91EBF83B6AB43C68D229B18A2FB5BDCDB26

static_assert(__cplusplus >= 202002L,
    "This file requires C++20 or later. Compile with -std=c++20 or higher.");

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v0.1.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#if __has_include(<version>)
#include <version>
#endif
#include <cmath>
#include <cstdint>
#include <limits>
#include <sstream>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <utility>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// ======================================================================
// ATLAS STRONG TYPE BOILERPLATE
// ----------------------------------------------------------------------
//
// This section provides the infrastructure for Atlas strong types.
// It is identical across all Atlas-generated files and uses a shared
// header guard (WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90) to ensure
// the boilerplate is only included once even when multiple generated
// files are used in the same translation unit.
//
// The boilerplate is intentionally inlined to make generated code
// self-contained with zero external dependencies.
//
// Components:
// - atlas::strong_type_tag: Base class for strong types
// - atlas::value(): Universal value accessor for strong types
// - atlas_detail::*: Internal implementation utilities
//
// For projects using multiple Atlas-generated files, this boilerplate
// will only be compiled once per translation unit thanks to the shared
// header guard below.
//
// ----------------------------------------------------------------------
// DO NOT EDIT THIS SECTION
// ======================================================================

// Atlas feature detection macros
#ifndef ATLAS_NODISCARD
#if defined(__cpp_attributes) && __cpp_attributes >= 201603L
#define ATLAS_NODISCARD [[nodiscard]]
#else
#define ATLAS_NODISCARD
#endif
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif

namespace atlas {

struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <typename T, typename = void>
struct IsAtlasType
: std::false_type
{ };

template <typename T>
struct IsAtlasType<T, void_t<typename T::atlas_value_type>>
: std::true_type
{ };

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;
template <typename T, typename U = void>
using enable_if = typename std::enable_if<T::value, U>::type;

template <typename T>
using _t = typename T::type;

void atlas_value();

template <typename T>
constexpr T &
value(T & val, PriorityTag<0>)
{
    return val;
}

template <typename T, typename U = typename T::atlas_value_type>
using val_t = _t<std::conditional<std::is_const<T>::value, U const &, U &>>;

template <typename T, typename U = val_t<T>>
constexpr auto
value(T & val, PriorityTag<1>)
-> decltype(atlas::atlas_detail::value(static_cast<U>(val), value_tag{}))
{
    return atlas::atlas_detail::value(static_cast<U>(val), value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<2>)
-> decltype(atlas_value(t, atlas::value_tag{}))
{
    return atlas_value(t, atlas::value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<3>)
-> decltype(atlas_value(t))
{
    return atlas_value(t);
}

class Value
{
    template <
        typename U,
        typename T,
        typename V = _t<std::conditional<is_lref<U &&>::value, T &, T>>>
    static constexpr V rval(T && t)
    {
        return t;
    }

public:
    template <typename T>
    constexpr auto operator () (T && t) const
    -> decltype(rval<T>(atlas_detail::value(t, atlas_detail::value_tag{})))
    {
        return rval<T>(atlas_detail::value(t, atlas_detail::value_tag{}));
    }
};

void begin();
void end();

template <typename T>
constexpr auto
begin_(T && t) noexcept(noexcept(begin(std::forward<T>(t))))
-> decltype(begin(std::forward<T>(t)))
{
    return begin(std::forward<T>(t));
}

template <typename T>
constexpr auto
end_(T && t) noexcept(noexcept(end(std::forward<T>(t))))
-> decltype(end(std::forward<T>(t)))
{
    return end(std::forward<T>(t));
}

} // namespace atlas_detail

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto value = atlas_detail::Value{};
#else
template <typename T>
constexpr auto
value(T && t)
-> decltype(atlas_detail::Value{}(std::forward<T>(t)))
{
    return atlas_detail::Value{}(std::forward<T>(t));
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

#ifndef WJH_ATLAS_8BF8485B2F9D45ACAD473DC5B3274DDF
#define WJH_ATLAS_8BF8485B2F9D45ACAD473DC5B3274DDF

namespace atlas {

/**
 * Base class for arithmetic-related errors in checked arithmetic mode.
 *
 * This serves as the base class for all arithmetic exceptions thrown by
 * checked arithmetic operations on Atlas strong types.
 *
 * @see CheckedOverflowError
 * @see CheckedUnderflowError
 * @see CheckedDivisionByZeroError
 * @see CheckedInvalidOperationError
 */
class ArithmeticError
: public std::runtime_error
{
public:
    using std::runtime_error::runtime_error;
    virtual ~ArithmeticError() noexcept = default;
};

/**
 * Thrown when an arithmetic operation goes above the maximum representable
 * value.
 *
 * This exception is thrown by checked arithmetic operations when the result
 * would exceed std::numeric_limits<T>::max() for the underlying type.
 *
 * @note This is distinct from std::overflow_error, which represents
 * floating-point overflow. This exception represents integer and
 * floating-point range violations in checked arithmetic operations.
 *
 * Examples:
 * - CheckedInt8{127} + CheckedInt8{1}
 * - CheckedInt{INT_MAX} + CheckedInt{1}
 * - CheckedDouble{DBL_MAX} + CheckedDouble{DBL_MAX}
 *
 * @see CheckedUnderflowError for negative range violations
 * @see std::overflow_error (different semantics!)
 */
class CheckedOverflowError
: public ArithmeticError
{
public:
    using ArithmeticError::ArithmeticError;
    virtual ~CheckedOverflowError() noexcept = default;
};

/**
 * Thrown when an arithmetic operation goes below the minimum representable
 * value.
 *
 * This exception is thrown by checked arithmetic operations when the result
 * would be less than std::numeric_limits<T>::min() for signed types, or less
 * than zero for unsigned types during subtraction.
 *
 * @note This is NOT the same as std::underflow_error, which represents
 * floating-point gradual underflow. This represents integer and
 * floating-point range violations in checked arithmetic operations.
 *
 * Examples:
 * - CheckedInt8{-128} - CheckedInt8{1}
 * - CheckedInt{INT_MIN} - CheckedInt{1}
 * - CheckedUInt{0} - CheckedUInt{1}
 *
 * @see CheckedOverflowError for positive range violations
 * @see std::underflow_error (different semantics!)
 */
class CheckedUnderflowError
: public ArithmeticError
{
public:
    using ArithmeticError::ArithmeticError;
    virtual ~CheckedUnderflowError() noexcept = default;
};

/**
 * Thrown when dividing or taking modulo by zero in checked arithmetic mode.
 *
 * This exception is thrown by checked arithmetic operations when attempting
 * to divide or compute modulo with a zero divisor, which is undefined behavior
 * in C++.
 *
 * Examples:
 * - CheckedInt{5} / CheckedInt{0}
 * - CheckedInt{10} % CheckedInt{0}
 * - CheckedDouble{3.14} / CheckedDouble{0.0}
 *
 * @see CheckedInvalidOperationError for NaN-producing operations
 */
class CheckedDivisionByZeroError
: public ArithmeticError
{
public:
    using ArithmeticError::ArithmeticError;
    virtual ~CheckedDivisionByZeroError() noexcept = default;
};

/**
 * Thrown when a floating-point operation produces an invalid result (NaN).
 *
 * This exception is thrown by checked arithmetic operations when a floating-point
 * operation would produce NaN (Not-a-Number) according to IEEE 754 semantics.
 *
 * @note This is distinct from IEEE 754 invalid operation exceptions and
 * represents NaN detection in checked arithmetic mode, not hardware exception
 * handling.
 *
 * Examples:
 * - CheckedDouble{0.0} / CheckedDouble{0.0}  // 0/0 -> NaN
 * - CheckedDouble{INFINITY} - CheckedDouble{INFINITY}  // inf-inf -> NaN
 * - CheckedDouble{-1.0}.sqrt()  // sqrt(-1) -> NaN (if sqrt method exists)
 *
 * @see CheckedDivisionByZeroError for division by zero
 * @see CheckedOverflowError for overflow to infinity
 */
class CheckedInvalidOperationError
: public ArithmeticError
{
public:
    using ArithmeticError::ArithmeticError;
    virtual ~CheckedInvalidOperationError() noexcept = default;
};

namespace atlas_detail {

template <typename T>
using EnableFloatingPoint = typename std::enable_if<
    std::is_floating_point<T>::value,
    T>::type;

template <typename T>
using EnableSigned = typename std::enable_if<
    std::is_signed<T>::value && std::is_integral<T>::value,
    T>::type;

template <typename T>
using EnableUnsigned = typename std::enable_if<
    std::is_unsigned<T>::value && std::is_integral<T>::value,
    T>::type;

template <typename T>
EnableFloatingPoint<T>
checked_add(T a, T b, char const * overflow, char const * underflow)
{
    T result = a + b;
    if (std::isinf(result)) {
        if (result > 0) {
            throw CheckedOverflowError(overflow);
        } else {
            throw CheckedUnderflowError(underflow);
        }
    }
    if (std::isnan(result)) {
        throw CheckedInvalidOperationError("Invalid operation: NaN result");
    }
    return result;
}

template <typename T>
EnableUnsigned<T>
checked_add(T a, T b, char const * error_msg, char const * = "")
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_add_overflow(a, b, &result)) {
        throw CheckedOverflowError(error_msg);
    }
    return result;
#else
    if (a > std::numeric_limits<T>::max() - b) {
        throw CheckedOverflowError(error_msg);
    }
    return a + b;
#endif
}

template <typename T>
EnableSigned<T>
checked_add(T a, T b, char const * overflow, char const * underflow)
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_add_overflow(a, b, &result)) {
        if (b < 0) {
            throw CheckedUnderflowError(underflow);
        } else {
            throw CheckedOverflowError(overflow);
        }
    }
    return result;
#else
    if (b > 0 && a > std::numeric_limits<T>::max() - b) {
        throw CheckedOverflowError(overflow);
    } else if (b < 0 && a < std::numeric_limits<T>::lowest() - b) {
        throw CheckedUnderflowError(underflow);
    }
    return a + b;
#endif
}

template <typename T>
EnableFloatingPoint<T>
checked_sub(T a, T b, char const * overflow, char const * underflow)
{
    a -= b;
    if (std::isinf(a)) {
        if (a > 0) {
            throw CheckedOverflowError(overflow);
        } else {
            throw CheckedUnderflowError(underflow);
        }
    } else if (std::isnan(a)) {
        throw CheckedInvalidOperationError("Invalid operation: NaN result");
    }
    return a;
}

template <typename T>
EnableUnsigned<T>
checked_sub(T a, T b, char const *, char const * underflow)
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_sub_overflow(a, b, &result)) {
        throw CheckedUnderflowError(underflow);
    }
    return result;
#else
    if (a < b) {
        throw CheckedUnderflowError(underflow);
    }
    return a - b;
#endif
}

template <typename T>
EnableSigned<T>
checked_sub(T a, T b, char const * overflow, char const * underflow)
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_sub_overflow(a, b, &result)) {
        if (b > 0) {
            throw CheckedUnderflowError(underflow);
        } else {
            throw CheckedOverflowError(overflow);
        }
    }
    return result;
#else
    if (b < 0 && a > std::numeric_limits<T>::max() + b) {
        throw CheckedOverflowError(overflow);
    } else if (b > 0 && a < std::numeric_limits<T>::lowest() + b) {
        throw CheckedUnderflowError(underflow);
    }
    return a - b;
#endif
}

template <typename T>
EnableFloatingPoint<T>
checked_mul(T a, T b, char const * overflow, char const *)
{
    // Check for multiplication that would produce NaN (inf * 0 or 0 * inf)
    if ((std::isinf(a) && b == static_cast<T>(0.0)) ||
        (a == static_cast<T>(0.0) && std::isinf(b))) {
        throw CheckedInvalidOperationError(overflow);
    }

    a *= b;
    if (std::isinf(a)) {
        throw CheckedOverflowError(overflow);
    } else if (std::isnan(a)) {
        throw CheckedInvalidOperationError(overflow);
    }
    return a;
}

template <typename T>
EnableUnsigned<T>
checked_mul(T a, T b, char const * overflow, char const *)
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_mul_overflow(a, b, &result)) {
        throw CheckedOverflowError(overflow);
    }
    return result;
#else
    if (b != 0 && a > std::numeric_limits<T>::max() / b) {
        throw CheckedOverflowError(overflow);
    }
    return a * b;
#endif
}

template <typename T>
EnableSigned<T>
checked_mul(T a, T b, char const * overflow, char const * underflow)
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_mul_overflow(a, b, &result)) {
        // Determine if overflow or underflow based on operand signs
        bool same_sign = (a > 0) == (b > 0);
        if (same_sign) {
            throw CheckedOverflowError(overflow);
        } else {
            throw CheckedUnderflowError(underflow);
        }
    }
    return result;
#else
    // Handle zero cases
    if (a == 0 || b == 0) {
        return 0;
    }

    // Check for __int128 support (GCC/Clang on 64-bit platforms)
#if defined(__SIZEOF_INT128__) && (sizeof(T) < 16)
    // Use __int128 for widening (works for all types up to 64-bit)
    __int128 result = static_cast<__int128>(a) * static_cast<__int128>(b);
    if (result < static_cast<__int128>(std::numeric_limits<T>::lowest()) ||
        result > static_cast<__int128>(std::numeric_limits<T>::max()))
    {
        throw CheckedOverflowError(overflow);
    }
    return static_cast<T>(result);
#else
    // Fallback: widening for small types, division checks for long long
    if (sizeof(T) < sizeof(long long)) {
        auto result = static_cast<long long>(a) * static_cast<long long>(b);
        if (result < static_cast<long long>(std::numeric_limits<T>::lowest()) ||
            result > static_cast<long long>(std::numeric_limits<T>::max()))
        {
            throw CheckedOverflowError(overflow);
        }
        return static_cast<T>(result);
    } else {
        // For long long itself (or __int128 if that's T), use division checks
        // Check all four sign combinations
        if (a > 0) {
            if (b > 0) {
                if (a > std::numeric_limits<T>::max() / b) {
                    throw CheckedOverflowError(overflow);
                }
            } else {
                if (b < std::numeric_limits<T>::lowest() / a) {
                    throw CheckedOverflowError(overflow);
                }
            }
        } else {
            if (b > 0) {
                if (a < std::numeric_limits<T>::lowest() / b) {
                    throw CheckedOverflowError(overflow);
                }
            } else {
                if (a != 0 && b < std::numeric_limits<T>::max() / a) {
                    throw CheckedOverflowError(overflow);
                }
            }
        }
        return a * b;
    }
#endif
#endif
}

template <typename T>
EnableFloatingPoint<T>
checked_div(T a, T b, char const * div_by_zero, char const *)
{
    // Division by zero: throw exception (including 0.0/0.0 which produces NaN)
    if (b == T(0)) {
        throw CheckedDivisionByZeroError(div_by_zero);
    }
    // Check for inf / inf which produces NaN
    if (std::isinf(a) && std::isinf(b)) {
        throw CheckedInvalidOperationError(div_by_zero);
    }
    a /= b;
    if (std::isinf(a)) {
        throw CheckedOverflowError(div_by_zero);
    } else if (std::isnan(a)) {
        throw CheckedInvalidOperationError(div_by_zero);
    }
    return a;
}

template <typename T>
EnableUnsigned<T>
checked_div(T a, T b, char const * div_by_zero, char const *)
{
    if (b == T(0)) {
        throw CheckedDivisionByZeroError(div_by_zero);
    }
    return a / b;
}

template <typename T>
EnableSigned<T>
checked_div(T a, T b, char const * div_by_zero, char const * overflow)
{
    if (b == T(0)) {
        throw CheckedDivisionByZeroError(div_by_zero);
    }
    // Check for special case: INT_MIN / -1 overflows
    if (a == std::numeric_limits<T>::lowest() && b == T(-1)) {
        throw CheckedOverflowError(overflow);
    }
    return a / b;
}

template <typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
checked_mod(T a, T b, char const * div_by_zero)
{
    if (b == T(0)) {
        throw CheckedDivisionByZeroError(div_by_zero);
    }
    // INT_MIN % -1 is UB - throw for consistency with INT_MIN / -1
    if (std::is_signed<T>::value &&
        a == std::numeric_limits<T>::lowest() &&
        b == static_cast<T>(-1)) {
        throw CheckedOverflowError(div_by_zero);  // Consistent with division
    }
    return a % b;
}

// Modulo for floating-point - not provided (use static_assert in caller)

} // namespace atlas_detail
} // namespace atlas

#endif // WJH_ATLAS_8BF8485B2F9D45ACAD473DC5B3274DDF

#ifndef WJH_ATLAS_173D2C4FC9AA46929AD14C8BDF75D829
#define WJH_ATLAS_173D2C4FC9AA46929AD14C8BDF75D829

#include <sstream>

namespace atlas {

/**
 * @brief Exception thrown when a constraint is violated
 */
class ConstraintError
: public std::logic_error
{
public:
    using std::logic_error::logic_error;
    virtual ~ConstraintError() noexcept = default;
};

namespace atlas_detail {

template <typename T>
std::string
format_value_impl(T const &, PriorityTag<0>)
{
    return "unknown value";
}

template <typename T>
auto
format_value_impl(T const & value, PriorityTag<1>)
-> decltype(std::declval<std::ostringstream &>() << value, std::string())
{
    std::ostringstream oss;
    oss << value;
    return oss.str();
}

template <typename T>
auto
format_value_impl(T const & value, PriorityTag<2>)
-> decltype(std::to_string(value))
{
    return std::to_string(value);
}

template <typename T>
std::string
format_value(T const & value)
{
    return format_value_impl(value, PriorityTag<2>{});
}

inline int uncaught_exceptions() noexcept
{
#if defined(__cpp_lib_uncaught_exceptions) && \
    __cpp_lib_uncaught_exceptions >= 201411L
    return std::uncaught_exceptions();
#elif defined(_MSC_VER)
    return __uncaught_exceptions();  // MSVC extension available since VS2015
#elif defined(__GLIBCXX__)
    // libstdc++ has __cxa_get_globals which tracks uncaught exceptions
    return __cxxabiv1::__cxa_get_globals()->uncaughtExceptions;
#elif defined(_LIBCPP_VERSION)
    // libc++ has std::uncaught_exceptions even in C++11 mode as extension
    return std::uncaught_exceptions();
#else
    // Fallback: use old uncaught_exception() (singular) - less safe but works
    // This will return 1 during any exception, 0 otherwise
    // Can't distinguish between multiple exceptions, but better than nothing
    return std::uncaught_exception() ? 1 : 0;
#endif
}

/**
 * @brief RAII guard for validating constraints after mutating operations
 *
 * This guard validates constraints in its destructor, ensuring that the
 * constraint is checked after the operation completes. The guard checks
 * uncaught_exceptions() to avoid throwing during stack unwinding.
 *
 * Only validates non-const operations - const operations cannot violate
 * constraints by definition.
 *
 * @tparam T The value type being constrained (may be const)
 * @tparam ConstraintT The constraint type with static check() and message()
 */
template <typename T, typename ConstraintT, typename = void>
struct ConstraintGuard
{
    using value_type = typename std::remove_const<T>::type;

    T const & value;
    char const * operation_name;
    int uncaught_at_entry;

    /**
     * @brief Construct guard, capturing current exception state
     */
    constexpr ConstraintGuard(T const & v, char const * op) noexcept
    : value(v)
    , operation_name(op)
    , uncaught_at_entry(atlas::atlas_detail::uncaught_exceptions())
    { }

    /**
     * @brief Destructor validates constraint if no new exceptions
     *
     * Only throws if the constraint is violated AND no exceptions are
     * currently unwinding (to avoid std::terminate).
     *
     * Only validates non-const operations - uses std::is_const to check.
     */
    constexpr ~ConstraintGuard() noexcept(false)
    {
        if (atlas::atlas_detail::uncaught_exceptions() == uncaught_at_entry) {
            if (not ConstraintT::check(value)) {
                throw atlas::ConstraintError(
                    std::string(operation_name) +
                    ": operation violates constraint (" +
                    ConstraintT::message() + ")");
            }
        }
    }
};

template <typename T, typename ConstraintT>
struct ConstraintGuard<
    T,
    ConstraintT,
    typename std::enable_if<std::is_const<T>::value>::type>
{
    constexpr ConstraintGuard(T const &, char const *) noexcept
    { }
};

template <typename ConstraintT, typename T>
auto constraint_guard(T & t, char const * op) noexcept
{
    return ConstraintGuard<T, ConstraintT>(t, op);
}

} // namespace atlas_detail

namespace constraints {

/**
 * @brief Constraint: value must be > 0
 */
template <typename T>
struct positive
{
    static constexpr bool check(T value)
        noexcept(noexcept(value > T{0}))
    {
        return value > T{0};
    }

    static constexpr char const * message() noexcept {
        return "value must be positive (> 0)";
    }
};

/**
 * @brief Constraint: value must be >= 0
 */
template <typename T>
struct non_negative
{
    static constexpr bool check(T value)
        noexcept(noexcept(value >= T{0}))
    {
        return value >= T{0};
    }

    static constexpr char const * message() noexcept {
        return "value must be non-negative (>= 0)";
    }
};

/**
 * @brief Constraint: value must be != 0
 */
template <typename T>
struct non_zero
{
    static constexpr bool check(T value)
        noexcept(noexcept(value != T{0}))
    {
        return value != T{0};
    }

    static constexpr char const * message() noexcept {
        return "value must be non-zero (!= 0)";
    }
};

/**
 * Constraint: value must be in [Min, Max]
 */
template <typename T>
struct bounded
{
    static constexpr bool check(typename T::value_type const & value)
    noexcept(noexcept(value >= T::min()) && noexcept(value <= T::max()))
    {
        return value >= T::min() && value <= T::max();
    }

    static constexpr char const * message() noexcept {
        return T::message();
    }
};

/**
 * Constraint: value must be in [Min, Max) (half-open range)
 */
template <typename T>
struct bounded_range
{
    static constexpr bool check(typename T::value_type const & value)
    noexcept(noexcept(value >= T::min()) && noexcept(value < T::max()))
    {
        return value >= T::min() && value < T::max();
    }

    static constexpr char const * message() noexcept {
        return T::message();
    }
};

/**
 * @brief Constraint: container/string must not be empty
 */
template <typename T>
struct non_empty
{
    static constexpr bool check(T const & value)
        noexcept(noexcept(value.empty()))
    {
        return not value.empty();
    }

    static constexpr char const * message() noexcept {
        return "value must not be empty";
    }
};

/**
 * @brief Constraint: pointer must not be null
 *
 * Works with raw pointers, smart pointers (unique_ptr, shared_ptr), and
 * std::optional by using explicit bool conversion (operator bool()).
 *
 * Note: weak_ptr requires C++23 for operator bool() support.
 */
template <typename T>
struct non_null
{
    static constexpr bool check(T const & value)
        noexcept(noexcept(static_cast<bool>(std::declval<T const &>())))
    {
        // Use explicit bool conversion - works for:
        // - Raw pointers (void*, int*, etc.)
        // - Smart pointers (unique_ptr, shared_ptr)
        // - std::optional
        // - Any type with explicit operator bool()
        return static_cast<bool>(value);
    }

    static constexpr char const * message() noexcept {
        return "pointer must not be null";
    }
};

} // namespace constraints
} // namespace atlas

#endif // WJH_ATLAS_173D2C4FC9AA46929AD14C8BDF75D829


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////


namespace test {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: HalfOpenPercentage
 * - description: int; <=>, bounded_range<0,100>
 * - default_value: ""
 */
struct HalfOpenPercentage
: private atlas::strong_type_tag
{
    int value;

    using atlas_value_type = int;
    struct atlas_bounds
    {
        using value_type = atlas_value_type;
        static constexpr value_type min() noexcept {
            return value_type(0);
        }
        static constexpr value_type max() noexcept {
            return value_type(100);
        }
        static constexpr char const * message() noexcept {
            return "value must be in [0, 100)";
        }
    };
    using atlas_constraint = atlas::constraints::bounded_range<atlas_bounds>;

    constexpr explicit HalfOpenPercentage() = default;
    constexpr HalfOpenPercentage(HalfOpenPercentage const &) = default;
    constexpr HalfOpenPercentage(HalfOpenPercentage &&) = default;
    constexpr HalfOpenPercentage & operator = (HalfOpenPercentage const &) = default;
    constexpr HalfOpenPercentage & operator = (HalfOpenPercentage &&) = default;
    constexpr ~HalfOpenPercentage() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit HalfOpenPercentage(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas_constraint::check(value)) {
            throw atlas::ConstraintError(
                "HalfOpenPercentage: " + atlas::atlas_detail::format_value(value) +
                " violates constraint: value must be in [0, 100)");
        }
    }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int const & () const { return value; }
    constexpr explicit operator int & () { return value; }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        HalfOpenPercentage const &,
        HalfOpenPercentage const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        HalfOpenPercentage const & lhs,
        HalfOpenPercentage const & rhs)
    noexcept(noexcept(std::declval<int const &>() <
        std::declval<int const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        HalfOpenPercentage const & lhs,
        HalfOpenPercentage const & rhs)
    noexcept(noexcept(std::declval<int const &>() <=
        std::declval<int const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        HalfOpenPercentage const & lhs,
        HalfOpenPercentage const & rhs)
    noexcept(noexcept(std::declval<int const &>() >
        std::declval<int const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        HalfOpenPercentage const & lhs,
        HalfOpenPercentage const & rhs)
    noexcept(noexcept(std::declval<int const &>() >=
        std::declval<int const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        HalfOpenPercentage const &,
        HalfOpenPercentage const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        HalfOpenPercentage const & lhs,
        HalfOpenPercentage const & rhs)
    noexcept(noexcept(std::declval<int const &>() ==
        std::declval<int const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        HalfOpenPercentage const & lhs,
        HalfOpenPercentage const & rhs)
    noexcept(noexcept(std::declval<int const &>() !=
        std::declval<int const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace test


namespace physics {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: physics
 * - type_name: CelsiusRange
 * - description: double; *, +, -, /, bounded_range<0.0,100.0>, c++20
 * - default_value: ""
 */
struct CelsiusRange
: private atlas::strong_type_tag
{
    double value;

    using atlas_value_type = double;
    struct atlas_bounds
    {
        using value_type = atlas_value_type;
        static constexpr value_type min() noexcept {
            return value_type(0.0);
        }
        static constexpr value_type max() noexcept {
            return value_type(100.0);
        }
        static constexpr char const * message() noexcept {
            return "value must be in [0.0, 100.0)";
        }
    };
    using atlas_constraint = atlas::constraints::bounded_range<atlas_bounds>;

    constexpr explicit CelsiusRange() = default;
    constexpr CelsiusRange(CelsiusRange const &) = default;
    constexpr CelsiusRange(CelsiusRange &&) = default;
    constexpr CelsiusRange & operator = (CelsiusRange const &) = default;
    constexpr CelsiusRange & operator = (CelsiusRange &&) = default;
    constexpr ~CelsiusRange() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<double, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit CelsiusRange(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas_constraint::check(value)) {
            throw atlas::ConstraintError(
                "CelsiusRange: " + atlas::atlas_detail::format_value(value) +
                " violates constraint: value must be in [0.0, 100.0)");
        }
    }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator double const & () const { return value; }
    constexpr explicit operator double & () { return value; }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr CelsiusRange & operator *= (
        CelsiusRange & lhs,
        CelsiusRange const & rhs)
    {
        lhs.value *= rhs.value;
        if (not atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "CelsiusRange: arithmetic result violates constraint (value must be in [0.0, 100.0))");
        }
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr CelsiusRange operator * (
        CelsiusRange lhs,
        CelsiusRange const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr CelsiusRange & operator += (
        CelsiusRange & lhs,
        CelsiusRange const & rhs)
    {
        lhs.value += rhs.value;
        if (not atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "CelsiusRange: arithmetic result violates constraint (value must be in [0.0, 100.0))");
        }
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr CelsiusRange operator + (
        CelsiusRange lhs,
        CelsiusRange const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr CelsiusRange & operator -= (
        CelsiusRange & lhs,
        CelsiusRange const & rhs)
    {
        lhs.value -= rhs.value;
        if (not atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "CelsiusRange: arithmetic result violates constraint (value must be in [0.0, 100.0))");
        }
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr CelsiusRange operator - (
        CelsiusRange lhs,
        CelsiusRange const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr CelsiusRange & operator /= (
        CelsiusRange & lhs,
        CelsiusRange const & rhs)
    {
        lhs.value /= rhs.value;
        if (not atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "CelsiusRange: arithmetic result violates constraint (value must be in [0.0, 100.0))");
        }
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr CelsiusRange operator / (
        CelsiusRange lhs,
        CelsiusRange const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }
};
} // namespace physics


namespace test {

/**
 * @brief Strong type wrapper for std::uint8_t
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: BoundedRangeChecked
 * - description: std::uint8_t; #<cstdint>, +, -, bounded_range<0,100>, checked
 * - default_value: ""
 */
struct BoundedRangeChecked
: private atlas::strong_type_tag
{
    std::uint8_t value;

    using atlas_value_type = std::uint8_t;
    struct atlas_bounds
    {
        using value_type = atlas_value_type;
        static constexpr value_type min() noexcept {
            return value_type(0);
        }
        static constexpr value_type max() noexcept {
            return value_type(100);
        }
        static constexpr char const * message() noexcept {
            return "value must be in [0, 100)";
        }
    };
    using atlas_constraint = atlas::constraints::bounded_range<atlas_bounds>;

    constexpr explicit BoundedRangeChecked() = default;
    constexpr BoundedRangeChecked(BoundedRangeChecked const &) = default;
    constexpr BoundedRangeChecked(BoundedRangeChecked &&) = default;
    constexpr BoundedRangeChecked & operator = (BoundedRangeChecked const &) = default;
    constexpr BoundedRangeChecked & operator = (BoundedRangeChecked &&) = default;
    constexpr ~BoundedRangeChecked() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::uint8_t, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit BoundedRangeChecked(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas_constraint::check(value)) {
            throw atlas::ConstraintError(
                "BoundedRangeChecked: " + atlas::atlas_detail::format_value(value) +
                " violates constraint: value must be in [0, 100)");
        }
    }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::uint8_t const & () const { return value; }
    constexpr explicit operator std::uint8_t & () { return value; }

    /**
     * @brief Checked addition - throws on overflow
     * @throws atlas::CheckedOverflowError if result would overflow
     * @throws atlas::CheckedUnderflowError if result would underflow (signed only)
     */
    friend BoundedRangeChecked operator + (
        BoundedRangeChecked lhs,
        BoundedRangeChecked const & rhs)
    {
        lhs.value = atlas::atlas_detail::checked_add(
            lhs.value,
            rhs.value,
            "test::BoundedRangeChecked: addition overflow",
            "test::BoundedRangeChecked: addition underflow");
        if (not atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "BoundedRangeChecked: arithmetic result violates constraint (value must be in [0, 100))");
        }
        return lhs;
    }

    /**
     * @brief Checked subtraction - throws on overflow/underflow
     * @throws atlas::CheckedOverflowError if result would overflow
     * @throws atlas::CheckedUnderflowError if result would underflow
     */
    friend BoundedRangeChecked operator - (
        BoundedRangeChecked lhs,
        BoundedRangeChecked const & rhs)
    {
        lhs.value = atlas::atlas_detail::checked_sub(
            lhs.value,
            rhs.value,
            "test::BoundedRangeChecked: subtraction overflow",
            "test::BoundedRangeChecked: subtraction underflow");
        if (not atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "BoundedRangeChecked: arithmetic result violates constraint (value must be in [0, 100))");
        }
        return lhs;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: TinyRange
 * - description: int; ==, bounded_range<42,44>
 * - default_value: ""
 */
struct TinyRange
: private atlas::strong_type_tag
{
    int value;

    using atlas_value_type = int;
    struct atlas_bounds
    {
        using value_type = atlas_value_type;
        static constexpr value_type min() noexcept {
            return value_type(42);
        }
        static constexpr value_type max() noexcept {
            return value_type(44);
        }
        static constexpr char const * message() noexcept {
            return "value must be in [42, 44)";
        }
    };
    using atlas_constraint = atlas::constraints::bounded_range<atlas_bounds>;

    constexpr explicit TinyRange() = default;
    constexpr TinyRange(TinyRange const &) = default;
    constexpr TinyRange(TinyRange &&) = default;
    constexpr TinyRange & operator = (TinyRange const &) = default;
    constexpr TinyRange & operator = (TinyRange &&) = default;
    constexpr ~TinyRange() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit TinyRange(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas_constraint::check(value)) {
            throw atlas::ConstraintError(
                "TinyRange: " + atlas::atlas_detail::format_value(value) +
                " violates constraint: value must be in [42, 44)");
        }
    }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int const & () const { return value; }
    constexpr explicit operator int & () { return value; }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        TinyRange const & lhs,
        TinyRange const & rhs)
    noexcept(noexcept(std::declval<int const&>() == std::declval<int const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: NegativeRange
 * - description: int; +, -, <=>, bounded_range<-10,10>
 * - default_value: ""
 */
struct NegativeRange
: private atlas::strong_type_tag
{
    int value;

    using atlas_value_type = int;
    struct atlas_bounds
    {
        using value_type = atlas_value_type;
        static constexpr value_type min() noexcept {
            return value_type(-10);
        }
        static constexpr value_type max() noexcept {
            return value_type(10);
        }
        static constexpr char const * message() noexcept {
            return "value must be in [-10, 10)";
        }
    };
    using atlas_constraint = atlas::constraints::bounded_range<atlas_bounds>;

    constexpr explicit NegativeRange() = default;
    constexpr NegativeRange(NegativeRange const &) = default;
    constexpr NegativeRange(NegativeRange &&) = default;
    constexpr NegativeRange & operator = (NegativeRange const &) = default;
    constexpr NegativeRange & operator = (NegativeRange &&) = default;
    constexpr ~NegativeRange() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit NegativeRange(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas_constraint::check(value)) {
            throw atlas::ConstraintError(
                "NegativeRange: " + atlas::atlas_detail::format_value(value) +
                " violates constraint: value must be in [-10, 10)");
        }
    }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int const & () const { return value; }
    constexpr explicit operator int & () { return value; }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr NegativeRange & operator += (
        NegativeRange & lhs,
        NegativeRange const & rhs)
    {
        lhs.value += rhs.value;
        if (not atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "NegativeRange: arithmetic result violates constraint (value must be in [-10, 10))");
        }
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr NegativeRange operator + (
        NegativeRange lhs,
        NegativeRange const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr NegativeRange & operator -= (
        NegativeRange & lhs,
        NegativeRange const & rhs)
    {
        lhs.value -= rhs.value;
        if (not atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "NegativeRange: arithmetic result violates constraint (value must be in [-10, 10))");
        }
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr NegativeRange operator - (
        NegativeRange lhs,
        NegativeRange const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        NegativeRange const &,
        NegativeRange const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        NegativeRange const & lhs,
        NegativeRange const & rhs)
    noexcept(noexcept(std::declval<int const &>() <
        std::declval<int const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        NegativeRange const & lhs,
        NegativeRange const & rhs)
    noexcept(noexcept(std::declval<int const &>() <=
        std::declval<int const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        NegativeRange const & lhs,
        NegativeRange const & rhs)
    noexcept(noexcept(std::declval<int const &>() >
        std::declval<int const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        NegativeRange const & lhs,
        NegativeRange const & rhs)
    noexcept(noexcept(std::declval<int const &>() >=
        std::declval<int const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        NegativeRange const &,
        NegativeRange const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        NegativeRange const & lhs,
        NegativeRange const & rhs)
    noexcept(noexcept(std::declval<int const &>() ==
        std::declval<int const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        NegativeRange const & lhs,
        NegativeRange const & rhs)
    noexcept(noexcept(std::declval<int const &>() !=
        std::declval<int const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: BoundedRangeString
 * - description: std::string; <=>, bounded_range<"A", "AAAA">
 * - default_value: ""
 */
struct BoundedRangeString
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;
    struct atlas_bounds
    {
        using value_type = atlas_value_type;
        static constexpr value_type min() noexcept {
            return value_type("A");
        }
        static constexpr value_type max() noexcept {
            return value_type("AAAA");
        }
        static constexpr char const * message() noexcept {
            return "value must be in [\"A\", \"AAAA\")";
        }
    };
    using atlas_constraint = atlas::constraints::bounded_range<atlas_bounds>;

    constexpr explicit BoundedRangeString() = default;
    constexpr BoundedRangeString(BoundedRangeString const &) = default;
    constexpr BoundedRangeString(BoundedRangeString &&) = default;
    constexpr BoundedRangeString & operator = (BoundedRangeString const &) = default;
    constexpr BoundedRangeString & operator = (BoundedRangeString &&) = default;
    constexpr ~BoundedRangeString() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit BoundedRangeString(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas_constraint::check(value)) {
            throw atlas::ConstraintError(
                "BoundedRangeString: " + atlas::atlas_detail::format_value(value) +
                " violates constraint: value must be in [\"A\", \"AAAA\")");
        }
    }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::string const & () const { return value; }
    constexpr explicit operator std::string & () { return value; }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        BoundedRangeString const &,
        BoundedRangeString const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        BoundedRangeString const & lhs,
        BoundedRangeString const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <
        std::declval<std::string const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        BoundedRangeString const & lhs,
        BoundedRangeString const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() <=
        std::declval<std::string const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        BoundedRangeString const & lhs,
        BoundedRangeString const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >
        std::declval<std::string const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        BoundedRangeString const & lhs,
        BoundedRangeString const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() >=
        std::declval<std::string const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        BoundedRangeString const &,
        BoundedRangeString const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        BoundedRangeString const & lhs,
        BoundedRangeString const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() ==
        std::declval<std::string const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        BoundedRangeString const & lhs,
        BoundedRangeString const & rhs)
    noexcept(noexcept(std::declval<std::string const &>() !=
        std::declval<std::string const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace test

#endif // FOO_BAR_7C85B91EBF83B6AB43C68D229B18A2FB5BDCDB26

