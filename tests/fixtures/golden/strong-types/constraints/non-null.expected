#ifndef FOO_BAR_8A1ADBB6F6514044D42978325A5D10B947CE93D0
#define FOO_BAR_8A1ADBB6F6514044D42978325A5D10B947CE93D0

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v0.1.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#if __has_include(<version>)
#include <version>
#endif
#include <memory>
#include <optional>
#include <sstream>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <utility>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// ======================================================================
// ATLAS STRONG TYPE BOILERPLATE
// ----------------------------------------------------------------------
//
// This section provides the infrastructure for Atlas strong types.
// It is identical across all Atlas-generated files and uses a shared
// header guard (WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90) to ensure
// the boilerplate is only included once even when multiple generated
// files are used in the same translation unit.
//
// The boilerplate is intentionally inlined to make generated code
// self-contained with zero external dependencies.
//
// Components:
// - atlas::strong_type_tag: Base class for strong types
// - atlas::value(): Universal value accessor for strong types
// - atlas_detail::*: Internal implementation utilities
//
// For projects using multiple Atlas-generated files, this boilerplate
// will only be compiled once per translation unit thanks to the shared
// header guard below.
//
// ----------------------------------------------------------------------
// DO NOT EDIT THIS SECTION
// ======================================================================

// Atlas feature detection macros
#ifndef ATLAS_NODISCARD
#if defined(__cpp_attributes) && __cpp_attributes >= 201603L
#define ATLAS_NODISCARD [[nodiscard]]
#else
#define ATLAS_NODISCARD
#endif
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif

namespace atlas {

struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <typename T, typename = void>
struct IsAtlasType
: std::false_type
{ };

template <typename T>
struct IsAtlasType<T, void_t<typename T::atlas_value_type>>
: std::true_type
{ };

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;
template <typename T, typename U = void>
using enable_if = typename std::enable_if<T::value, U>::type;

template <typename T>
using _t = typename T::type;

void atlas_value();

template <typename T>
constexpr T &
value(T & val, PriorityTag<0>)
{
    return val;
}

template <typename T, typename U = typename T::atlas_value_type>
using val_t = _t<std::conditional<std::is_const<T>::value, U const &, U &>>;

template <typename T, typename U = val_t<T>>
constexpr auto
value(T & val, PriorityTag<1>)
-> decltype(atlas::atlas_detail::value(static_cast<U>(val), value_tag{}))
{
    return atlas::atlas_detail::value(static_cast<U>(val), value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<2>)
-> decltype(atlas_value(t, atlas::value_tag{}))
{
    return atlas_value(t, atlas::value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<3>)
-> decltype(atlas_value(t))
{
    return atlas_value(t);
}

class Value
{
    template <
        typename U,
        typename T,
        typename V = _t<std::conditional<is_lref<U &&>::value, T &, T>>>
    static constexpr V rval(T && t)
    {
        return t;
    }

public:
    template <typename T>
    constexpr auto operator () (T && t) const
    -> decltype(rval<T>(atlas_detail::value(t, atlas_detail::value_tag{})))
    {
        return rval<T>(atlas_detail::value(t, atlas_detail::value_tag{}));
    }
};

void begin();
void end();

template <typename T>
constexpr auto
begin_(T && t) noexcept(noexcept(begin(std::forward<T>(t))))
-> decltype(begin(std::forward<T>(t)))
{
    return begin(std::forward<T>(t));
}

template <typename T>
constexpr auto
end_(T && t) noexcept(noexcept(end(std::forward<T>(t))))
-> decltype(end(std::forward<T>(t)))
{
    return end(std::forward<T>(t));
}

} // namespace atlas_detail

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto value = atlas_detail::Value{};
#else
template <typename T>
constexpr auto
value(T && t)
-> decltype(atlas_detail::Value{}(std::forward<T>(t)))
{
    return atlas_detail::Value{}(std::forward<T>(t));
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

#ifndef WJH_ATLAS_46CE143CD5E7495DAA505B54DBD417A2
#define WJH_ATLAS_46CE143CD5E7495DAA505B54DBD417A2

namespace atlas {
namespace atlas_detail {

struct const_
{
    template <typename T>
    static T const * _ (T * p) { return p; }
    template <typename T>
    static T const & _ (T const & p) { return p; }
};

struct mutable_
{
    template <typename T>
    static T * _ (T * p) { return p; }
    template <typename T>
    static T && _ (T && p) { return static_cast<T&&>(p); }
};

} // namespace atlas_detail
} // namespace atlas

#endif // WJH_ATLAS_46CE143CD5E7495DAA505B54DBD417A2

#ifndef WJH_ATLAS_A527B9864606413FB036AFD74BF8C8BF
#define WJH_ATLAS_A527B9864606413FB036AFD74BF8C8BF

namespace atlas {
namespace atlas_detail {

template <typename T, typename U>
auto
arrow_impl(U & u, PriorityTag<1>)
-> decltype(T::_(u.operator->()))
{
    return T::_(u.operator->());
}

template <typename T, typename U>
auto
arrow_impl(U * u, PriorityTag<1>)
-> decltype(T::_(u))
{
    return T::_(u);
}

template <typename T, typename U>
U * arrow_impl(U & u, PriorityTag<0>)
{
    return std::addressof(u);
}

} // namespace atlas_detail
} // namespace atlas

#endif // WJH_ATLAS_A527B9864606413FB036AFD74BF8C8BF

#ifndef WJH_ATLAS_173D2C4FC9AA46929AD14C8BDF75D829
#define WJH_ATLAS_173D2C4FC9AA46929AD14C8BDF75D829

#include <sstream>

namespace atlas {

/**
 * @brief Exception thrown when a constraint is violated
 */
class ConstraintError
: public std::logic_error
{
public:
    using std::logic_error::logic_error;
    virtual ~ConstraintError() noexcept = default;
};

namespace constraints {

namespace detail {

template <typename T>
std::string
format_value_impl(T const &, atlas_detail::PriorityTag<0>)
{
    return "unknown value";
}

template <typename T>
auto
format_value_impl(T const & value, atlas_detail::PriorityTag<1>)
-> decltype(std::declval<std::ostringstream &>() << value, std::string())
{
    std::ostringstream oss;
    oss << value;
    return oss.str();
}

template <typename T>
auto
format_value_impl(T const & value, atlas_detail::PriorityTag<2>)
-> decltype(std::to_string(value))
{
    return std::to_string(value);
}

template <typename T>
std::string
format_value(T const & value)
{
    return format_value_impl(value, atlas_detail::PriorityTag<2>{});
}

inline int uncaught_exceptions() noexcept
{
#if defined(__cpp_lib_uncaught_exceptions) && \
    __cpp_lib_uncaught_exceptions >= 201411L
    return std::uncaught_exceptions();
#elif defined(_MSC_VER)
    return __uncaught_exceptions();  // MSVC extension available since VS2015
#elif defined(__GLIBCXX__)
    // libstdc++ has __cxa_get_globals which tracks uncaught exceptions
    return __cxxabiv1::__cxa_get_globals()->uncaughtExceptions;
#elif defined(_LIBCPP_VERSION)
    // libc++ has std::uncaught_exceptions even in C++11 mode as extension
    return std::uncaught_exceptions();
#else
    // Fallback: use old uncaught_exception() (singular) - less safe but works
    // This will return 1 during any exception, 0 otherwise
    // Can't distinguish between multiple exceptions, but better than nothing
    return std::uncaught_exception() ? 1 : 0;
#endif
}

/**
 * @brief RAII guard for validating constraints after mutating operations
 *
 * This guard validates constraints in its destructor, ensuring that the
 * constraint is checked after the operation completes. The guard checks
 * uncaught_exceptions() to avoid throwing during stack unwinding.
 *
 * Only validates non-const operations - const operations cannot violate
 * constraints by definition.
 *
 * @tparam T The value type being constrained (may be const)
 * @tparam ConstraintT The constraint type with static check() and message()
 */
template <typename T, typename ConstraintT, typename = void>
struct ConstraintGuard
{
    using value_type = typename std::remove_const<T>::type;

    T const & value;
    char const * operation_name;
    int uncaught_at_entry;

    /**
     * @brief Construct guard, capturing current exception state
     */
    constexpr ConstraintGuard(T const & v, char const * op) noexcept
    : value(v)
    , operation_name(op)
    , uncaught_at_entry(uncaught_exceptions())
    { }

    /**
     * @brief Destructor validates constraint if no new exceptions
     *
     * Only throws if the constraint is violated AND no exceptions are
     * currently unwinding (to avoid std::terminate).
     *
     * Only validates non-const operations - uses std::is_const to check.
     */
    constexpr ~ConstraintGuard() noexcept(false)
    {
        if (uncaught_exceptions() == uncaught_at_entry) {
            if (not ConstraintT::check(value)) {
                throw atlas::ConstraintError(
                    std::string(operation_name) +
                    ": operation violates constraint (" +
                    ConstraintT::message() + ")");
            }
        }
    }
};

template <typename T, typename ConstraintT>
struct ConstraintGuard<
    T,
    ConstraintT,
    typename std::enable_if<std::is_const<T>::value>::type>
{
    constexpr ConstraintGuard(T const &, char const *) noexcept
    { }
};

} // namespace detail

template <typename ConstraintT, typename T>
auto constraint_guard(T & t, char const * op) noexcept
{
    return detail::ConstraintGuard<T, ConstraintT>(t, op);
}

template <typename T>
constexpr auto is_nil_value(typename T::atlas_value_type const * value)
-> decltype(atlas::value(T::nil_value) == *value)
{
    return atlas::value(T::nil_value) == *value;
}

template <typename T>
constexpr bool is_nil_value(void const *)
{
    return false;
}

template <typename T>
constexpr bool check(typename T::atlas_value_type const & value)
{
    return is_nil_value<T>(std::addressof(value)) ||
        T::atlas_constraint::check(value);
}

/**
 * @brief Constraint: value must be > 0
 */
template <typename T>
struct positive
{
    static constexpr bool check(T const & value)
    noexcept(noexcept(value > T{0}))
    {
        return value > T{0};
    }

    static constexpr char const * message() noexcept
    {
        return "value must be positive (> 0)";
    }
};

/**
 * @brief Constraint: value must be >= 0
 */
template <typename T>
struct non_negative
{
    static constexpr bool check(T const & value)
    noexcept(noexcept(value >= T{0}))
    {
        return value >= T{0};
    }

    static constexpr char const * message() noexcept
    {
        return "value must be non-negative (>= 0)";
    }
};

/**
 * @brief Constraint: value must be != 0
 */
template <typename T>
struct non_zero
{
    static constexpr bool check(T const & value)
    noexcept(noexcept(value != T{0}))
    {
        return value != T{0};
    }

    static constexpr char const * message() noexcept
    {
        return "value must be non-zero (!= 0)";
    }
};

/**
 * Constraint: value must be in [Min, Max]
 */
template <typename T>
struct bounded
{
    static constexpr bool check(typename T::value_type const & value)
    noexcept(noexcept(value >= T::min()) && noexcept(value <= T::max()))
    {
        return value >= T::min() && value <= T::max();
    }

    static constexpr char const * message() noexcept
    {
        return T::message();
    }
};

/**
 * Constraint: value must be in [Min, Max) (half-open range)
 */
template <typename T>
struct bounded_range
{
    static constexpr bool check(typename T::value_type const & value)
    noexcept(noexcept(value >= T::min()) && noexcept(value < T::max()))
    {
        return value >= T::min() && value < T::max();
    }

    static constexpr char const * message() noexcept
    {
        return T::message();
    }
};

/**
 * @brief Constraint: container/string must not be empty
 */
template <typename T>
struct non_empty
{
    static constexpr bool check(T const & value)
    noexcept(noexcept(value.empty()))
    {
        return not value.empty();
    }

    static constexpr char const * message() noexcept
    {
        return "value must not be empty";
    }
};

/**
 * @brief Constraint: pointer must not be null
 *
 * Works with raw pointers, smart pointers (unique_ptr, shared_ptr), and
 * std::optional by using explicit bool conversion (operator bool()).
 *
 * Note: weak_ptr requires C++23 for operator bool() support.
 */
template <typename T>
struct non_null
{
    static constexpr bool check(T const & value)
    noexcept(noexcept(static_cast<bool>(value)))
    {
        // Use explicit bool conversion - works for:
        // - Raw pointers (void*, int*, etc.)
        // - Smart pointers (unique_ptr, shared_ptr)
        // - std::optional
        // - Any type with explicit operator bool()
        return static_cast<bool>(value);
    }

    static constexpr char const * message() noexcept
    {
        return "pointer must not be null";
    }
};

} // namespace constraints
} // namespace atlas

#endif // WJH_ATLAS_173D2C4FC9AA46929AD14C8BDF75D829


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////


namespace sys {

/**
 * @brief Strong type wrapper for void*
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: sys
 * - type_name: Handle
 * - description: void*; !=, ==, non_null
 * - default_value: ""
 */
struct Handle
: private atlas::strong_type_tag
{
    void* value;

    using atlas_value_type = void*;
    using atlas_constraint = atlas::constraints::non_null<void*>;

    Handle() = delete;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<void*, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Handle(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas::constraints::check<Handle>(value)) {
            throw atlas::ConstraintError(
                "Handle: " +
                atlas::constraints::detail::format_value(value) +
                " violates constraint: pointer must not be null");
        }
    }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator void* const & () const { return value; }
    constexpr explicit operator void* & () { return value; }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        Handle const & lhs,
        Handle const & rhs)
    noexcept(noexcept(std::declval<void* const&>() != std::declval<void* const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        Handle const & lhs,
        Handle const & rhs)
    noexcept(noexcept(std::declval<void* const&>() == std::declval<void* const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace sys


namespace data {

/**
 * @brief Strong type wrapper for int*
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: data
 * - type_name: DataPointer
 * - description: int*; !=, ->, ==, non_null
 * - default_value: ""
 */
struct DataPointer
: private atlas::strong_type_tag
{
    int* value;

    using atlas_value_type = int*;
    using atlas_constraint = atlas::constraints::non_null<int*>;

    DataPointer() = delete;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int*, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit DataPointer(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas::constraints::check<DataPointer>(value)) {
            throw atlas::ConstraintError(
                "DataPointer: " +
                atlas::constraints::detail::format_value(value) +
                " violates constraint: pointer must not be null");
        }
    }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int* const & () const { return value; }
    constexpr explicit operator int* & () { return value; }

    /**
     * Arrow operator - forwards to wrapped type if it's a pointer or
     * pointer-like, otherwise returns pointer to wrapped value.
     *
     * pointer types: returns the pointer itself (built-in -> handles the rest)
     * pointer-like types (smart pointers): returns value.operator->()
     * other types: returns &value
     */
    template <typename T = atlas::atlas_detail::const_>
    constexpr auto operator -> () const
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    template <typename T = atlas::atlas_detail::mutable_>
    constexpr auto operator -> ()
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        DataPointer const & lhs,
        DataPointer const & rhs)
    noexcept(noexcept(std::declval<int* const&>() != std::declval<int* const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        DataPointer const & lhs,
        DataPointer const & rhs)
    noexcept(noexcept(std::declval<int* const&>() == std::declval<int* const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace data


namespace data {

/**
 * @brief Strong type wrapper for std::unique_ptr<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: data
 * - type_name: UniquePointer
 * - description: std::unique_ptr<int>; !=, ->, ==, no-constexpr, non_null
 * - default_value: ""
 */
struct UniquePointer
: private atlas::strong_type_tag
{
    std::unique_ptr<int> value;

    using atlas_value_type = std::unique_ptr<int>;
    using atlas_constraint = atlas::constraints::non_null<std::unique_ptr<int>>;

    UniquePointer() = delete;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::unique_ptr<int>, ArgTs...>::value,
            bool>::type = true>
    explicit UniquePointer(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas::constraints::check<UniquePointer>(value)) {
            throw atlas::ConstraintError(
                "UniquePointer: " +
                atlas::constraints::detail::format_value(value) +
                " violates constraint: pointer must not be null");
        }
    }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    explicit operator std::unique_ptr<int> const & () const { return value; }
    explicit operator std::unique_ptr<int> & () { return value; }

    /**
     * Arrow operator - forwards to wrapped type if it's a pointer or
     * pointer-like, otherwise returns pointer to wrapped value.
     *
     * pointer types: returns the pointer itself (built-in -> handles the rest)
     * pointer-like types (smart pointers): returns value.operator->()
     * other types: returns &value
     */
    template <typename T = atlas::atlas_detail::const_>
    auto operator -> () const
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    template <typename T = atlas::atlas_detail::mutable_>
    auto operator -> ()
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend bool operator != (
        UniquePointer const & lhs,
        UniquePointer const & rhs)
    noexcept(noexcept(std::declval<std::unique_ptr<int> const&>() != std::declval<std::unique_ptr<int> const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend bool operator == (
        UniquePointer const & lhs,
        UniquePointer const & rhs)
    noexcept(noexcept(std::declval<std::unique_ptr<int> const&>() == std::declval<std::unique_ptr<int> const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace data


namespace data {

/**
 * @brief Strong type wrapper for std::shared_ptr<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: data
 * - type_name: SharedPointer
 * - description: std::shared_ptr<int>; !=, ->, ==, no-constexpr, non_null
 * - default_value: ""
 */
struct SharedPointer
: private atlas::strong_type_tag
{
    std::shared_ptr<int> value;

    using atlas_value_type = std::shared_ptr<int>;
    using atlas_constraint = atlas::constraints::non_null<std::shared_ptr<int>>;

    SharedPointer() = delete;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::shared_ptr<int>, ArgTs...>::value,
            bool>::type = true>
    explicit SharedPointer(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas::constraints::check<SharedPointer>(value)) {
            throw atlas::ConstraintError(
                "SharedPointer: " +
                atlas::constraints::detail::format_value(value) +
                " violates constraint: pointer must not be null");
        }
    }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    explicit operator std::shared_ptr<int> const & () const { return value; }
    explicit operator std::shared_ptr<int> & () { return value; }

    /**
     * Arrow operator - forwards to wrapped type if it's a pointer or
     * pointer-like, otherwise returns pointer to wrapped value.
     *
     * pointer types: returns the pointer itself (built-in -> handles the rest)
     * pointer-like types (smart pointers): returns value.operator->()
     * other types: returns &value
     */
    template <typename T = atlas::atlas_detail::const_>
    auto operator -> () const
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    template <typename T = atlas::atlas_detail::mutable_>
    auto operator -> ()
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend bool operator != (
        SharedPointer const & lhs,
        SharedPointer const & rhs)
    noexcept(noexcept(std::declval<std::shared_ptr<int> const&>() != std::declval<std::shared_ptr<int> const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend bool operator == (
        SharedPointer const & lhs,
        SharedPointer const & rhs)
    noexcept(noexcept(std::declval<std::shared_ptr<int> const&>() == std::declval<std::shared_ptr<int> const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace data


namespace data {

/**
 * @brief Strong type wrapper for std::optional<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: data
 * - type_name: Optional
 * - description: std::optional<int>; !=, ->, ==, no-constexpr, non_null
 * - default_value: ""
 */
struct Optional
: private atlas::strong_type_tag
{
    std::optional<int> value;

    using atlas_value_type = std::optional<int>;
    using atlas_constraint = atlas::constraints::non_null<std::optional<int>>;

    Optional() = delete;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::optional<int>, ArgTs...>::value,
            bool>::type = true>
    explicit Optional(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    {
        if (not atlas::constraints::check<Optional>(value)) {
            throw atlas::ConstraintError(
                "Optional: " +
                atlas::constraints::detail::format_value(value) +
                " violates constraint: pointer must not be null");
        }
    }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    explicit operator std::optional<int> const & () const { return value; }
    explicit operator std::optional<int> & () { return value; }

    /**
     * Arrow operator - forwards to wrapped type if it's a pointer or
     * pointer-like, otherwise returns pointer to wrapped value.
     *
     * pointer types: returns the pointer itself (built-in -> handles the rest)
     * pointer-like types (smart pointers): returns value.operator->()
     * other types: returns &value
     */
    template <typename T = atlas::atlas_detail::const_>
    auto operator -> () const
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    template <typename T = atlas::atlas_detail::mutable_>
    auto operator -> ()
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend bool operator != (
        Optional const & lhs,
        Optional const & rhs)
    noexcept(noexcept(std::declval<std::optional<int> const&>() != std::declval<std::optional<int> const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend bool operator == (
        Optional const & lhs,
        Optional const & rhs)
    noexcept(noexcept(std::declval<std::optional<int> const&>() == std::declval<std::optional<int> const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace data

#endif // FOO_BAR_8A1ADBB6F6514044D42978325A5D10B947CE93D0

