#ifndef FOO_BAR_A3378C71D3D2AE7F2C83DB9378EF765B776F0E07
#define FOO_BAR_A3378C71D3D2AE7F2C83DB9378EF765B776F0E07

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v1.0.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#if __has_include(<version>)
#include <version>
#endif
#include <cmath>
#include <limits>
#include <stdexcept>
#include <type_traits>
#include <utility>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// ======================================================================
// ATLAS STRONG TYPE BOILERPLATE
// ----------------------------------------------------------------------
//
// This section provides the infrastructure for Atlas strong types.
// It is identical across all Atlas-generated files and uses a shared
// header guard (WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90) to ensure
// the boilerplate is only included once even when multiple generated
// files are used in the same translation unit.
//
// The boilerplate is intentionally inlined to make generated code
// self-contained with zero external dependencies.
//
// Components:
// - atlas::strong_type_tag: Base class for strong types
// - atlas::undress(): Universal value accessor for strong types
// - atlas_detail::*: Internal implementation utilities
//
// For projects using multiple Atlas-generated files, this boilerplate
// will only be compiled once per translation unit thanks to the shared
// header guard below.
//
// ----------------------------------------------------------------------
// DO NOT EDIT THIS SECTION
// ======================================================================

// Atlas feature detection macros
#ifndef ATLAS_NODISCARD
#if defined(__cpp_attributes) && __cpp_attributes >= 201603L
#define ATLAS_NODISCARD [[nodiscard]]
#else
#define ATLAS_NODISCARD
#endif
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif

#if defined(__cpp_lib_format) && __cpp_lib_format >= 202110L
#include <format>
#endif

namespace atlas {

template<typename T>
struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;

template <typename T>
using remove_cv_t = typename std::remove_cv<T>::type;
template <typename T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <typename T>
using remove_cvref_t = remove_cv_t<remove_reference_t<T>>;
template <bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;
template <bool B>
using when = enable_if_t<B, bool>;

template <typename T>
using _t = typename T::type;

template <typename T, typename = void>
struct has_atlas_value_type
: std::false_type
{ };

template <typename T>
struct has_atlas_value_type<
    T,
    enable_if_t<not std::is_same<
        typename remove_cvref_t<T>::atlas_value_type,
        void>::value>>
: std::true_type
{ };

void atlas_value_for();
struct value_by_ref
{ };
struct value_by_val
{ };

// ----------------------------------------------------------------------------
// Base case: T does not have atlas_value_type
// These are the termination cases for the recursion.
// ----------------------------------------------------------------------------
template <typename T>
constexpr T &
value_impl(T & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T const &
value_impl(T const & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T
value_impl(T & t, PriorityTag<0>, value_by_val)
{
    return std::move(t);
}
template <typename T>
constexpr T
value_impl(T const & t, PriorityTag<0>, value_by_val)
{
    return t;
}

// ----------------------------------------------------------------------------
// Enum case: T is an enum - convert to underlying type
// Always returns by value since conversion creates a distinct value.
// ----------------------------------------------------------------------------
template <typename T>
constexpr auto
value_impl(T t, PriorityTag<2>, value_by_ref)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}
template <typename T>
constexpr auto
value_impl(T t, PriorityTag<2>, value_by_val)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}

// ----------------------------------------------------------------------------
// Recursive case: T has atlas_value_for() hidden friend
// Use ADL to call atlas_value_for() and recurse.
// ----------------------------------------------------------------------------
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_ref{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_ref{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    atlas_value_for(std::move(t)),
    value_tag{},
    value_by_val{}))
{
    return value_impl(atlas_value_for(std::move(t)), value_tag{}, value_by_val{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_val{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_val{});
}

struct ToUnderlying
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_val{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_val{});
    }
};

// ----------------------------------------------------------------------------
// Unwrap: Remove exactly one layer from atlas types or enums
// Unlike undress, this does NOT recurse.
// ----------------------------------------------------------------------------

template <typename T>
constexpr auto
unwrap_impl(T & t, PriorityTag<2>)
-> decltype(atlas_value_for(t))
{
    return atlas_value_for(t);
}

template <typename T>
constexpr auto
unwrap_impl(T const & t, PriorityTag<2>)
-> decltype(atlas_value_for(t))
{
    return atlas_value_for(t);
}

template <typename T>
constexpr auto
unwrap_impl(T && t, PriorityTag<2>)
-> typename std::enable_if<
    not std::is_lvalue_reference<T>::value,
    decltype(atlas_value_for(std::move(t)))>::type
{
    return atlas_value_for(std::move(t));
}

// Enum fallback - convert to underlying type
template <typename T>
constexpr auto
unwrap_impl(T t, PriorityTag<1>)
-> typename std::enable_if<
    std::is_enum<T>::value,
    typename std::underlying_type<T>::type>::type
{
    return static_cast<typename std::underlying_type<T>::type>(t);
}

// No PriorityTag<0> - SFINAE failure for non-atlas/non-enum types

struct Unwrap
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(unwrap_impl(t, PriorityTag<2>{}))
    {
        return unwrap_impl(t, PriorityTag<2>{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(unwrap_impl(t, PriorityTag<2>{}))
    {
        return unwrap_impl(t, PriorityTag<2>{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(unwrap_impl(std::forward<T>(t), PriorityTag<2>{}))
    {
        return unwrap_impl(std::forward<T>(t), PriorityTag<2>{});
    }
};

// ----------------------------------------------------------------------------
// UndressEnum: Drill through atlas types and stop at enum
// Like undress, but stops at enum instead of converting to underlying type.
// SFINAE fails if the drill does not resolve to an enum.
// ----------------------------------------------------------------------------
using undress_enum_tag = PriorityTag<1>;

// Base case: T is an enum - return it (don't convert to underlying)
template <typename T>
constexpr auto
undress_enum_impl(T & t, PriorityTag<0>)
-> typename std::enable_if<std::is_enum<T>::value, T &>::type
{
    return t;
}

template <typename T>
constexpr auto
undress_enum_impl(T const & t, PriorityTag<0>)
-> typename std::enable_if<std::is_enum<T>::value, T const &>::type
{
    return t;
}

// Recursive case: drill through atlas types
template <typename T>
constexpr auto
undress_enum_impl(T & t, PriorityTag<1>)
-> decltype(undress_enum_impl(atlas_value_for(t), undress_enum_tag{}))
{
    return undress_enum_impl(atlas_value_for(t), undress_enum_tag{});
}

template <typename T>
constexpr auto
undress_enum_impl(T const & t, PriorityTag<1>)
-> decltype(undress_enum_impl(atlas_value_for(t), undress_enum_tag{}))
{
    return undress_enum_impl(atlas_value_for(t), undress_enum_tag{});
}

template <typename T>
constexpr auto
undress_enum_impl(T && t, PriorityTag<1>)
-> typename std::enable_if<
    not std::is_lvalue_reference<T>::value,
    decltype(undress_enum_impl(atlas_value_for(std::move(t)), undress_enum_tag{}))>::type
{
    return undress_enum_impl(atlas_value_for(std::move(t)), undress_enum_tag{});
}

struct UndressEnum
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(undress_enum_impl(t, undress_enum_tag{}))
    {
        return undress_enum_impl(t, undress_enum_tag{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(undress_enum_impl(t, undress_enum_tag{}))
    {
        return undress_enum_impl(t, undress_enum_tag{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(undress_enum_impl(std::forward<T>(t), undress_enum_tag{}))
    {
        return undress_enum_impl(std::forward<T>(t), undress_enum_tag{});
    }
};

// ----------------------------------------------------------------------------
// Type trait: holds_enum - true if undress_enum would succeed
// Uses the same mechanism as undress_enum to ensure consistency.
// ----------------------------------------------------------------------------
template <typename T, typename = void>
struct holds_enum_impl : std::false_type {};

template <typename T>
struct holds_enum_impl<
    T,
    void_t<decltype(undress_enum_impl(
        std::declval<remove_cvref_t<T> &>(),
        undress_enum_tag{}))>>
: std::true_type {};

using cast_tag = PriorityTag<1>;

// ----------------------------------------------------------------------------
// cast_impl: Drill down to find the first type castable to TargetT
// ----------------------------------------------------------------------------
template <typename TargetT, typename U>
constexpr auto
cast_impl(U && u, PriorityTag<1>)
-> decltype(static_cast<TargetT>(std::forward<U>(u)))
{
    return static_cast<TargetT>(std::forward<U>(u));
}

template <typename TargetT, typename U>
constexpr auto
cast_impl(U && u, PriorityTag<0>)
-> decltype(cast_impl<TargetT>(atlas_value_for(std::forward<U>(u)), cast_tag{}))
{
    return cast_impl<TargetT>(atlas_value_for(std::forward<U>(u)), cast_tag{});
}

template <typename TargetT>
struct CastTo
{
    template <typename U>
    constexpr auto
    operator () (U && u) const
    -> decltype(cast_impl<TargetT>(std::forward<U>(u), cast_tag{}))
    {
        return cast_impl<TargetT>(std::forward<U>(u), cast_tag{});
    }
};

void begin();
void end();

template <typename T>
constexpr auto
begin_(T && t) noexcept(noexcept(begin(std::forward<T>(t))))
-> decltype(begin(std::forward<T>(t)))
{
    return begin(std::forward<T>(t));
}

template <typename T>
constexpr auto
end_(T && t) noexcept(noexcept(end(std::forward<T>(t))))
-> decltype(end(std::forward<T>(t)))
{
    return end(std::forward<T>(t));
}

} // namespace atlas_detail

using atlas_detail::enable_if_t;
using atlas_detail::remove_cv_t;
using atlas_detail::remove_cvref_t;
using atlas_detail::when;

template <typename T>
using is_atlas_type = atlas_detail::has_atlas_value_type<T>;

template <typename T>
using holds_enum = atlas_detail::holds_enum_impl<atlas_detail::remove_cvref_t<T>>;

#if defined(__cpp_concepts) && __cpp_concepts >= 201907L
template <typename T>
concept AtlasTypeC = is_atlas_type<T>::value;

template <typename T>
concept HoldsEnumC = holds_enum<T>::value;
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto undress = atlas_detail::ToUnderlying{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto undress = atlas_detail::ToUnderlying{};
#else
// fallback: not nice, but not terrible and prevents ADL
namespace {
constexpr atlas_detail::ToUnderlying undress{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto unwrap = atlas_detail::Unwrap{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto unwrap = atlas_detail::Unwrap{};
#else
namespace {
constexpr atlas_detail::Unwrap unwrap{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto undress_enum = atlas_detail::UndressEnum{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
constexpr auto undress_enum = atlas_detail::UndressEnum{};
#else
namespace {
constexpr atlas_detail::UndressEnum undress_enum{};
}
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
template <typename TargetT>
inline constexpr atlas_detail::CastTo<TargetT> cast{};
#elif defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304L
template <typename TargetT>
constexpr atlas_detail::CastTo<TargetT> cast{};
#else
// fallback: function template (ADL still possible, but unavoidable in C++11)
template <typename TargetT, typename U>
constexpr auto
cast(U && u)
-> decltype(atlas_detail::cast_impl<TargetT>(
    std::forward<U>(u),
    atlas_detail::cast_tag{}))
{
    return atlas_detail::cast_impl<TargetT>(
        std::forward<U>(u),
        atlas_detail::cast_tag{});
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

#ifndef WJH_ATLAS_8BF8485B2F9D45ACAD473DC5B3274DDF
#define WJH_ATLAS_8BF8485B2F9D45ACAD473DC5B3274DDF

#ifdef __clang__
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wweak-vtables"
#endif

namespace atlas {

/**
 * Base class for arithmetic-related errors in checked arithmetic mode.
 *
 * This serves as the base class for all arithmetic exceptions thrown by
 * checked arithmetic operations on Atlas strong types.
 *
 * @see CheckedOverflowError
 * @see CheckedUnderflowError
 * @see CheckedDivisionByZeroError
 * @see CheckedInvalidOperationError
 */
class ArithmeticError
: public std::runtime_error
{
public:
    using std::runtime_error::runtime_error;
};

/**
 * Thrown when an arithmetic operation goes above the maximum representable
 * value.
 *
 * This exception is thrown by checked arithmetic operations when the result
 * would exceed std::numeric_limits<T>::max() for the underlying type.
 *
 * @note This is distinct from std::overflow_error, which represents
 * floating-point overflow. This exception represents integer and
 * floating-point range violations in checked arithmetic operations.
 *
 * Examples:
 * - CheckedInt8{127} + CheckedInt8{1}
 * - CheckedInt{INT_MAX} + CheckedInt{1}
 * - CheckedDouble{DBL_MAX} + CheckedDouble{DBL_MAX}
 *
 * @see CheckedUnderflowError for negative range violations
 * @see std::overflow_error (different semantics!)
 */
class CheckedOverflowError
: public ArithmeticError
{
public:
    using ArithmeticError::ArithmeticError;
};

/**
 * Thrown when an arithmetic operation goes below the minimum representable
 * value.
 *
 * This exception is thrown by checked arithmetic operations when the result
 * would be less than std::numeric_limits<T>::min() for signed types, or less
 * than zero for unsigned types during subtraction.
 *
 * @note This is NOT the same as std::underflow_error, which represents
 * floating-point gradual underflow. This represents integer and
 * floating-point range violations in checked arithmetic operations.
 *
 * Examples:
 * - CheckedInt8{-128} - CheckedInt8{1}
 * - CheckedInt{INT_MIN} - CheckedInt{1}
 * - CheckedUInt{0} - CheckedUInt{1}
 *
 * @see CheckedOverflowError for positive range violations
 * @see std::underflow_error (different semantics!)
 */
class CheckedUnderflowError
: public ArithmeticError
{
public:
    using ArithmeticError::ArithmeticError;
};

/**
 * Thrown when dividing or taking modulo by zero in checked arithmetic mode.
 *
 * This exception is thrown by checked arithmetic operations when attempting
 * to divide or compute modulo with a zero divisor, which is undefined behavior
 * in C++.
 *
 * Examples:
 * - CheckedInt{5} / CheckedInt{0}
 * - CheckedInt{10} % CheckedInt{0}
 * - CheckedDouble{3.14} / CheckedDouble{0.0}
 *
 * @see CheckedInvalidOperationError for NaN-producing operations
 */
class CheckedDivisionByZeroError
: public ArithmeticError
{
public:
    using ArithmeticError::ArithmeticError;
};

/**
 * Thrown when a floating-point operation produces an invalid result (NaN).
 *
 * This exception is thrown by checked arithmetic operations when a floating-point
 * operation would produce NaN (Not-a-Number) according to IEEE 754 semantics.
 *
 * @note This is distinct from IEEE 754 invalid operation exceptions and
 * represents NaN detection in checked arithmetic mode, not hardware exception
 * handling.
 *
 * Examples:
 * - CheckedDouble{0.0} / CheckedDouble{0.0}  // 0/0 -> NaN
 * - CheckedDouble{INFINITY} - CheckedDouble{INFINITY}  // inf-inf -> NaN
 * - CheckedDouble{-1.0}.sqrt()  // sqrt(-1) -> NaN (if sqrt method exists)
 *
 * @see CheckedDivisionByZeroError for division by zero
 * @see CheckedOverflowError for overflow to infinity
 */
class CheckedInvalidOperationError
: public ArithmeticError
{
public:
    using ArithmeticError::ArithmeticError;
};

namespace atlas_detail {

template <typename T>
using EnableFloatingPoint = typename std::enable_if<
    std::is_floating_point<T>::value,
    T>::type;

template <typename T>
using EnableSigned = typename std::enable_if<
    std::is_signed<T>::value && std::is_integral<T>::value,
    T>::type;

template <typename T>
using EnableUnsigned = typename std::enable_if<
    std::is_unsigned<T>::value && std::is_integral<T>::value,
    T>::type;

template <typename T>
EnableFloatingPoint<T>
checked_add(T a, T b, char const * overflow, char const * underflow)
{
    T result = a + b;
    if (std::isinf(result)) {
        if (result > 0) {
            throw CheckedOverflowError(overflow);
        } else {
            throw CheckedUnderflowError(underflow);
        }
    }
    if (std::isnan(result)) {
        throw CheckedInvalidOperationError("Invalid operation: NaN result");
    }
    return result;
}

template <typename T>
EnableUnsigned<T>
checked_add(T a, T b, char const * error_msg, char const * = "")
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_add_overflow(a, b, &result)) {
        throw CheckedOverflowError(error_msg);
    }
    return result;
#else
    if (a > std::numeric_limits<T>::max() - b) {
        throw CheckedOverflowError(error_msg);
    }
    return a + b;
#endif
}

template <typename T>
EnableSigned<T>
checked_add(T a, T b, char const * overflow, char const * underflow)
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_add_overflow(a, b, &result)) {
        if (b < 0) {
            throw CheckedUnderflowError(underflow);
        } else {
            throw CheckedOverflowError(overflow);
        }
    }
    return result;
#else
    if (b > 0 && a > std::numeric_limits<T>::max() - b) {
        throw CheckedOverflowError(overflow);
    } else if (b < 0 && a < std::numeric_limits<T>::lowest() - b) {
        throw CheckedUnderflowError(underflow);
    }
    return a + b;
#endif
}

template <typename T>
EnableFloatingPoint<T>
checked_sub(T a, T b, char const * overflow, char const * underflow)
{
    a -= b;
    if (std::isinf(a)) {
        if (a > 0) {
            throw CheckedOverflowError(overflow);
        } else {
            throw CheckedUnderflowError(underflow);
        }
    } else if (std::isnan(a)) {
        throw CheckedInvalidOperationError("Invalid operation: NaN result");
    }
    return a;
}

template <typename T>
EnableUnsigned<T>
checked_sub(T a, T b, char const *, char const * underflow)
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_sub_overflow(a, b, &result)) {
        throw CheckedUnderflowError(underflow);
    }
    return result;
#else
    if (a < b) {
        throw CheckedUnderflowError(underflow);
    }
    return a - b;
#endif
}

template <typename T>
EnableSigned<T>
checked_sub(T a, T b, char const * overflow, char const * underflow)
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_sub_overflow(a, b, &result)) {
        if (b > 0) {
            throw CheckedUnderflowError(underflow);
        } else {
            throw CheckedOverflowError(overflow);
        }
    }
    return result;
#else
    if (b < 0 && a > std::numeric_limits<T>::max() + b) {
        throw CheckedOverflowError(overflow);
    } else if (b > 0 && a < std::numeric_limits<T>::lowest() + b) {
        throw CheckedUnderflowError(underflow);
    }
    return a - b;
#endif
}

template <typename T>
EnableFloatingPoint<T>
checked_mul(T a, T b, char const * overflow, char const *)
{
    // Check for multiplication that would produce NaN (inf * 0 or 0 * inf)
    if ((std::isinf(a) && b == static_cast<T>(0.0)) ||
        (a == static_cast<T>(0.0) && std::isinf(b))) {
        throw CheckedInvalidOperationError(overflow);
    }

    a *= b;
    if (std::isinf(a)) {
        throw CheckedOverflowError(overflow);
    } else if (std::isnan(a)) {
        throw CheckedInvalidOperationError(overflow);
    }
    return a;
}

template <typename T>
EnableUnsigned<T>
checked_mul(T a, T b, char const * overflow, char const *)
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_mul_overflow(a, b, &result)) {
        throw CheckedOverflowError(overflow);
    }
    return result;
#else
    if (b != 0 && a > std::numeric_limits<T>::max() / b) {
        throw CheckedOverflowError(overflow);
    }
    return a * b;
#endif
}

template <typename T>
EnableSigned<T>
checked_mul(T a, T b, char const * overflow, char const * underflow)
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_mul_overflow(a, b, &result)) {
        // Determine if overflow or underflow based on operand signs
        bool same_sign = (a > 0) == (b > 0);
        if (same_sign) {
            throw CheckedOverflowError(overflow);
        } else {
            throw CheckedUnderflowError(underflow);
        }
    }
    return result;
#else
    // Handle zero cases
    if (a == 0 || b == 0) {
        return 0;
    }

    // Check for __int128 support (GCC/Clang on 64-bit platforms)
#if defined(__SIZEOF_INT128__) && (sizeof(T) < 16)
    // Use __int128 for widening (works for all types up to 64-bit)
    __int128 result = static_cast<__int128>(a) * static_cast<__int128>(b);
    if (result < static_cast<__int128>(std::numeric_limits<T>::lowest()) ||
        result > static_cast<__int128>(std::numeric_limits<T>::max()))
    {
        throw CheckedOverflowError(overflow);
    }
    return static_cast<T>(result);
#else
    // Fallback: widening for small types, division checks for long long
    if (sizeof(T) < sizeof(long long)) {
        auto result = static_cast<long long>(a) * static_cast<long long>(b);
        if (result < static_cast<long long>(std::numeric_limits<T>::lowest()) ||
            result > static_cast<long long>(std::numeric_limits<T>::max()))
        {
            throw CheckedOverflowError(overflow);
        }
        return static_cast<T>(result);
    } else {
        // For long long itself (or __int128 if that's T), use division checks
        // Check all four sign combinations
        if (a > 0) {
            if (b > 0) {
                if (a > std::numeric_limits<T>::max() / b) {
                    throw CheckedOverflowError(overflow);
                }
            } else {
                if (b < std::numeric_limits<T>::lowest() / a) {
                    throw CheckedOverflowError(overflow);
                }
            }
        } else {
            if (b > 0) {
                if (a < std::numeric_limits<T>::lowest() / b) {
                    throw CheckedOverflowError(overflow);
                }
            } else {
                if (a != 0 && b < std::numeric_limits<T>::max() / a) {
                    throw CheckedOverflowError(overflow);
                }
            }
        }
        return a * b;
    }
#endif
#endif
}

template <typename T>
EnableFloatingPoint<T>
checked_div(T a, T b, char const * div_by_zero, char const *)
{
    // Division by zero: throw exception (including 0.0/0.0 which produces NaN)
    if (b == T(0)) {
        throw CheckedDivisionByZeroError(div_by_zero);
    }
    // Check for inf / inf which produces NaN
    if (std::isinf(a) && std::isinf(b)) {
        throw CheckedInvalidOperationError(div_by_zero);
    }
    a /= b;
    if (std::isinf(a)) {
        throw CheckedOverflowError(div_by_zero);
    } else if (std::isnan(a)) {
        throw CheckedInvalidOperationError(div_by_zero);
    }
    return a;
}

template <typename T>
EnableUnsigned<T>
checked_div(T a, T b, char const * div_by_zero, char const *)
{
    if (b == T(0)) {
        throw CheckedDivisionByZeroError(div_by_zero);
    }
    return a / b;
}

template <typename T>
EnableSigned<T>
checked_div(T a, T b, char const * div_by_zero, char const * overflow)
{
    if (b == T(0)) {
        throw CheckedDivisionByZeroError(div_by_zero);
    }
    // Check for special case: INT_MIN / -1 overflows
    if (a == std::numeric_limits<T>::lowest() && b == T(-1)) {
        throw CheckedOverflowError(overflow);
    }
    return a / b;
}

template <typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
checked_mod(T a, T b, char const * div_by_zero)
{
    if (b == T(0)) {
        throw CheckedDivisionByZeroError(div_by_zero);
    }
    // INT_MIN % -1 is UB - throw for consistency with INT_MIN / -1
    if (std::is_signed<T>::value &&
        a == std::numeric_limits<T>::lowest() &&
        b == static_cast<T>(-1)) {
        throw CheckedOverflowError(div_by_zero);  // Consistent with division
    }
    return a % b;
}

// Modulo for floating-point - not provided (use static_assert in caller)

} // namespace atlas_detail
} // namespace atlas

#ifdef __clang__
    #pragma clang diagnostic pop
#endif

#endif // WJH_ATLAS_8BF8485B2F9D45ACAD473DC5B3274DDF


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////


namespace test {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: CheckedFloat
 * - description: strong double; *, +, -, /, checked
 * - default_value: ""
 */
struct CheckedFloat
: private atlas::strong_type_tag<CheckedFloat>
{
    double value;

    using atlas_value_type = double;

    constexpr explicit CheckedFloat() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<double, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit CheckedFloat(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */

    /**
     * @brief Checked multiplication - throws on overflow
     * @throws atlas::CheckedOverflowError if result would overflow
     * @throws atlas::CheckedUnderflowError if result would underflow (signed only)
     */
    friend CheckedFloat operator * (
        CheckedFloat lhs,
        CheckedFloat const & rhs)
    {
        lhs.value = atlas::atlas_detail::checked_mul(
            lhs.value,
            rhs.value,
            "test::CheckedFloat: multiplication overflow",
            "test::CheckedFloat: multiplication underflow");
        return lhs;
    }

    /**
     * @brief Checked addition - throws on overflow
     * @throws atlas::CheckedOverflowError if result would overflow
     * @throws atlas::CheckedUnderflowError if result would underflow (signed only)
     */
    friend CheckedFloat operator + (
        CheckedFloat lhs,
        CheckedFloat const & rhs)
    {
        lhs.value = atlas::atlas_detail::checked_add(
            lhs.value,
            rhs.value,
            "test::CheckedFloat: addition overflow",
            "test::CheckedFloat: addition underflow");
        return lhs;
    }

    /**
     * @brief Checked subtraction - throws on overflow/underflow
     * @throws atlas::CheckedOverflowError if result would overflow
     * @throws atlas::CheckedUnderflowError if result would underflow
     */
    friend CheckedFloat operator - (
        CheckedFloat lhs,
        CheckedFloat const & rhs)
    {
        lhs.value = atlas::atlas_detail::checked_sub(
            lhs.value,
            rhs.value,
            "test::CheckedFloat: subtraction overflow",
            "test::CheckedFloat: subtraction underflow");
        return lhs;
    }

    /**
     * @brief Checked division - throws on division by zero and overflow
     * @throws atlas::CheckedDivisionByZeroError if divisor is zero
     * @throws atlas::CheckedOverflowError if result would overflow (INT_MIN / -1)
     */
    friend CheckedFloat operator / (
        CheckedFloat lhs,
        CheckedFloat const & rhs)
    {
        lhs.value = atlas::atlas_detail::checked_div(
            lhs.value,
            rhs.value,
            "test::CheckedFloat: division by zero",
            "test::CheckedFloat: division overflow (INT_MIN / -1)");
        return lhs;
    }
    friend constexpr double const & atlas_value_for(CheckedFloat const & self) noexcept {
        return self.value;
    }
    friend constexpr double & atlas_value_for(CheckedFloat & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(CheckedFloat && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<double>::value,
            double>::type
    {
        return std::move(self.value);
    }
};
} // namespace test

#endif // FOO_BAR_A3378C71D3D2AE7F2C83DB9378EF765B776F0E07

