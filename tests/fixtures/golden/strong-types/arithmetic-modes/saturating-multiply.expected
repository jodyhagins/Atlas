#ifndef FOO_BAR_5B7A4599E35458212FFEDCA8B5AA35C84979F683
#define FOO_BAR_5B7A4599E35458212FFEDCA8B5AA35C84979F683

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v0.1.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#if __has_include(<version>)
#include <version>
#endif
#include <cmath>
#include <limits>
#include <type_traits>
#include <utility>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// ======================================================================
// ATLAS STRONG TYPE BOILERPLATE
// ----------------------------------------------------------------------
//
// This section provides the infrastructure for Atlas strong types.
// It is identical across all Atlas-generated files and uses a shared
// header guard (WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90) to ensure
// the boilerplate is only included once even when multiple generated
// files are used in the same translation unit.
//
// The boilerplate is intentionally inlined to make generated code
// self-contained with zero external dependencies.
//
// Components:
// - atlas::strong_type_tag: Base class for strong types
// - atlas::value(): Universal value accessor for strong types
// - atlas_detail::*: Internal implementation utilities
//
// For projects using multiple Atlas-generated files, this boilerplate
// will only be compiled once per translation unit thanks to the shared
// header guard below.
//
// ----------------------------------------------------------------------
// DO NOT EDIT THIS SECTION
// ======================================================================

// Atlas feature detection macros
#ifndef ATLAS_NODISCARD
#if defined(__cpp_attributes) && __cpp_attributes >= 201603L
#define ATLAS_NODISCARD [[nodiscard]]
#else
#define ATLAS_NODISCARD
#endif
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif

namespace atlas {

struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;

template <typename T>
using remove_cv_t = typename std::remove_cv<T>::type;
template <typename T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <typename T>
using remove_cvref_t = remove_cv_t<remove_reference_t<T>>;
template <bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;
template <bool B>
using when = enable_if_t<B, bool>;

template <typename T>
using _t = typename T::type;

template <typename T, typename = void>
struct has_atlas_value_type
: std::false_type
{ };

template <typename T>
struct has_atlas_value_type<
    T,
    enable_if_t<not std::is_same<
        typename remove_cvref_t<T>::atlas_value_type,
        void>::value>>
: std::true_type
{ };

void atlas_value();
struct value_by_ref
{ };
struct value_by_val
{ };

// ----------------------------------------------------------------------------
// Base case: T does not have atlas_value_type
// These are the termination cases for the recursion.
// ----------------------------------------------------------------------------
template <typename T>
constexpr T &
value_impl(T & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T const &
value_impl(T const & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T
value_impl(T & t, PriorityTag<0>, value_by_val)
{
    return std::move(t);
}
template <typename T>
constexpr T
value_impl(T const & t, PriorityTag<0>, value_by_val)
{
    return t;
}

// ----------------------------------------------------------------------------
// Recursive case: T has atlas_value_type
// Drill down one level and recurse.
// ----------------------------------------------------------------------------
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    static_cast<typename T::atlas_value_type &>(t),
    value_tag{},
    value_by_ref{}))
{
    using A = typename T::atlas_value_type;
    return value_impl(static_cast<A &>(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    static_cast<typename T::atlas_value_type const &>(t),
    value_tag{},
    value_by_ref{}))
{
    using A = typename T::atlas_value_type;
    return value_impl(static_cast<A const &>(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    static_cast<typename T::atlas_value_type &>(t),
    value_tag{},
    value_by_val{}))
{
    using A = typename T::atlas_value_type;
    return value_impl(static_cast<A &>(t), value_tag{}, value_by_val{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    static_cast<typename T::atlas_value_type const &>(t),
    value_tag{},
    value_by_val{}))
{
    using A = typename T::atlas_value_type;
    return value_impl(static_cast<A const &>(t), value_tag{}, value_by_val{});
}

struct Value
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_val{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_val{});
    }
};

void begin();
void end();

template <typename T>
constexpr auto
begin_(T && t) noexcept(noexcept(begin(std::forward<T>(t))))
-> decltype(begin(std::forward<T>(t)))
{
    return begin(std::forward<T>(t));
}

template <typename T>
constexpr auto
end_(T && t) noexcept(noexcept(end(std::forward<T>(t))))
-> decltype(end(std::forward<T>(t)))
{
    return end(std::forward<T>(t));
}

} // namespace atlas_detail

using atlas_detail::enable_if_t;
using atlas_detail::remove_cv_t;
using atlas_detail::remove_cvref_t;
using atlas_detail::when;

template <typename T>
using is_atlas_type = atlas_detail::has_atlas_value_type<T>;

#if defined(__cpp_concepts) && __cpp_concepts >= 201907L
template <typename T>
concept AtlasTypeC = is_atlas_type<T>::value;
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto value = atlas_detail::Value{};
#else
template <typename T>
constexpr auto
value(T && t)
-> decltype(atlas_detail::Value{}(std::forward<T>(t)))
{
    return atlas_detail::Value{}(std::forward<T>(t));
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

#ifndef WJH_ATLAS_64A9A0E1C2564622BBEAE087A98B793D
#define WJH_ATLAS_64A9A0E1C2564622BBEAE087A98B793D

namespace atlas {
namespace atlas_detail {

template <typename T>
using EnableFloatingPoint = typename std::enable_if<
    std::is_floating_point<T>::value,
    T>::type;

template <typename T>
using EnableSigned = typename std::enable_if<
    std::is_signed<T>::value && std::is_integral<T>::value,
    T>::type;

template <typename T>
using EnableUnsigned = typename std::enable_if<
    std::is_unsigned<T>::value && std::is_integral<T>::value,
    T>::type;

template <typename T>
EnableFloatingPoint<T>
saturating_add(T a, T b) noexcept
{
    T result = a + b;
    if (std::isinf(result) || result > std::numeric_limits<T>::max()) {
        return std::numeric_limits<T>::max();
    }
    if (result < std::numeric_limits<T>::lowest()) {
        return std::numeric_limits<T>::lowest();
    }
    // Saturate NaN to max for consistency
    if (std::isnan(result)) {
        return std::numeric_limits<T>::max();
    }
    return result;
}

template <typename T>
EnableUnsigned<T>
saturating_add(T a, T b) noexcept
{
    if (a > std::numeric_limits<T>::max() - b) {
        return std::numeric_limits<T>::max();
    }
    return a + b;
}

template <typename T>
EnableSigned<T>
saturating_add(T a, T b) noexcept
{
    if (b > 0 && a > std::numeric_limits<T>::max() - b) {
        return std::numeric_limits<T>::max();
    }
    if (b < 0 && a < std::numeric_limits<T>::lowest() - b) {
        return std::numeric_limits<T>::lowest();
    }
    return a + b;
}

template <typename T>
EnableFloatingPoint<T>
saturating_sub(T a, T b) noexcept
{
    T result = a - b;
    if (std::isinf(result) || result > std::numeric_limits<T>::max()) {
        return std::numeric_limits<T>::max();
    }
    if (result < std::numeric_limits<T>::lowest()) {
        return std::numeric_limits<T>::lowest();
    }
    // Saturate NaN to max for consistency
    if (std::isnan(result)) {
        return std::numeric_limits<T>::max();
    }
    return result;
}

template <typename T>
EnableUnsigned<T>
saturating_sub(T a, T b) noexcept
{
    if (a < b) {
        return std::numeric_limits<T>::min(); // 0 for unsigned
    }
    return a - b;
}

template <typename T>
EnableSigned<T>
saturating_sub(T a, T b) noexcept
{
    if (b < 0 && a > std::numeric_limits<T>::max() + b) {
        return std::numeric_limits<T>::max();
    }
    if (b > 0 && a < std::numeric_limits<T>::lowest() + b) {
        return std::numeric_limits<T>::lowest();
    }
    return a - b;
}

/**
 * Saturating multiplication for floating-point types
 *
 * Multiplies two floating-point values and clamps the result to the
 * representable range if overflow or underflow occurs.
 *
 * @tparam T Floating-point type (float, double, long double)
 * @param a First operand
 * @param b Second operand
 * @return Product of a and b, clamped to [lowest, max]
 */
template <typename T>
EnableFloatingPoint<T>
saturating_mul(T a, T b) noexcept
{
    T result = a * b;
    if (std::isinf(result) || result > std::numeric_limits<T>::max()) {
        return std::numeric_limits<T>::max();
    }
    if (result < std::numeric_limits<T>::lowest()) {
        return std::numeric_limits<T>::lowest();
    }
    // NaN case: saturate to max for consistency
    if (std::isnan(result)) {
        return std::numeric_limits<T>::max();
    }
    return result;
}

/**
 * Saturating multiplication for unsigned integer types
 *
 * Multiplies two unsigned integers and clamps the result to the maximum
 * representable value if overflow occurs.
 *
 * @tparam T Unsigned integer type
 * @param a First operand
 * @param b Second operand
 * @return Product of a and b, clamped to max on overflow
 */
template <typename T>
EnableUnsigned<T>
saturating_mul(T a, T b) noexcept
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_mul_overflow(a, b, &result)) {
        return std::numeric_limits<T>::max();
    }
    return result;
#else
    if (b != 0 && a > std::numeric_limits<T>::max() / b) {
        return std::numeric_limits<T>::max();
    }
    return a * b;
#endif
}

/**
 * Saturating multiplication for signed integer types
 *
 * Multiplies two signed integers and clamps the result to the representable
 * range if overflow or underflow occurs.
 *
 * @tparam T Signed integer type
 * @param a First operand
 * @param b Second operand
 * @return Product of a and b, clamped to [min, max]
 */
template <typename T>
EnableSigned<T>
saturating_mul(T a, T b) noexcept
{
#if defined(__GNUC__) || defined(__clang__)
    T result;
    if (__builtin_mul_overflow(a, b, &result)) {
        // Determine if overflow or underflow based on signs
        bool const same_sign = (a > 0) == (b > 0);
        if (same_sign) {
            return std::numeric_limits<T>::max();
        } else {
            return std::numeric_limits<T>::lowest();
        }
    }
    return result;
#else
    // Handle zero cases
    if (a == 0 || b == 0) {
        return 0;
    }

    // Check for __int128 support (GCC/Clang on 64-bit platforms)
#if defined(__SIZEOF_INT128__) && (sizeof(T) < 16)
    // Use __int128 for widening (works for all types up to 64-bit)
    __int128 result = static_cast<__int128>(a) * static_cast<__int128>(b);
    if (result < static_cast<__int128>(std::numeric_limits<T>::lowest())) {
        return std::numeric_limits<T>::lowest();
    } else if (result > static_cast<__int128>(std::numeric_limits<T>::max())) {
        return std::numeric_limits<T>::max();
    }
    return static_cast<T>(result);
#else
    // Fallback: widening for small types, division checks for long long
    if (sizeof(T) < sizeof(long long)) {
        auto result = static_cast<long long>(a) * static_cast<long long>(b);
        if (result < static_cast<long long>(std::numeric_limits<T>::lowest())) {
            return std::numeric_limits<T>::lowest();
        } else if (result > static_cast<long long>(std::numeric_limits<T>::max())) {
            return std::numeric_limits<T>::max();
        }
        return static_cast<T>(result);
    } else {
        // For long long itself (or __int128 if that's T), use division checks
        // Check all four sign combinations
        if (a > 0) {
            if (b > 0) {
                if (a > std::numeric_limits<T>::max() / b) {
                    return std::numeric_limits<T>::max();
                }
            } else {
                if (b < std::numeric_limits<T>::lowest() / a) {
                    return std::numeric_limits<T>::lowest();
                }
            }
        } else {
            if (b > 0) {
                if (a < std::numeric_limits<T>::lowest() / b) {
                    return std::numeric_limits<T>::lowest();
                }
            } else {
                if (a < std::numeric_limits<T>::max() / b) {
                    return std::numeric_limits<T>::max();
                }
            }
        }
        return a * b;
    }
#endif
#endif
}

/**
 * Saturating division for floating-point types
 *
 * Divides two floating-point values and clamps the result to the
 * representable range if overflow or underflow occurs.
 *
 * Division by zero uses sign-aware saturation (matches MATLAB's approach):
 * - positive / 0 → max (matches limit as divisor approaches 0+)
 * - negative / 0 → lowest (matches limit as divisor approaches 0+)
 * - 0 / 0 → 0 (neutral value for indeterminate form)
 * - NaN result → 0 (neutral value for invalid operations)
 *
 * @tparam T Floating-point type (float, double, long double)
 * @param a Dividend
 * @param b Divisor
 * @return Quotient of a and b, clamped to [lowest, max]
 */
template <typename T>
EnableFloatingPoint<T>
saturating_div(T a, T b) noexcept
{
    // Division by zero: sign-aware saturation
    // Use std::signbit() to handle negative zero correctly
    if (b == static_cast<T>(0.0)) {
        bool divisor_negative = std::signbit(b);
        if (a > static_cast<T>(0.0)) {
            return divisor_negative ?
                std::numeric_limits<T>::lowest() :
                std::numeric_limits<T>::max();
        } else if (a < static_cast<T>(0.0)) {
            return divisor_negative ?
                std::numeric_limits<T>::max() :
                std::numeric_limits<T>::lowest();
        } else {
            // 0.0 / 0.0 is indeterminate: return neutral value (0)
            return static_cast<T>(0.0);
        }
    }

    T result = a / b;
    if (std::isinf(result) || result > std::numeric_limits<T>::max()) {
        return std::numeric_limits<T>::max();
    }
    if (result < std::numeric_limits<T>::lowest()) {
        return std::numeric_limits<T>::lowest();
    }
    // NaN indicates invalid operation: return neutral value (0)
    if (std::isnan(result)) {
        return static_cast<T>(0.0);
    }
    return result;
}

/**
 * Saturating division for unsigned integer types
 *
 * Divides two unsigned integers. Division never overflows for unsigned types.
 *
 * @tparam T Unsigned integer type
 * @param a Dividend
 * @param b Divisor
 * @return Quotient of a and b
 */
template <typename T>
EnableUnsigned<T>
saturating_div(T a, T b) noexcept
{
    // Division by zero: saturate to max for consistency with overflow behavior
    if (b == 0) {
        if (a == 0) {
            return 0;  // Match signed/float behavior for 0/0
        }
        return std::numeric_limits<T>::max();
    }
    // Division never overflows for unsigned (when divisor is non-zero)
    return a / b;
}

/**
 * Saturating division for signed integer types
 *
 * Divides two signed integers and clamps the result to the maximum
 * representable value if overflow occurs (INT_MIN / -1).
 *
 * Division by zero uses sign-aware saturation (matches MATLAB's approach):
 * - positive / 0 → max (matches limit as divisor approaches 0+)
 * - negative / 0 → lowest (matches limit as divisor approaches 0+)
 * - 0 / 0 → 0 (neutral value for indeterminate form)
 *
 * @tparam T Signed integer type
 * @param a Dividend
 * @param b Divisor
 * @return Quotient of a and b, clamped to max on overflow
 */
template <typename T>
EnableSigned<T>
saturating_div(T a, T b) noexcept
{
    // Division by zero: sign-aware saturation
    // Matches limit behavior as divisor approaches zero
    if (b == 0) {
        if (a > 0) {
            return std::numeric_limits<T>::max();
        } else if (a < 0) {
            return std::numeric_limits<T>::lowest();
        } else {
            // 0 / 0 is indeterminate: return neutral value (0)
            return 0;
        }
    }
    // Only overflow case: INT_MIN / -1
    if (a == std::numeric_limits<T>::lowest() && b == static_cast<T>(-1)) {
        return std::numeric_limits<T>::max();
    }
    return a / b;
}

/**
 * Saturating remainder for unsigned integer types
 *
 * Computes the remainder of two unsigned integers. Remainder never overflows
 * for unsigned types, but we handle modulo by zero.
 *
 * Remainder by zero behavior:
 * - a % 0 → 0 (neutral value for undefined operation)
 *
 * @tparam T Unsigned integer type
 * @param a Dividend
 * @param b Divisor (modulus)
 * @return Remainder of a and b
 */
template <typename T>
EnableUnsigned<T>
saturating_rem(T a, T b) noexcept
{
    // Remainder by zero: return neutral value (0)
    if (b == 0) {
        return 0;
    }
    // Remainder never overflows for unsigned (when divisor is non-zero)
    return a % b;
}

/**
 * Saturating remainder for signed integer types
 *
 * Computes the remainder of two signed integers. Handles the edge case
 * of INT_MIN % -1, which on some architectures can trigger overflow
 * (though mathematically the result is 0).
 *
 * Remainder by zero behavior:
 * - a % 0 → 0 (neutral value for undefined operation)
 *
 * Special cases:
 * - INT_MIN % -1 → 0 (mathematical result, avoiding potential overflow)
 *
 * @tparam T Signed integer type
 * @param a Dividend
 * @param b Divisor (modulus)
 * @return Remainder of a and b
 */
template <typename T>
EnableSigned<T>
saturating_rem(T a, T b) noexcept
{
    // Remainder by zero: return neutral value (0)
    if (b == 0) {
        return 0;
    }
    // Edge case: INT_MIN % -1 can overflow on some architectures
    // Mathematically, the result is 0
    if (a == std::numeric_limits<T>::lowest() && b == static_cast<T>(-1)) {
        return 0;
    }
    return a % b;
}

// Modulo for floating-point - not provided (modulo is only defined for integral types)

} // namespace atlas_detail
} // namespace atlas

#endif // WJH_ATLAS_64A9A0E1C2564622BBEAE087A98B793D


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////


namespace test {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: Distance
 * - description: strong int; *, saturating
 * - default_value: ""
 */
struct Distance
: private atlas::strong_type_tag
{
    int value;

    using atlas_value_type = int;

    constexpr explicit Distance() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Distance(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int const & () const { return value; }
    constexpr explicit operator int & () { return value; }

    /**
     * @brief Saturating multiplication - clamps to type limits
     * @note noexcept - overflow/underflow clamps to limits instead of throwing
     */
    friend Distance operator * (
        Distance lhs,
        Distance const & rhs)
    noexcept
    {
        lhs.value = atlas::atlas_detail::saturating_mul(lhs.value, rhs.value);
        return lhs;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for unsigned int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: Count
 * - description: strong unsigned int; *, saturating
 * - default_value: ""
 */
struct Count
: private atlas::strong_type_tag
{
    unsigned int value;

    using atlas_value_type = unsigned int;

    constexpr explicit Count() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<unsigned int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Count(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator unsigned int const & () const { return value; }
    constexpr explicit operator unsigned int & () { return value; }

    /**
     * @brief Saturating multiplication - clamps to type limits
     * @note noexcept - overflow/underflow clamps to limits instead of throwing
     */
    friend Count operator * (
        Count lhs,
        Count const & rhs)
    noexcept
    {
        lhs.value = atlas::atlas_detail::saturating_mul(lhs.value, rhs.value);
        return lhs;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for double
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: Ratio
 * - description: strong double; *, saturating
 * - default_value: ""
 */
struct Ratio
: private atlas::strong_type_tag
{
    double value;

    using atlas_value_type = double;

    constexpr explicit Ratio() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<double, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Ratio(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator double const & () const { return value; }
    constexpr explicit operator double & () { return value; }

    /**
     * @brief Saturating multiplication - clamps to type limits
     * @note noexcept - overflow/underflow clamps to limits instead of throwing
     */
    friend Ratio operator * (
        Ratio lhs,
        Ratio const & rhs)
    noexcept
    {
        lhs.value = atlas::atlas_detail::saturating_mul(lhs.value, rhs.value);
        return lhs;
    }
};
} // namespace test

#endif // FOO_BAR_5B7A4599E35458212FFEDCA8B5AA35C84979F683

