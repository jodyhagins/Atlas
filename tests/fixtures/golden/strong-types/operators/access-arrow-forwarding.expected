#ifndef FOO_BAR_125ACA00A81B1C8FFE10C0F33630F4823D202A66
#define FOO_BAR_125ACA00A81B1C8FFE10C0F33630F4823D202A66

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v0.1.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#if __has_include(<version>)
#include <version>
#endif
#include <memory>
#include <optional>
#include <string>
#include <type_traits>
#include <utility>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// ======================================================================
// ATLAS STRONG TYPE BOILERPLATE
// ----------------------------------------------------------------------
//
// This section provides the infrastructure for Atlas strong types.
// It is identical across all Atlas-generated files and uses a shared
// header guard (WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90) to ensure
// the boilerplate is only included once even when multiple generated
// files are used in the same translation unit.
//
// The boilerplate is intentionally inlined to make generated code
// self-contained with zero external dependencies.
//
// Components:
// - atlas::strong_type_tag: Base class for strong types
// - atlas::value(): Universal value accessor for strong types
// - atlas_detail::*: Internal implementation utilities
//
// For projects using multiple Atlas-generated files, this boilerplate
// will only be compiled once per translation unit thanks to the shared
// header guard below.
//
// ----------------------------------------------------------------------
// DO NOT EDIT THIS SECTION
// ======================================================================

// Atlas feature detection macros
#ifndef ATLAS_NODISCARD
#if defined(__cpp_attributes) && __cpp_attributes >= 201603L
#define ATLAS_NODISCARD [[nodiscard]]
#else
#define ATLAS_NODISCARD
#endif
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif
#include <type_traits>
#include <utility>

namespace atlas {

struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <typename T, typename = void>
struct IsAtlasType
: std::false_type
{ };

template <typename T>
struct IsAtlasType<T, void_t<typename T::atlas_value_type>>
: std::true_type
{ };

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;
template <typename T, typename U = void>
using enable_if = typename std::enable_if<T::value, U>::type;

template <typename T>
using _t = typename T::type;

void atlas_value();

template <typename T>
constexpr T &
value(T & val, PriorityTag<0>)
{
    return val;
}

template <typename T, typename U = typename T::atlas_value_type>
using val_t = _t<std::conditional<std::is_const<T>::value, U const &, U &>>;

template <typename T, typename U = val_t<T>>
constexpr auto
value(T & val, PriorityTag<1>)
-> decltype(atlas::atlas_detail::value(static_cast<U>(val), value_tag{}))
{
    return atlas::atlas_detail::value(static_cast<U>(val), value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<2>)
-> decltype(atlas_value(t, atlas::value_tag{}))
{
    return atlas_value(t, atlas::value_tag{});
}

template <typename T>
constexpr auto
value(T const & t, PriorityTag<3>)
-> decltype(atlas_value(t))
{
    return atlas_value(t);
}

class Value
{
    template <
        typename U,
        typename T,
        typename V = _t<std::conditional<is_lref<U &&>::value, T &, T>>>
    static constexpr V rval(T && t)
    {
        return t;
    }

public:
    template <typename T>
    constexpr auto operator () (T && t) const
    -> decltype(rval<T>(atlas_detail::value(t, atlas_detail::value_tag{})))
    {
        return rval<T>(atlas_detail::value(t, atlas_detail::value_tag{}));
    }
};

void begin();
void end();

template <typename T>
constexpr auto
begin_(T && t) noexcept(noexcept(begin(std::forward<T>(t))))
-> decltype(begin(std::forward<T>(t)))
{
    return begin(std::forward<T>(t));
}

template <typename T>
constexpr auto
end_(T && t) noexcept(noexcept(end(std::forward<T>(t))))
-> decltype(end(std::forward<T>(t)))
{
    return end(std::forward<T>(t));
}
// Detects if T is a pointer or pointer-like type (has operator->)

template <typename T>
class is_arrow_operable
{
    template <typename U>
    static auto test(int)
    -> decltype(std::declval<U&>().operator->(), std::true_type{});

    template <typename U>
    static auto test(...) -> std::false_type;

public:
    static constexpr bool value = decltype(test<T>(0))::value ||
        std::is_pointer<T>::value;
};

template <typename T>
class is_arrow_operable_const
{
    template <typename U>
    static auto test(int)
    -> decltype(std::declval<U const&>().operator->(), std::true_type{});

    template <typename U>
    static auto test(...) -> std::false_type;

public:
    static constexpr bool value = decltype(test<T>(0))::value ||
        std::is_pointer<T>::value;
};

template <typename T>
using has_arrow_operator = is_arrow_operable<T>;

template <typename T>
using has_arrow_operator_const = is_arrow_operable_const<T>;

} // namespace atlas_detail

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto value = atlas_detail::Value{};
#else
template <typename T>
constexpr auto
value(T && t)
-> decltype(atlas_detail::Value{}(std::forward<T>(t)))
{
    return atlas_detail::Value{}(std::forward<T>(t));
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ArrowStringWrapper
 * - description: strong std::string; ->
 * - default_value: ""
 */
struct ArrowStringWrapper
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit ArrowStringWrapper() = default;
    constexpr ArrowStringWrapper(ArrowStringWrapper const &) = default;
    constexpr ArrowStringWrapper(ArrowStringWrapper &&) = default;
    constexpr ArrowStringWrapper & operator = (ArrowStringWrapper const &) = default;
    constexpr ArrowStringWrapper & operator = (ArrowStringWrapper &&) = default;
    constexpr ~ArrowStringWrapper() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ArrowStringWrapper(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::string const & () const { return value; }
    constexpr explicit operator std::string & () { return value; }

    /**
     * Arrow operator - forwards to wrapped type if it's a pointer or
     * pointer-like, otherwise returns pointer to wrapped value.
     *
     * pointer types: returns the pointer itself (built-in -> handles the rest)
     * pointer-like types (smart pointers): returns value.operator->()
     * other types: returns &value
     */
private:
    // forward for raw pointers (const) - return the pointer itself
    template <typename T>
    static constexpr T
    arrow_impl(T const & v, std::true_type /* is_pointer */)
    {
        return v;
    }

    // forward for pointer-like types (const) - call their operator->
    template <typename T>
    static constexpr auto
    arrow_impl(T const & v, std::false_type /* is_pointer */)
    -> decltype(v.operator->())
    {
        return v.operator->();
    }

    // forward for raw pointers (non-const) - return the pointer itself
    template <typename T>
    static constexpr T
    arrow_impl(T & v, std::true_type /* is_pointer */)
    {
        return v;
    }

    // forward for pointer-like types (non-const) - call their operator->
    template <typename T>
    static constexpr auto
    arrow_impl(T & v, std::false_type /* is_pointer */)
    -> decltype(v.operator->())
    {
        return v.operator->();
    }

public:
    // Forward to wrapped type if it's arrow-operable (const)
    template <typename T = std::string>
    constexpr auto operator -> () const
    -> typename std::enable_if<
        atlas::atlas_detail::has_arrow_operator_const<T>::value,
        decltype(arrow_impl(
            std::declval<T const&>(),
            typename std::is_pointer<T>::type{}))>::type
    {
        return arrow_impl(value, typename std::is_pointer<T>::type{});
    }

    // Forward to wrapped type if it's arrow-operable (non-const)
    template <typename T = std::string>
    constexpr auto operator -> ()
    -> typename std::enable_if<
        atlas::atlas_detail::has_arrow_operator<T>::value,
        decltype(arrow_impl(
            std::declval<T&>(),
            typename std::is_pointer<T>::type{}))>::type
    {
        return arrow_impl(value, typename std::is_pointer<T>::type{});
    }

    // Fallback: return pointer to wrapped value (const)
    template <typename T = std::string>
    constexpr auto operator -> () const noexcept
    -> typename std::enable_if<
        not atlas::atlas_detail::has_arrow_operator_const<T>::value,
        T const *>::type
    {
        return std::addressof(value);
    }

    // Fallback: return pointer to wrapped value (non-const)
    template <typename T = std::string>
    constexpr auto operator -> () noexcept
    -> typename std::enable_if<
        not atlas::atlas_detail::has_arrow_operator<T>::value,
        T *>::type
    {
        return std::addressof(value);
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for int*
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ArrowRawPointer
 * - description: strong int*; ->
 * - default_value: ""
 */
struct ArrowRawPointer
: private atlas::strong_type_tag
{
    int* value;

    using atlas_value_type = int*;

    constexpr explicit ArrowRawPointer() = default;
    constexpr ArrowRawPointer(ArrowRawPointer const &) = default;
    constexpr ArrowRawPointer(ArrowRawPointer &&) = default;
    constexpr ArrowRawPointer & operator = (ArrowRawPointer const &) = default;
    constexpr ArrowRawPointer & operator = (ArrowRawPointer &&) = default;
    constexpr ~ArrowRawPointer() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int*, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ArrowRawPointer(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int* const & () const { return value; }
    constexpr explicit operator int* & () { return value; }

    /**
     * Arrow operator - forwards to wrapped type if it's a pointer or
     * pointer-like, otherwise returns pointer to wrapped value.
     *
     * pointer types: returns the pointer itself (built-in -> handles the rest)
     * pointer-like types (smart pointers): returns value.operator->()
     * other types: returns &value
     */
private:
    // forward for raw pointers (const) - return the pointer itself
    template <typename T>
    static constexpr T
    arrow_impl(T const & v, std::true_type /* is_pointer */)
    {
        return v;
    }

    // forward for pointer-like types (const) - call their operator->
    template <typename T>
    static constexpr auto
    arrow_impl(T const & v, std::false_type /* is_pointer */)
    -> decltype(v.operator->())
    {
        return v.operator->();
    }

    // forward for raw pointers (non-const) - return the pointer itself
    template <typename T>
    static constexpr T
    arrow_impl(T & v, std::true_type /* is_pointer */)
    {
        return v;
    }

    // forward for pointer-like types (non-const) - call their operator->
    template <typename T>
    static constexpr auto
    arrow_impl(T & v, std::false_type /* is_pointer */)
    -> decltype(v.operator->())
    {
        return v.operator->();
    }

public:
    // Forward to wrapped type if it's arrow-operable (const)
    template <typename T = int*>
    constexpr auto operator -> () const
    -> typename std::enable_if<
        atlas::atlas_detail::has_arrow_operator_const<T>::value,
        decltype(arrow_impl(
            std::declval<T const&>(),
            typename std::is_pointer<T>::type{}))>::type
    {
        return arrow_impl(value, typename std::is_pointer<T>::type{});
    }

    // Forward to wrapped type if it's arrow-operable (non-const)
    template <typename T = int*>
    constexpr auto operator -> ()
    -> typename std::enable_if<
        atlas::atlas_detail::has_arrow_operator<T>::value,
        decltype(arrow_impl(
            std::declval<T&>(),
            typename std::is_pointer<T>::type{}))>::type
    {
        return arrow_impl(value, typename std::is_pointer<T>::type{});
    }

    // Fallback: return pointer to wrapped value (const)
    template <typename T = int*>
    constexpr auto operator -> () const noexcept
    -> typename std::enable_if<
        not atlas::atlas_detail::has_arrow_operator_const<T>::value,
        T const *>::type
    {
        return std::addressof(value);
    }

    // Fallback: return pointer to wrapped value (non-const)
    template <typename T = int*>
    constexpr auto operator -> () noexcept
    -> typename std::enable_if<
        not atlas::atlas_detail::has_arrow_operator<T>::value,
        T *>::type
    {
        return std::addressof(value);
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::shared_ptr<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ArrowSharedPtr
 * - description: strong std::shared_ptr<int>; ->
 * - default_value: ""
 */
struct ArrowSharedPtr
: private atlas::strong_type_tag
{
    std::shared_ptr<int> value;

    using atlas_value_type = std::shared_ptr<int>;

    constexpr explicit ArrowSharedPtr() = default;
    constexpr ArrowSharedPtr(ArrowSharedPtr const &) = default;
    constexpr ArrowSharedPtr(ArrowSharedPtr &&) = default;
    constexpr ArrowSharedPtr & operator = (ArrowSharedPtr const &) = default;
    constexpr ArrowSharedPtr & operator = (ArrowSharedPtr &&) = default;
    constexpr ~ArrowSharedPtr() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::shared_ptr<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ArrowSharedPtr(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::shared_ptr<int> const & () const { return value; }
    constexpr explicit operator std::shared_ptr<int> & () { return value; }

    /**
     * Arrow operator - forwards to wrapped type if it's a pointer or
     * pointer-like, otherwise returns pointer to wrapped value.
     *
     * pointer types: returns the pointer itself (built-in -> handles the rest)
     * pointer-like types (smart pointers): returns value.operator->()
     * other types: returns &value
     */
private:
    // forward for raw pointers (const) - return the pointer itself
    template <typename T>
    static constexpr T
    arrow_impl(T const & v, std::true_type /* is_pointer */)
    {
        return v;
    }

    // forward for pointer-like types (const) - call their operator->
    template <typename T>
    static constexpr auto
    arrow_impl(T const & v, std::false_type /* is_pointer */)
    -> decltype(v.operator->())
    {
        return v.operator->();
    }

    // forward for raw pointers (non-const) - return the pointer itself
    template <typename T>
    static constexpr T
    arrow_impl(T & v, std::true_type /* is_pointer */)
    {
        return v;
    }

    // forward for pointer-like types (non-const) - call their operator->
    template <typename T>
    static constexpr auto
    arrow_impl(T & v, std::false_type /* is_pointer */)
    -> decltype(v.operator->())
    {
        return v.operator->();
    }

public:
    // Forward to wrapped type if it's arrow-operable (const)
    template <typename T = std::shared_ptr<int>>
    constexpr auto operator -> () const
    -> typename std::enable_if<
        atlas::atlas_detail::has_arrow_operator_const<T>::value,
        decltype(arrow_impl(
            std::declval<T const&>(),
            typename std::is_pointer<T>::type{}))>::type
    {
        return arrow_impl(value, typename std::is_pointer<T>::type{});
    }

    // Forward to wrapped type if it's arrow-operable (non-const)
    template <typename T = std::shared_ptr<int>>
    constexpr auto operator -> ()
    -> typename std::enable_if<
        atlas::atlas_detail::has_arrow_operator<T>::value,
        decltype(arrow_impl(
            std::declval<T&>(),
            typename std::is_pointer<T>::type{}))>::type
    {
        return arrow_impl(value, typename std::is_pointer<T>::type{});
    }

    // Fallback: return pointer to wrapped value (const)
    template <typename T = std::shared_ptr<int>>
    constexpr auto operator -> () const noexcept
    -> typename std::enable_if<
        not atlas::atlas_detail::has_arrow_operator_const<T>::value,
        T const *>::type
    {
        return std::addressof(value);
    }

    // Fallback: return pointer to wrapped value (non-const)
    template <typename T = std::shared_ptr<int>>
    constexpr auto operator -> () noexcept
    -> typename std::enable_if<
        not atlas::atlas_detail::has_arrow_operator<T>::value,
        T *>::type
    {
        return std::addressof(value);
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::unique_ptr<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ArrowUniquePtr
 * - description: strong std::unique_ptr<int>; ->
 * - default_value: ""
 */
struct ArrowUniquePtr
: private atlas::strong_type_tag
{
    std::unique_ptr<int> value;

    using atlas_value_type = std::unique_ptr<int>;

    constexpr explicit ArrowUniquePtr() = default;
    constexpr ArrowUniquePtr(ArrowUniquePtr const &) = default;
    constexpr ArrowUniquePtr(ArrowUniquePtr &&) = default;
    constexpr ArrowUniquePtr & operator = (ArrowUniquePtr const &) = default;
    constexpr ArrowUniquePtr & operator = (ArrowUniquePtr &&) = default;
    constexpr ~ArrowUniquePtr() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::unique_ptr<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ArrowUniquePtr(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::unique_ptr<int> const & () const { return value; }
    constexpr explicit operator std::unique_ptr<int> & () { return value; }

    /**
     * Arrow operator - forwards to wrapped type if it's a pointer or
     * pointer-like, otherwise returns pointer to wrapped value.
     *
     * pointer types: returns the pointer itself (built-in -> handles the rest)
     * pointer-like types (smart pointers): returns value.operator->()
     * other types: returns &value
     */
private:
    // forward for raw pointers (const) - return the pointer itself
    template <typename T>
    static constexpr T
    arrow_impl(T const & v, std::true_type /* is_pointer */)
    {
        return v;
    }

    // forward for pointer-like types (const) - call their operator->
    template <typename T>
    static constexpr auto
    arrow_impl(T const & v, std::false_type /* is_pointer */)
    -> decltype(v.operator->())
    {
        return v.operator->();
    }

    // forward for raw pointers (non-const) - return the pointer itself
    template <typename T>
    static constexpr T
    arrow_impl(T & v, std::true_type /* is_pointer */)
    {
        return v;
    }

    // forward for pointer-like types (non-const) - call their operator->
    template <typename T>
    static constexpr auto
    arrow_impl(T & v, std::false_type /* is_pointer */)
    -> decltype(v.operator->())
    {
        return v.operator->();
    }

public:
    // Forward to wrapped type if it's arrow-operable (const)
    template <typename T = std::unique_ptr<int>>
    constexpr auto operator -> () const
    -> typename std::enable_if<
        atlas::atlas_detail::has_arrow_operator_const<T>::value,
        decltype(arrow_impl(
            std::declval<T const&>(),
            typename std::is_pointer<T>::type{}))>::type
    {
        return arrow_impl(value, typename std::is_pointer<T>::type{});
    }

    // Forward to wrapped type if it's arrow-operable (non-const)
    template <typename T = std::unique_ptr<int>>
    constexpr auto operator -> ()
    -> typename std::enable_if<
        atlas::atlas_detail::has_arrow_operator<T>::value,
        decltype(arrow_impl(
            std::declval<T&>(),
            typename std::is_pointer<T>::type{}))>::type
    {
        return arrow_impl(value, typename std::is_pointer<T>::type{});
    }

    // Fallback: return pointer to wrapped value (const)
    template <typename T = std::unique_ptr<int>>
    constexpr auto operator -> () const noexcept
    -> typename std::enable_if<
        not atlas::atlas_detail::has_arrow_operator_const<T>::value,
        T const *>::type
    {
        return std::addressof(value);
    }

    // Fallback: return pointer to wrapped value (non-const)
    template <typename T = std::unique_ptr<int>>
    constexpr auto operator -> () noexcept
    -> typename std::enable_if<
        not atlas::atlas_detail::has_arrow_operator<T>::value,
        T *>::type
    {
        return std::addressof(value);
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::optional<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ArrowOptional
 * - description: strong std::optional<int>; ->
 * - default_value: ""
 */
struct ArrowOptional
: private atlas::strong_type_tag
{
    std::optional<int> value;

    using atlas_value_type = std::optional<int>;

    constexpr explicit ArrowOptional() = default;
    constexpr ArrowOptional(ArrowOptional const &) = default;
    constexpr ArrowOptional(ArrowOptional &&) = default;
    constexpr ArrowOptional & operator = (ArrowOptional const &) = default;
    constexpr ArrowOptional & operator = (ArrowOptional &&) = default;
    constexpr ~ArrowOptional() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::optional<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ArrowOptional(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::optional<int> const & () const { return value; }
    constexpr explicit operator std::optional<int> & () { return value; }

    /**
     * Arrow operator - forwards to wrapped type if it's a pointer or
     * pointer-like, otherwise returns pointer to wrapped value.
     *
     * pointer types: returns the pointer itself (built-in -> handles the rest)
     * pointer-like types (smart pointers): returns value.operator->()
     * other types: returns &value
     */
private:
    // forward for raw pointers (const) - return the pointer itself
    template <typename T>
    static constexpr T
    arrow_impl(T const & v, std::true_type /* is_pointer */)
    {
        return v;
    }

    // forward for pointer-like types (const) - call their operator->
    template <typename T>
    static constexpr auto
    arrow_impl(T const & v, std::false_type /* is_pointer */)
    -> decltype(v.operator->())
    {
        return v.operator->();
    }

    // forward for raw pointers (non-const) - return the pointer itself
    template <typename T>
    static constexpr T
    arrow_impl(T & v, std::true_type /* is_pointer */)
    {
        return v;
    }

    // forward for pointer-like types (non-const) - call their operator->
    template <typename T>
    static constexpr auto
    arrow_impl(T & v, std::false_type /* is_pointer */)
    -> decltype(v.operator->())
    {
        return v.operator->();
    }

public:
    // Forward to wrapped type if it's arrow-operable (const)
    template <typename T = std::optional<int>>
    constexpr auto operator -> () const
    -> typename std::enable_if<
        atlas::atlas_detail::has_arrow_operator_const<T>::value,
        decltype(arrow_impl(
            std::declval<T const&>(),
            typename std::is_pointer<T>::type{}))>::type
    {
        return arrow_impl(value, typename std::is_pointer<T>::type{});
    }

    // Forward to wrapped type if it's arrow-operable (non-const)
    template <typename T = std::optional<int>>
    constexpr auto operator -> ()
    -> typename std::enable_if<
        atlas::atlas_detail::has_arrow_operator<T>::value,
        decltype(arrow_impl(
            std::declval<T&>(),
            typename std::is_pointer<T>::type{}))>::type
    {
        return arrow_impl(value, typename std::is_pointer<T>::type{});
    }

    // Fallback: return pointer to wrapped value (const)
    template <typename T = std::optional<int>>
    constexpr auto operator -> () const noexcept
    -> typename std::enable_if<
        not atlas::atlas_detail::has_arrow_operator_const<T>::value,
        T const *>::type
    {
        return std::addressof(value);
    }

    // Fallback: return pointer to wrapped value (non-const)
    template <typename T = std::optional<int>>
    constexpr auto operator -> () noexcept
    -> typename std::enable_if<
        not atlas::atlas_detail::has_arrow_operator<T>::value,
        T *>::type
    {
        return std::addressof(value);
    }
};
} // namespace test

#endif // FOO_BAR_125ACA00A81B1C8FFE10C0F33630F4823D202A66

