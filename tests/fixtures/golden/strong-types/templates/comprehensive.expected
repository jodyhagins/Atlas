#ifndef FOO_BAR_62FBD164EA4260290A1053EAD54B7A8BA652AF1E
#define FOO_BAR_62FBD164EA4260290A1053EAD54B7A8BA652AF1E

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v0.1.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#if __has_include(<version>)
#include <version>
#endif
#include <optional>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// ======================================================================
// ATLAS STRONG TYPE BOILERPLATE
// ----------------------------------------------------------------------
//
// This section provides the infrastructure for Atlas strong types.
// It is identical across all Atlas-generated files and uses a shared
// header guard (WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90) to ensure
// the boilerplate is only included once even when multiple generated
// files are used in the same translation unit.
//
// The boilerplate is intentionally inlined to make generated code
// self-contained with zero external dependencies.
//
// Components:
// - atlas::strong_type_tag: Base class for strong types
// - atlas::value(): Universal value accessor for strong types
// - atlas_detail::*: Internal implementation utilities
//
// For projects using multiple Atlas-generated files, this boilerplate
// will only be compiled once per translation unit thanks to the shared
// header guard below.
//
// ----------------------------------------------------------------------
// DO NOT EDIT THIS SECTION
// ======================================================================

// Atlas feature detection macros
#ifndef ATLAS_NODISCARD
#if defined(__cpp_attributes) && __cpp_attributes >= 201603L
#define ATLAS_NODISCARD [[nodiscard]]
#else
#define ATLAS_NODISCARD
#endif
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif

namespace atlas {

struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;

template <typename T>
using remove_cv_t = typename std::remove_cv<T>::type;
template <typename T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <typename T>
using remove_cvref_t = remove_cv_t<remove_reference_t<T>>;
template <bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;
template <bool B>
using when = enable_if_t<B, bool>;

template <typename T>
using _t = typename T::type;

template <typename T, typename = void>
struct has_atlas_value_type
: std::false_type
{ };

template <typename T>
struct has_atlas_value_type<
    T,
    enable_if_t<not std::is_same<
        typename remove_cvref_t<T>::atlas_value_type,
        void>::value>>
: std::true_type
{ };

void atlas_value();
struct value_by_ref
{ };
struct value_by_val
{ };

// ----------------------------------------------------------------------------
// Base case: T does not have atlas_value_type
// These are the termination cases for the recursion.
// ----------------------------------------------------------------------------
template <typename T>
constexpr T &
value_impl(T & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T const &
value_impl(T const & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T
value_impl(T & t, PriorityTag<0>, value_by_val)
{
    return std::move(t);
}
template <typename T>
constexpr T
value_impl(T const & t, PriorityTag<0>, value_by_val)
{
    return t;
}

// ----------------------------------------------------------------------------
// Recursive case: T has atlas_value_type
// Drill down one level and recurse.
// ----------------------------------------------------------------------------
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    static_cast<typename T::atlas_value_type &>(t),
    value_tag{},
    value_by_ref{}))
{
    using A = typename T::atlas_value_type;
    return value_impl(static_cast<A &>(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    static_cast<typename T::atlas_value_type const &>(t),
    value_tag{},
    value_by_ref{}))
{
    using A = typename T::atlas_value_type;
    return value_impl(static_cast<A const &>(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    static_cast<typename T::atlas_value_type &>(t),
    value_tag{},
    value_by_val{}))
{
    using A = typename T::atlas_value_type;
    return value_impl(static_cast<A &>(t), value_tag{}, value_by_val{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    static_cast<typename T::atlas_value_type const &>(t),
    value_tag{},
    value_by_val{}))
{
    using A = typename T::atlas_value_type;
    return value_impl(static_cast<A const &>(t), value_tag{}, value_by_val{});
}

struct Value
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_val{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_val{});
    }
};

void begin();
void end();

template <typename T>
constexpr auto
begin_(T && t) noexcept(noexcept(begin(std::forward<T>(t))))
-> decltype(begin(std::forward<T>(t)))
{
    return begin(std::forward<T>(t));
}

template <typename T>
constexpr auto
end_(T && t) noexcept(noexcept(end(std::forward<T>(t))))
-> decltype(end(std::forward<T>(t)))
{
    return end(std::forward<T>(t));
}

} // namespace atlas_detail

using atlas_detail::enable_if_t;
using atlas_detail::remove_cv_t;
using atlas_detail::remove_cvref_t;
using atlas_detail::when;

template <typename T>
using is_atlas_type = atlas_detail::has_atlas_value_type<T>;

#if defined(__cpp_concepts) && __cpp_concepts >= 201907L
template <typename T>
concept AtlasTypeC = is_atlas_type<T>::value;
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto value = atlas_detail::Value{};
#else
template <typename T>
constexpr auto
value(T && t)
-> decltype(atlas_detail::Value{}(std::forward<T>(t)))
{
    return atlas_detail::Value{}(std::forward<T>(t));
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////


namespace test {
namespace templates {

/**
 * @brief Strong type wrapper for std::optional<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test::templates
 * - type_name: Optional_int
 * - description: strong std::optional<int>; <=>, bool
 * - default_value: ""
 */
struct Optional_int
: private atlas::strong_type_tag
{
    std::optional<int> value;

    using atlas_value_type = std::optional<int>;

    constexpr explicit Optional_int() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::optional<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit Optional_int(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::optional<int> const & () const { return value; }
    constexpr explicit operator std::optional<int> & () { return value; }

    /**
     * Return the result of casting the wrapped object to bool.
     */
    constexpr explicit operator bool () const
    noexcept(noexcept(static_cast<bool>(
        std::declval<std::optional<int> const&>())))
    {
        return static_cast<bool>(value);
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        Optional_int const &,
        Optional_int const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        Optional_int const & lhs,
        Optional_int const & rhs)
    noexcept(noexcept(std::declval<std::optional<int> const &>() <
        std::declval<std::optional<int> const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        Optional_int const & lhs,
        Optional_int const & rhs)
    noexcept(noexcept(std::declval<std::optional<int> const &>() <=
        std::declval<std::optional<int> const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        Optional_int const & lhs,
        Optional_int const & rhs)
    noexcept(noexcept(std::declval<std::optional<int> const &>() >
        std::declval<std::optional<int> const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        Optional_int const & lhs,
        Optional_int const & rhs)
    noexcept(noexcept(std::declval<std::optional<int> const &>() >=
        std::declval<std::optional<int> const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        Optional_int const &,
        Optional_int const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        Optional_int const & lhs,
        Optional_int const & rhs)
    noexcept(noexcept(std::declval<std::optional<int> const &>() ==
        std::declval<std::optional<int> const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        Optional_int const & lhs,
        Optional_int const & rhs)
    noexcept(noexcept(std::declval<std::optional<int> const &>() !=
        std::declval<std::optional<int> const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace templates
} // namespace test


namespace test {
namespace templates {

/**
 * @brief Strong type wrapper for std::optional<double>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test::templates
 * - type_name: OptionalDouble
 * - description: strong std::optional<double>; <=>, bool
 * - default_value: ""
 */
struct OptionalDouble
: private atlas::strong_type_tag
{
    std::optional<double> value;

    using atlas_value_type = std::optional<double>;

    constexpr explicit OptionalDouble() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::optional<double>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit OptionalDouble(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::optional<double> const & () const { return value; }
    constexpr explicit operator std::optional<double> & () { return value; }

    /**
     * Return the result of casting the wrapped object to bool.
     */
    constexpr explicit operator bool () const
    noexcept(noexcept(static_cast<bool>(
        std::declval<std::optional<double> const&>())))
    {
        return static_cast<bool>(value);
    }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        OptionalDouble const &,
        OptionalDouble const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        OptionalDouble const & lhs,
        OptionalDouble const & rhs)
    noexcept(noexcept(std::declval<std::optional<double> const &>() <
        std::declval<std::optional<double> const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        OptionalDouble const & lhs,
        OptionalDouble const & rhs)
    noexcept(noexcept(std::declval<std::optional<double> const &>() <=
        std::declval<std::optional<double> const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        OptionalDouble const & lhs,
        OptionalDouble const & rhs)
    noexcept(noexcept(std::declval<std::optional<double> const &>() >
        std::declval<std::optional<double> const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        OptionalDouble const & lhs,
        OptionalDouble const & rhs)
    noexcept(noexcept(std::declval<std::optional<double> const &>() >=
        std::declval<std::optional<double> const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        OptionalDouble const &,
        OptionalDouble const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        OptionalDouble const & lhs,
        OptionalDouble const & rhs)
    noexcept(noexcept(std::declval<std::optional<double> const &>() ==
        std::declval<std::optional<double> const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        OptionalDouble const & lhs,
        OptionalDouble const & rhs)
    noexcept(noexcept(std::declval<std::optional<double> const &>() !=
        std::declval<std::optional<double> const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};
} // namespace templates
} // namespace test


namespace test {
namespace templates {

/**
 * @brief Strong type wrapper for std::pair<int, std::string>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test::templates
 * - type_name: IntStringPair
 * - description: strong std::pair<int, std::string>; ==
 * - default_value: ""
 */
struct IntStringPair
: private atlas::strong_type_tag
{
    std::pair<int, std::string> value;

    using atlas_value_type = std::pair<int, std::string>;

    constexpr explicit IntStringPair() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::pair<int, std::string>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit IntStringPair(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::pair<int, std::string> const & () const { return value; }
    constexpr explicit operator std::pair<int, std::string> & () { return value; }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        IntStringPair const & lhs,
        IntStringPair const & rhs)
    noexcept(noexcept(std::declval<std::pair<int, std::string> const&>() == std::declval<std::pair<int, std::string> const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace templates
} // namespace test


namespace test {
namespace templates {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test::templates
 * - type_name: BoundedInt
 * - description: strong int; <=>, ==
 * - default_value: ""
 */
struct BoundedInt
: private atlas::strong_type_tag
{
    int value;

    using atlas_value_type = int;

    static const BoundedInt max;

    static const BoundedInt min;

    constexpr explicit BoundedInt() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit BoundedInt(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int const & () const { return value; }
    constexpr explicit operator int & () { return value; }

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend constexpr auto operator <=> (
        BoundedInt const &,
        BoundedInt const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator < (
        BoundedInt const & lhs,
        BoundedInt const & rhs)
    noexcept(noexcept(std::declval<int const &>() <
        std::declval<int const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend constexpr bool operator <= (
        BoundedInt const & lhs,
        BoundedInt const & rhs)
    noexcept(noexcept(std::declval<int const &>() <=
        std::declval<int const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend constexpr bool operator > (
        BoundedInt const & lhs,
        BoundedInt const & rhs)
    noexcept(noexcept(std::declval<int const &>() >
        std::declval<int const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend constexpr bool operator >= (
        BoundedInt const & lhs,
        BoundedInt const & rhs)
    noexcept(noexcept(std::declval<int const &>() >=
        std::declval<int const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend constexpr bool operator == (
        BoundedInt const &,
        BoundedInt const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend constexpr bool operator == (
        BoundedInt const & lhs,
        BoundedInt const & rhs)
    noexcept(noexcept(std::declval<int const &>() ==
        std::declval<int const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend constexpr bool operator != (
        BoundedInt const & lhs,
        BoundedInt const & rhs)
    noexcept(noexcept(std::declval<int const &>() !=
        std::declval<int const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
};

inline constexpr test::templates::BoundedInt test::templates::BoundedInt::max = test::templates::BoundedInt(100);

inline constexpr test::templates::BoundedInt test::templates::BoundedInt::min = test::templates::BoundedInt(0);
} // namespace templates
} // namespace test


namespace test {
namespace templates {

/**
 * @brief Strong type wrapper for std::vector<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test::templates
 * - type_name: IntContainer
 * - description: strong std::vector<int>; ==
 * - default_value: ""
 */
struct IntContainer
: private atlas::strong_type_tag
{
    std::vector<int> value;

    using atlas_value_type = std::vector<int>;

    constexpr explicit IntContainer() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::vector<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit IntContainer(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::vector<int> const & () const { return value; }
    constexpr explicit operator std::vector<int> & () { return value; }

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        IntContainer const & lhs,
        IntContainer const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() == std::declval<std::vector<int> const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace templates
} // namespace test


namespace test {
namespace templates {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test::templates
 * - type_name: DefaultInt
 * - description: strong int; ==
 * - default_value: "42"
 */
struct DefaultInt
: private atlas::strong_type_tag
{
    int value = static_cast<int>(42);

    using atlas_value_type = int;

    constexpr explicit DefaultInt() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit DefaultInt(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int const & () const { return value; }
    constexpr explicit operator int & () { return value; }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        DefaultInt const & lhs,
        DefaultInt const & rhs)
    noexcept(noexcept(std::declval<int const&>() == std::declval<int const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace templates
} // namespace test


namespace custom {
namespace ns {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: custom::ns
 * - type_name: NamespacedInt
 * - description: strong int; ==
 * - default_value: ""
 */
struct NamespacedInt
: private atlas::strong_type_tag
{
    int value;

    using atlas_value_type = int;

    constexpr explicit NamespacedInt() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit NamespacedInt(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int const & () const { return value; }
    constexpr explicit operator int & () { return value; }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        NamespacedInt const & lhs,
        NamespacedInt const & rhs)
    noexcept(noexcept(std::declval<int const&>() == std::declval<int const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace ns
} // namespace custom


namespace test {
namespace templates {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: class
 * - type_namespace: test::templates
 * - type_name: ClassWrapper
 * - description: strong int; ==
 * - default_value: ""
 */
class ClassWrapper
: private atlas::strong_type_tag
{
    int value;

public:
    using atlas_value_type = int;

    constexpr explicit ClassWrapper() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ClassWrapper(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int const & () const { return value; }
    constexpr explicit operator int & () { return value; }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ClassWrapper const & lhs,
        ClassWrapper const & rhs)
    noexcept(noexcept(std::declval<int const&>() == std::declval<int const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace templates
} // namespace test


namespace test {
namespace templates {

/**
 * @brief Strong type wrapper for long
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test::templates
 * - type_name: ArithmeticLong
 * - description: strong long; *, +, -, /, ==
 * - default_value: ""
 */
struct ArithmeticLong
: private atlas::strong_type_tag
{
    long value;

    using atlas_value_type = long;

    constexpr explicit ArithmeticLong() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<long, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ArithmeticLong(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator long const & () const { return value; }
    constexpr explicit operator long & () { return value; }

    /**
     * Apply * assignment to the wrapped objects.
     */
    friend constexpr ArithmeticLong & operator *= (
        ArithmeticLong & lhs,
        ArithmeticLong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<long &>() *= std::declval<long const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value *= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator * to the wrapped object.
     */
    friend constexpr ArithmeticLong operator * (
        ArithmeticLong lhs,
        ArithmeticLong const & rhs)
    noexcept(noexcept(lhs *= rhs))
    {
        lhs *= rhs;
        return lhs;
    }

    /**
     * Apply + assignment to the wrapped objects.
     */
    friend constexpr ArithmeticLong & operator += (
        ArithmeticLong & lhs,
        ArithmeticLong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<long &>() += std::declval<long const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value += rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator + to the wrapped object.
     */
    friend constexpr ArithmeticLong operator + (
        ArithmeticLong lhs,
        ArithmeticLong const & rhs)
    noexcept(noexcept(lhs += rhs))
    {
        lhs += rhs;
        return lhs;
    }

    /**
     * Apply - assignment to the wrapped objects.
     */
    friend constexpr ArithmeticLong & operator -= (
        ArithmeticLong & lhs,
        ArithmeticLong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<long &>() -= std::declval<long const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value -= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator - to the wrapped object.
     */
    friend constexpr ArithmeticLong operator - (
        ArithmeticLong lhs,
        ArithmeticLong const & rhs)
    noexcept(noexcept(lhs -= rhs))
    {
        lhs -= rhs;
        return lhs;
    }

    /**
     * Apply / assignment to the wrapped objects.
     */
    friend constexpr ArithmeticLong & operator /= (
        ArithmeticLong & lhs,
        ArithmeticLong const & rhs)
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<long &>() /= std::declval<long const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
    {
        lhs.value /= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator / to the wrapped object.
     */
    friend constexpr ArithmeticLong operator / (
        ArithmeticLong lhs,
        ArithmeticLong const & rhs)
    noexcept(noexcept(lhs /= rhs))
    {
        lhs /= rhs;
        return lhs;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ArithmeticLong const & lhs,
        ArithmeticLong const & rhs)
    noexcept(noexcept(std::declval<long const&>() == std::declval<long const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace templates
} // namespace test


namespace test {
namespace templates {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test::templates
 * - type_name: EnhancedInt
 * - description: strong int; ==
 * - default_value: ""
 */
struct EnhancedInt
: private atlas::strong_type_tag
{
    int value;

    using atlas_value_type = int;

    static const EnhancedInt is_template;

    static const EnhancedInt special;

    constexpr explicit EnhancedInt() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit EnhancedInt(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator int const & () const { return value; }
    constexpr explicit operator int & () { return value; }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        EnhancedInt const & lhs,
        EnhancedInt const & rhs)
    noexcept(noexcept(std::declval<int const&>() == std::declval<int const&>()))
    {
        return lhs.value == rhs.value;
    }
};

inline constexpr test::templates::EnhancedInt test::templates::EnhancedInt::is_template = test::templates::EnhancedInt(1);

inline constexpr test::templates::EnhancedInt test::templates::EnhancedInt::special = test::templates::EnhancedInt(42);
} // namespace templates
} // namespace test


namespace test {
namespace templates {

/**
 * @brief Strong type wrapper for std::vector<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test::templates
 * - type_name: VectorWrapper
 * - description: strong std::vector<int>; ==
 * - default_value: ""
 */
struct VectorWrapper
: private atlas::strong_type_tag
{
    std::vector<int> value;

    using atlas_value_type = std::vector<int>;

    constexpr explicit VectorWrapper() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::vector<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit VectorWrapper(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    constexpr explicit operator std::vector<int> const & () const { return value; }
    constexpr explicit operator std::vector<int> & () { return value; }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        VectorWrapper const & lhs,
        VectorWrapper const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() == std::declval<std::vector<int> const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace templates
} // namespace test

#endif // FOO_BAR_62FBD164EA4260290A1053EAD54B7A8BA652AF1E

