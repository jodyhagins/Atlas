#ifndef TEST_C427B30F55B411D5704110B3CC06F45F58A40BC0
#define TEST_C427B30F55B411D5704110B3CC06F45F58A40BC0

// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v0.1.0
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================

#if __has_include(<version>)
#include <version>
#endif
#include <functional>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>

#ifndef WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90
#define WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90

// ======================================================================
// ATLAS STRONG TYPE BOILERPLATE
// ----------------------------------------------------------------------
//
// This section provides the infrastructure for Atlas strong types.
// It is identical across all Atlas-generated files and uses a shared
// header guard (WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90) to ensure
// the boilerplate is only included once even when multiple generated
// files are used in the same translation unit.
//
// The boilerplate is intentionally inlined to make generated code
// self-contained with zero external dependencies.
//
// Components:
// - atlas::strong_type_tag: Base class for strong types
// - atlas::to_underlying(): Universal value accessor for strong types
// - atlas_detail::*: Internal implementation utilities
//
// For projects using multiple Atlas-generated files, this boilerplate
// will only be compiled once per translation unit thanks to the shared
// header guard below.
//
// ----------------------------------------------------------------------
// DO NOT EDIT THIS SECTION
// ======================================================================

// Atlas feature detection macros
#ifndef ATLAS_NODISCARD
#if defined(__cpp_attributes) && __cpp_attributes >= 201603L
#define ATLAS_NODISCARD [[nodiscard]]
#else
#define ATLAS_NODISCARD
#endif
#endif

#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
#include <compare>
#endif

#if defined(__cpp_lib_format) && __cpp_lib_format >= 202110L
#include <format>
#endif

namespace atlas {

struct strong_type_tag
{
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    friend auto operator <=> (
        strong_type_tag const &,
        strong_type_tag const &) = default;
#endif
};

struct value_tag
{ };

namespace atlas_detail {

template <typename... Ts>
struct make_void
{
    using type = void;
};

template <typename... Ts>
using void_t = typename make_void<Ts...>::type;

template <std::size_t N>
struct PriorityTag
: PriorityTag<N - 1>
{ };

template <>
struct PriorityTag<0u>
{ };

using value_tag = PriorityTag<3>;

template <bool B>
using bool_c = std::integral_constant<bool, B>;
template <typename T>
using bool_ = bool_c<T::value>;
template <typename T>
using not_ = bool_c<not T::value>;
template <typename T, typename U>
using and_ = bool_c<T::value && U::value>;
template <typename T>
using is_lref = std::is_lvalue_reference<T>;

template <typename T>
using remove_cv_t = typename std::remove_cv<T>::type;
template <typename T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <typename T>
using remove_cvref_t = remove_cv_t<remove_reference_t<T>>;
template <bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;
template <bool B>
using when = enable_if_t<B, bool>;

template <typename T>
using _t = typename T::type;

template <typename T, typename = void>
struct has_atlas_value_type
: std::false_type
{ };

template <typename T>
struct has_atlas_value_type<
    T,
    enable_if_t<not std::is_same<
        typename remove_cvref_t<T>::atlas_value_type,
        void>::value>>
: std::true_type
{ };

void atlas_value_for();
struct value_by_ref
{ };
struct value_by_val
{ };

// ----------------------------------------------------------------------------
// Base case: T does not have atlas_value_type
// These are the termination cases for the recursion.
// ----------------------------------------------------------------------------
template <typename T>
constexpr T &
value_impl(T & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T const &
value_impl(T const & t, PriorityTag<0>, value_by_ref)
{
    return t;
}
template <typename T>
constexpr T
value_impl(T & t, PriorityTag<0>, value_by_val)
{
    return std::move(t);
}
template <typename T>
constexpr T
value_impl(T const & t, PriorityTag<0>, value_by_val)
{
    return t;
}

// ----------------------------------------------------------------------------
// Recursive case: T has atlas_value_for() hidden friend
// Use ADL to call atlas_value_for() and recurse.
// ----------------------------------------------------------------------------
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_ref{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_ref)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_ref{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_ref{});
}
template <typename T>
constexpr auto
value_impl(T & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    atlas_value_for(std::move(t)),
    value_tag{},
    value_by_val{}))
{
    return value_impl(atlas_value_for(std::move(t)), value_tag{}, value_by_val{});
}
template <typename T>
constexpr auto
value_impl(T const & t, PriorityTag<1>, value_by_val)
-> decltype(value_impl(
    atlas_value_for(t),
    value_tag{},
    value_by_val{}))
{
    return value_impl(atlas_value_for(t), value_tag{}, value_by_val{});
}

struct ToUnderlying
{
    template <typename T>
    constexpr auto
    operator () (T & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <typename T>
    constexpr auto
    operator () (T const & t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_ref{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_ref{});
    }

    template <
        typename T,
        when<not std::is_lvalue_reference<T>::value> = true>
    constexpr auto
    operator () (T && t) const
    -> decltype(atlas_detail::value_impl(t, value_tag{}, value_by_val{}))
    {
        return atlas_detail::value_impl(t, value_tag{}, value_by_val{});
    }
};

void begin();
void end();

template <typename T>
constexpr auto
begin_(T && t) noexcept(noexcept(begin(std::forward<T>(t))))
-> decltype(begin(std::forward<T>(t)))
{
    return begin(std::forward<T>(t));
}

template <typename T>
constexpr auto
end_(T && t) noexcept(noexcept(end(std::forward<T>(t))))
-> decltype(end(std::forward<T>(t)))
{
    return end(std::forward<T>(t));
}

// ----------------------------------------------------------------------------
// Detection traits for drilling operations
// ----------------------------------------------------------------------------

// is_hashable<T>: detects if std::hash<T> is valid
template <typename T, typename = void>
struct is_hashable
: std::false_type
{ };

template <typename T>
struct is_hashable<
    T,
    void_t<decltype(std::hash<T>{}(std::declval<T const &>()))>>
: std::true_type
{ };

// is_ostreamable<T>: detects if T can be written to std::ostream
template <typename T, typename = void>
struct is_ostreamable
: std::false_type
{ };

template <typename T>
struct is_ostreamable<
    T,
    void_t<decltype(std::declval<std::ostream &>() << std::declval<T const &>())>>
: std::true_type
{ };

// is_istreamable<T>: detects if T can be read from std::istream
template <typename T, typename = void>
struct is_istreamable
: std::false_type
{ };

template <typename T>
struct is_istreamable<
    T,
    void_t<decltype(std::declval<std::istream &>() >> std::declval<T &>())>>
: std::true_type
{ };

// ----------------------------------------------------------------------------
// Drilling functions for hash
// Drill down to find the first hashable type, with enum fallback
// ----------------------------------------------------------------------------

// Base case: T is directly hashable
template <typename T>
auto hash_drill(T const & t, PriorityTag<2>)
-> typename std::enable_if<
    is_hashable<T>::value,
    std::size_t>::type
{
    return std::hash<T>{}(t);
}

// Enum fallback: T is an enum without std::hash, use underlying type
template <typename T>
auto hash_drill(T const & t, PriorityTag<1>)
-> typename std::enable_if<
    std::is_enum<T>::value &&
    not is_hashable<T>::value,
    std::size_t>::type
{
    return std::hash<typename std::underlying_type<T>::type>{}(
        static_cast<typename std::underlying_type<T>::type>(t));
}

// Recursive case: T is an atlas type, drill down
template <typename T>
auto hash_drill(T const & t, PriorityTag<0>)
-> decltype(hash_drill(atlas_value_for(t), PriorityTag<2>{}))
{
    return hash_drill(atlas_value_for(t), PriorityTag<2>{});
}

// ----------------------------------------------------------------------------
// Drilling functions for ostream
// ----------------------------------------------------------------------------

// Base case: T is directly ostreamable
template <typename T>
auto ostream_drill(std::ostream & strm, T const & t, PriorityTag<2>)
-> typename std::enable_if<
    is_ostreamable<T>::value,
    std::ostream &>::type
{
    return strm << t;
}

// Enum fallback: T is an enum without operator<<, use underlying type
template <typename T>
auto ostream_drill(std::ostream & strm, T const & t, PriorityTag<1>)
-> typename std::enable_if<
    std::is_enum<T>::value &&
    not is_ostreamable<T>::value,
    std::ostream &>::type
{
    return strm << static_cast<typename std::underlying_type<T>::type>(t);
}

// Recursive case: T is an atlas type, drill down
template <typename T>
auto ostream_drill(std::ostream & strm, T const & t, PriorityTag<0>)
-> decltype(ostream_drill(strm, atlas_value_for(t), PriorityTag<2>{}))
{
    return ostream_drill(strm, atlas_value_for(t), PriorityTag<2>{});
}

// ----------------------------------------------------------------------------
// Drilling functions for istream
// ----------------------------------------------------------------------------

// Base case: T is directly istreamable
template <typename T>
auto istream_drill(std::istream & strm, T & t, PriorityTag<2>)
-> typename std::enable_if<
    is_istreamable<T>::value,
    std::istream &>::type
{
    return strm >> t;
}

// Enum fallback: T is an enum without operator>>, read as underlying type
template <typename T>
auto istream_drill(std::istream & strm, T & t, PriorityTag<1>)
-> typename std::enable_if<
    std::is_enum<T>::value &&
    not is_istreamable<T>::value,
    std::istream &>::type
{
    typename std::underlying_type<T>::type tmp;
    strm >> tmp;
    t = static_cast<T>(tmp);
    return strm;
}

// Recursive case: T is an atlas type, drill down
template <typename T>
auto istream_drill(std::istream & strm, T & t, PriorityTag<0>)
-> decltype(istream_drill(strm, atlas_value_for(t), PriorityTag<2>{}))
{
    return istream_drill(strm, atlas_value_for(t), PriorityTag<2>{});
}

// ----------------------------------------------------------------------------
// Drilling functions for std::formatter (C++20+)
// Uses C++20 concepts and if constexpr for cleaner implementation
// ----------------------------------------------------------------------------
#if defined(__cpp_lib_format) && __cpp_lib_format >= 202110L

// Concept: T is formattable via std::formatter<T>
template <typename T>
concept formattable = requires(
    std::formatter<T> f,
    T const & t,
    std::format_parse_context & parse_ctx,
    std::format_context & fmt_ctx)
{
    f.parse(parse_ctx);
    f.format(t, fmt_ctx);
};

// Drill to find a formattable type, returning a reference or converted value
template <typename T>
constexpr decltype(auto) format_value_drill(T const & t)
{
    if constexpr (formattable<T>) {
        // Base case: T is directly formattable - return reference
        return (t);
    } else if constexpr (std::is_enum_v<T>) {
        // Enum fallback: convert to underlying type
        return static_cast<std::underlying_type_t<T>>(t);
    } else if constexpr (has_atlas_value_type<T>::value) {
        // Recursive case: drill through atlas type
        return format_value_drill(atlas_value_for(t));
    } else {
        static_assert(formattable<T>, "Type is not formattable after drilling");
    }
}

// Type trait for the drilled type
template <typename T>
using format_drilled_type_t =
    std::remove_cvref_t<decltype(format_value_drill(std::declval<T const &>()))>;

#endif // __cpp_lib_format

} // namespace atlas_detail

using atlas_detail::enable_if_t;
using atlas_detail::remove_cv_t;
using atlas_detail::remove_cvref_t;
using atlas_detail::when;

template <typename T>
using is_atlas_type = atlas_detail::has_atlas_value_type<T>;

#if defined(__cpp_concepts) && __cpp_concepts >= 201907L
template <typename T>
concept AtlasTypeC = is_atlas_type<T>::value;
#endif

#if defined(__cpp_inline_variables) && __cpp_inline_variables >= 201606L
inline constexpr auto to_underlying = atlas_detail::ToUnderlying{};
#else
template <typename T>
constexpr auto
to_underlying(T && t)
-> decltype(atlas_detail::ToUnderlying{}(std::forward<T>(t)))
{
    return atlas_detail::ToUnderlying{}(std::forward<T>(t));
}
#endif

} // namespace atlas

#endif // WJH_ATLAS_50E620B544874CB8BE4412EE6773BF90


//////////////////////////////////////////////////////////////////////
///
/// These are the droids you are looking for!
///
//////////////////////////////////////////////////////////////////////


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: StringWrapper
 * - description: std::string; forward=size,empty,clear; hash
 * - default_value: ""
 */
struct StringWrapper
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit StringWrapper() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit StringWrapper(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(StringWrapper const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(StringWrapper & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(StringWrapper && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward clear to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * clear member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto clear(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.clear(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.clear(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.clear(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto clear(Args&&... args) const &
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) const &&
    noexcept(noexcept(std::move(value).clear(std::forward<Args>(args)...)))
    -> decltype(std::move(value).clear(std::forward<Args>(args)...))
    {
        return std::move(value).clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) &
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) &&
    noexcept(noexcept(std::move(value).clear(std::forward<Args>(args)...)))
    -> decltype(std::move(value).clear(std::forward<Args>(args)...))
    {
        return std::move(value).clear(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif
};
} // namespace test


/**
 * @brief std::hash specialization for test::StringWrapper
 *
 * Drills down to find the first hashable type in the wrapping chain.
 * Falls back to underlying type for enums without std::hash.
 */
template <>
struct std::hash<test::StringWrapper>
{
    ATLAS_NODISCARD
    auto operator()(test::StringWrapper const & t) const
    noexcept(noexcept(atlas::atlas_detail::hash_drill(
        atlas_value_for(t), atlas::atlas_detail::PriorityTag<2>{})))
    -> decltype(atlas::atlas_detail::hash_drill(
        atlas_value_for(t), atlas::atlas_detail::PriorityTag<2>{}))
    {
        return atlas::atlas_detail::hash_drill(
            atlas_value_for(t), atlas::atlas_detail::PriorityTag<2>{});
    }
};

namespace test {

/**
 * @brief Strong type wrapper for std::vector<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: VectorWrapper
 * - description: std::vector<int>; forward=size,empty,begin,end; !=, ==, iterable
 * - default_value: ""
 */
struct VectorWrapper
: private atlas::strong_type_tag
{
    std::vector<int> value;

    using atlas_value_type = std::vector<int>;

    constexpr explicit VectorWrapper() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::vector<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit VectorWrapper(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::vector<int> const & atlas_value_for(VectorWrapper const & self) noexcept {
        return self.value;
    }
    friend constexpr std::vector<int> & atlas_value_for(VectorWrapper & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(VectorWrapper && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::vector<int>>::value,
            std::vector<int>>::type
    {
        return std::move(self.value);
    }

    /**
     * Iterator type aliases for container-like interface.
     */
    using iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<std::vector<int>&>()));
    using const_iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<std::vector<int> const&>()));
    using value_type = typename std::remove_reference<decltype(
        *atlas::atlas_detail::begin_(
            std::declval<std::vector<int>&>()))>::type;

    /**
     * Member functions for iterator access.
     * Enables both explicit calls (e.g., s.begin()) and range-based for loops.
     * Uses ADL-enabled helpers that work in decltype/noexcept contexts.
     */
    constexpr auto begin()
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    constexpr auto end()
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    constexpr auto begin() const
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    constexpr auto end() const
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    /**
     * @brief Forward begin to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * begin member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto begin(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.begin(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.begin(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.begin(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto begin(Args&&... args) const &
    noexcept(noexcept(value.begin(std::forward<Args>(args)...)))
    -> decltype(value.begin(std::forward<Args>(args)...))
    {
        return value.begin(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto begin(Args&&... args) const &&
    noexcept(noexcept(std::move(value).begin(std::forward<Args>(args)...)))
    -> decltype(std::move(value).begin(std::forward<Args>(args)...))
    {
        return std::move(value).begin(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto begin(Args&&... args) &
    noexcept(noexcept(value.begin(std::forward<Args>(args)...)))
    -> decltype(value.begin(std::forward<Args>(args)...))
    {
        return value.begin(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto begin(Args&&... args) &&
    noexcept(noexcept(std::move(value).begin(std::forward<Args>(args)...)))
    -> decltype(std::move(value).begin(std::forward<Args>(args)...))
    {
        return std::move(value).begin(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward end to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * end member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto end(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.end(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.end(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.end(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto end(Args&&... args) const &
    noexcept(noexcept(value.end(std::forward<Args>(args)...)))
    -> decltype(value.end(std::forward<Args>(args)...))
    {
        return value.end(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto end(Args&&... args) const &&
    noexcept(noexcept(std::move(value).end(std::forward<Args>(args)...)))
    -> decltype(std::move(value).end(std::forward<Args>(args)...))
    {
        return std::move(value).end(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto end(Args&&... args) &
    noexcept(noexcept(value.end(std::forward<Args>(args)...)))
    -> decltype(value.end(std::forward<Args>(args)...))
    {
        return value.end(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto end(Args&&... args) &&
    noexcept(noexcept(std::move(value).end(std::forward<Args>(args)...)))
    -> decltype(std::move(value).end(std::forward<Args>(args)...))
    {
        return std::move(value).end(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        VectorWrapper const & lhs,
        VectorWrapper const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() != std::declval<std::vector<int> const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        VectorWrapper const & lhs,
        VectorWrapper const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() == std::declval<std::vector<int> const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: StringWithExtra
 * - description: std::string; forward=length,size,empty,clear; ==
 * - default_value: ""
 */
struct StringWithExtra
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit StringWithExtra() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit StringWithExtra(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(StringWithExtra const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(StringWithExtra & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(StringWithExtra && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward clear to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * clear member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto clear(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.clear(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.clear(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.clear(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto clear(Args&&... args) const &
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) const &&
    noexcept(noexcept(std::move(value).clear(std::forward<Args>(args)...)))
    -> decltype(std::move(value).clear(std::forward<Args>(args)...))
    {
        return std::move(value).clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) &
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) &&
    noexcept(noexcept(std::move(value).clear(std::forward<Args>(args)...)))
    -> decltype(std::move(value).clear(std::forward<Args>(args)...))
    {
        return std::move(value).clear(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward length to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * length member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto length(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.length(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.length(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.length(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto length(Args&&... args) const &
    noexcept(noexcept(value.length(std::forward<Args>(args)...)))
    -> decltype(value.length(std::forward<Args>(args)...))
    {
        return value.length(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) const &&
    noexcept(noexcept(std::move(value).length(std::forward<Args>(args)...)))
    -> decltype(std::move(value).length(std::forward<Args>(args)...))
    {
        return std::move(value).length(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &
    noexcept(noexcept(value.length(std::forward<Args>(args)...)))
    -> decltype(value.length(std::forward<Args>(args)...))
    {
        return value.length(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &&
    noexcept(noexcept(std::move(value).length(std::forward<Args>(args)...)))
    -> decltype(std::move(value).length(std::forward<Args>(args)...))
    {
        return std::move(value).length(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        StringWithExtra const & lhs,
        StringWithExtra const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::vector<int>
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ContainerWithComparison
 * - description: std::vector<int>; forward=size,empty,begin,end; !=, <, <=, ==, >, >=, iterable
 * - default_value: ""
 */
struct ContainerWithComparison
: private atlas::strong_type_tag
{
    std::vector<int> value;

    using atlas_value_type = std::vector<int>;

    constexpr explicit ContainerWithComparison() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::vector<int>, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ContainerWithComparison(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::vector<int> const & atlas_value_for(ContainerWithComparison const & self) noexcept {
        return self.value;
    }
    friend constexpr std::vector<int> & atlas_value_for(ContainerWithComparison & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(ContainerWithComparison && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::vector<int>>::value,
            std::vector<int>>::type
    {
        return std::move(self.value);
    }

    /**
     * Iterator type aliases for container-like interface.
     */
    using iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<std::vector<int>&>()));
    using const_iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<std::vector<int> const&>()));
    using value_type = typename std::remove_reference<decltype(
        *atlas::atlas_detail::begin_(
            std::declval<std::vector<int>&>()))>::type;

    /**
     * Member functions for iterator access.
     * Enables both explicit calls (e.g., s.begin()) and range-based for loops.
     * Uses ADL-enabled helpers that work in decltype/noexcept contexts.
     */
    constexpr auto begin()
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    constexpr auto end()
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    constexpr auto begin() const
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    constexpr auto end() const
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    /**
     * @brief Forward begin to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * begin member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto begin(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.begin(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.begin(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.begin(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto begin(Args&&... args) const &
    noexcept(noexcept(value.begin(std::forward<Args>(args)...)))
    -> decltype(value.begin(std::forward<Args>(args)...))
    {
        return value.begin(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto begin(Args&&... args) const &&
    noexcept(noexcept(std::move(value).begin(std::forward<Args>(args)...)))
    -> decltype(std::move(value).begin(std::forward<Args>(args)...))
    {
        return std::move(value).begin(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto begin(Args&&... args) &
    noexcept(noexcept(value.begin(std::forward<Args>(args)...)))
    -> decltype(value.begin(std::forward<Args>(args)...))
    {
        return value.begin(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto begin(Args&&... args) &&
    noexcept(noexcept(std::move(value).begin(std::forward<Args>(args)...)))
    -> decltype(std::move(value).begin(std::forward<Args>(args)...))
    {
        return std::move(value).begin(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward end to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * end member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto end(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.end(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.end(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.end(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto end(Args&&... args) const &
    noexcept(noexcept(value.end(std::forward<Args>(args)...)))
    -> decltype(value.end(std::forward<Args>(args)...))
    {
        return value.end(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto end(Args&&... args) const &&
    noexcept(noexcept(std::move(value).end(std::forward<Args>(args)...)))
    -> decltype(std::move(value).end(std::forward<Args>(args)...))
    {
        return std::move(value).end(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto end(Args&&... args) &
    noexcept(noexcept(value.end(std::forward<Args>(args)...)))
    -> decltype(value.end(std::forward<Args>(args)...))
    {
        return value.end(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto end(Args&&... args) &&
    noexcept(noexcept(std::move(value).end(std::forward<Args>(args)...)))
    -> decltype(std::move(value).end(std::forward<Args>(args)...))
    {
        return std::move(value).end(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        ContainerWithComparison const & lhs,
        ContainerWithComparison const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() != std::declval<std::vector<int> const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value < @p rhs.value?
     */
    friend constexpr bool operator < (
        ContainerWithComparison const & lhs,
        ContainerWithComparison const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() < std::declval<std::vector<int> const&>()))
    {
        return lhs.value < rhs.value;
    }

    /**
     * Is @p lhs.value <= @p rhs.value?
     */
    friend constexpr bool operator <= (
        ContainerWithComparison const & lhs,
        ContainerWithComparison const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() <= std::declval<std::vector<int> const&>()))
    {
        return lhs.value <= rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ContainerWithComparison const & lhs,
        ContainerWithComparison const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() == std::declval<std::vector<int> const&>()))
    {
        return lhs.value == rhs.value;
    }

    /**
     * Is @p lhs.value > @p rhs.value?
     */
    friend constexpr bool operator > (
        ContainerWithComparison const & lhs,
        ContainerWithComparison const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() > std::declval<std::vector<int> const&>()))
    {
        return lhs.value > rhs.value;
    }

    /**
     * Is @p lhs.value >= @p rhs.value?
     */
    friend constexpr bool operator >= (
        ContainerWithComparison const & lhs,
        ContainerWithComparison const & rhs)
    noexcept(noexcept(std::declval<std::vector<int> const&>() >= std::declval<std::vector<int> const&>()))
    {
        return lhs.value >= rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for int
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ComparisonOnly
 * - description: int; !=, <, <=, ==, >, >=
 * - default_value: ""
 */
struct ComparisonOnly
: private atlas::strong_type_tag
{
    int value;

    using atlas_value_type = int;

    constexpr explicit ComparisonOnly() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<int, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ComparisonOnly(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr int const & atlas_value_for(ComparisonOnly const & self) noexcept {
        return self.value;
    }
    friend constexpr int & atlas_value_for(ComparisonOnly & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(ComparisonOnly && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<int>::value,
            int>::type
    {
        return std::move(self.value);
    }

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        ComparisonOnly const & lhs,
        ComparisonOnly const & rhs)
    noexcept(noexcept(std::declval<int const&>() != std::declval<int const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value < @p rhs.value?
     */
    friend constexpr bool operator < (
        ComparisonOnly const & lhs,
        ComparisonOnly const & rhs)
    noexcept(noexcept(std::declval<int const&>() < std::declval<int const&>()))
    {
        return lhs.value < rhs.value;
    }

    /**
     * Is @p lhs.value <= @p rhs.value?
     */
    friend constexpr bool operator <= (
        ComparisonOnly const & lhs,
        ComparisonOnly const & rhs)
    noexcept(noexcept(std::declval<int const&>() <= std::declval<int const&>()))
    {
        return lhs.value <= rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ComparisonOnly const & lhs,
        ComparisonOnly const & rhs)
    noexcept(noexcept(std::declval<int const&>() == std::declval<int const&>()))
    {
        return lhs.value == rhs.value;
    }

    /**
     * Is @p lhs.value > @p rhs.value?
     */
    friend constexpr bool operator > (
        ComparisonOnly const & lhs,
        ComparisonOnly const & rhs)
    noexcept(noexcept(std::declval<int const&>() > std::declval<int const&>()))
    {
        return lhs.value > rhs.value;
    }

    /**
     * Is @p lhs.value >= @p rhs.value?
     */
    friend constexpr bool operator >= (
        ComparisonOnly const & lhs,
        ComparisonOnly const & rhs)
    noexcept(noexcept(std::declval<int const&>() >= std::declval<int const&>()))
    {
        return lhs.value >= rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: AliasedWrapper
 * - description: std::string; forward=size:length,empty:is_empty; ==
 * - default_value: ""
 */
struct AliasedWrapper
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit AliasedWrapper() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit AliasedWrapper(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(AliasedWrapper const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(AliasedWrapper & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(AliasedWrapper && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward empty to wrapped object (aliased as is_empty)
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto is_empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object (aliased as length)
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto length(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto length(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        AliasedWrapper const & lhs,
        AliasedWrapper const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: ImmutableWrapper
 * - description: std::string; forward=const,size,empty; ==
 * - default_value: ""
 */
struct ImmutableWrapper
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit ImmutableWrapper() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit ImmutableWrapper(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(ImmutableWrapper const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(ImmutableWrapper & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(ImmutableWrapper && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto empty(Args&&... args) const
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }





    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto size(Args&&... args) const
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }





    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        ImmutableWrapper const & lhs,
        ImmutableWrapper const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: MixedForwarding
 * - description: std::string; forward=substr:substring,size:length,empty:is_empty,size,empty,clear; !=, ==
 * - default_value: ""
 */
struct MixedForwarding
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit MixedForwarding() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit MixedForwarding(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(MixedForwarding const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(MixedForwarding & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(MixedForwarding && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward clear to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * clear member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto clear(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.clear(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.clear(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.clear(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto clear(Args&&... args) const &
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) const &&
    noexcept(noexcept(std::move(value).clear(std::forward<Args>(args)...)))
    -> decltype(std::move(value).clear(std::forward<Args>(args)...))
    {
        return std::move(value).clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) &
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto clear(Args&&... args) &&
    noexcept(noexcept(std::move(value).clear(std::forward<Args>(args)...)))
    -> decltype(std::move(value).clear(std::forward<Args>(args)...))
    {
        return std::move(value).clear(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward empty to wrapped object (aliased as is_empty)
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto is_empty(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.empty(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.empty(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.empty(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) const &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) const &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) &
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto is_empty(Args&&... args) &&
    noexcept(noexcept(std::move(value).empty(std::forward<Args>(args)...)))
    -> decltype(std::move(value).empty(std::forward<Args>(args)...))
    {
        return std::move(value).empty(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object (aliased as length)
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto length(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto length(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto length(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto size(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.size(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.size(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.size(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto size(Args&&... args) const &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) const &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto size(Args&&... args) &&
    noexcept(noexcept(std::move(value).size(std::forward<Args>(args)...)))
    -> decltype(std::move(value).size(std::forward<Args>(args)...))
    {
        return std::move(value).size(std::forward<Args>(args)...);
    }
#endif

    /**
     * @brief Forward substr to wrapped object (aliased as substring)
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto substring(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.substr(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.substr(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.substr(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto substring(Args&&... args) const &
    noexcept(noexcept(value.substr(std::forward<Args>(args)...)))
    -> decltype(value.substr(std::forward<Args>(args)...))
    {
        return value.substr(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto substring(Args&&... args) const &&
    noexcept(noexcept(std::move(value).substr(std::forward<Args>(args)...)))
    -> decltype(std::move(value).substr(std::forward<Args>(args)...))
    {
        return std::move(value).substr(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto substring(Args&&... args) &
    noexcept(noexcept(value.substr(std::forward<Args>(args)...)))
    -> decltype(value.substr(std::forward<Args>(args)...))
    {
        return value.substr(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto substring(Args&&... args) &&
    noexcept(noexcept(std::move(value).substr(std::forward<Args>(args)...)))
    -> decltype(std::move(value).substr(std::forward<Args>(args)...))
    {
        return std::move(value).substr(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        MixedForwarding const & lhs,
        MixedForwarding const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        MixedForwarding const & lhs,
        MixedForwarding const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test


namespace test {

/**
 * @brief Strong type wrapper for std::string
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: struct
 * - type_namespace: test
 * - type_name: MixedForwardingConst
 * - description: std::string; forward=substr:substring,const,size:length,empty:is_empty,size,empty,clear; !=, ==
 * - default_value: ""
 */
struct MixedForwardingConst
: private atlas::strong_type_tag
{
    std::string value;

    using atlas_value_type = std::string;

    constexpr explicit MixedForwardingConst() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<std::string, ArgTs...>::value,
            bool>::type = true>
    constexpr explicit MixedForwardingConst(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * Access to immediate underlying value via ADL.
     */
    friend constexpr std::string const & atlas_value_for(MixedForwardingConst const & self) noexcept {
        return self.value;
    }
    friend constexpr std::string & atlas_value_for(MixedForwardingConst & self) noexcept {
        return self.value;
    }
    friend constexpr auto atlas_value_for(MixedForwardingConst && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<std::string>::value,
            std::string>::type
    {
        return std::move(self.value);
    }

    /**
     * @brief Forward clear to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * clear member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto clear(Args&&... args) const
    noexcept(noexcept(value.clear(std::forward<Args>(args)...)))
    -> decltype(value.clear(std::forward<Args>(args)...))
    {
        return value.clear(std::forward<Args>(args)...);
    }





    /**
     * @brief Forward empty to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto empty(Args&&... args) const
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }





    /**
     * @brief Forward empty to wrapped object (aliased as is_empty)
     *
     * This member function forwards all calls to the underlying type's
     * empty member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto is_empty(Args&&... args) const
    noexcept(noexcept(value.empty(std::forward<Args>(args)...)))
    -> decltype(value.empty(std::forward<Args>(args)...))
    {
        return value.empty(std::forward<Args>(args)...);
    }





    /**
     * @brief Forward size to wrapped object (aliased as length)
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto length(Args&&... args) const
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }





    /**
     * @brief Forward size to wrapped object
     *
     * This member function forwards all calls to the underlying type's
     * size member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     * Only const overloads are generated.
     */
    // C++11-20: ref-qualified overloads (or just const for const-only)
    template <typename... Args>
    constexpr auto size(Args&&... args) const
    noexcept(noexcept(value.size(std::forward<Args>(args)...)))
    -> decltype(value.size(std::forward<Args>(args)...))
    {
        return value.size(std::forward<Args>(args)...);
    }





    /**
     * @brief Forward substr to wrapped object (aliased as substring)
     *
     * This member function forwards all calls to the underlying type's
     * substr member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
     */
#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    constexpr auto substring(this Self&& self, Args&&... args)
    noexcept(noexcept(std::forward<Self>(self).value.substr(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.substr(std::forward<Args>(args)...))
    {
        return std::forward<Self>(self).value.substr(std::forward<Args>(args)...);
    }
#else
    // C++11-20: ref-qualified overloads (or just const for const-only)

    template <typename... Args>
    constexpr auto substring(Args&&... args) const &
    noexcept(noexcept(value.substr(std::forward<Args>(args)...)))
    -> decltype(value.substr(std::forward<Args>(args)...))
    {
        return value.substr(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto substring(Args&&... args) const &&
    noexcept(noexcept(std::move(value).substr(std::forward<Args>(args)...)))
    -> decltype(std::move(value).substr(std::forward<Args>(args)...))
    {
        return std::move(value).substr(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto substring(Args&&... args) &
    noexcept(noexcept(value.substr(std::forward<Args>(args)...)))
    -> decltype(value.substr(std::forward<Args>(args)...))
    {
        return value.substr(std::forward<Args>(args)...);
    }

    template <typename... Args>
    constexpr auto substring(Args&&... args) &&
    noexcept(noexcept(std::move(value).substr(std::forward<Args>(args)...)))
    -> decltype(std::move(value).substr(std::forward<Args>(args)...))
    {
        return std::move(value).substr(std::forward<Args>(args)...);
    }
#endif

    /**
     * Is @p lhs.value != @p rhs.value?
     */
    friend constexpr bool operator != (
        MixedForwardingConst const & lhs,
        MixedForwardingConst const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() != std::declval<std::string const&>()))
    {
        return lhs.value != rhs.value;
    }

    /**
     * Is @p lhs.value == @p rhs.value?
     */
    friend constexpr bool operator == (
        MixedForwardingConst const & lhs,
        MixedForwardingConst const & rhs)
    noexcept(noexcept(std::declval<std::string const&>() == std::declval<std::string const&>()))
    {
        return lhs.value == rhs.value;
    }
};
} // namespace test

#endif // TEST_C427B30F55B411D5704110B3CC06F45F58A40BC0

