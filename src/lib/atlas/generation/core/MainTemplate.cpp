// ----------------------------------------------------------------------
// Copyright 2025 Jody Hagins
// Distributed under the MIT Software License
// See accompanying file LICENSE or copy at
// https://opensource.org/licenses/MIT
// ----------------------------------------------------------------------
#include "ClassInfo.hpp"
#include "MainTemplate.hpp"
#include "TemplateRegistry.hpp"

#include <boost/json/array.hpp>
#include <boost/json/object.hpp>

#include "atlas/StrongTypeGenerator.hpp"

namespace wjh::atlas::generation {

// ============================================================================
// MainTemplate Implementation
// ============================================================================

std::string
MainTemplate::
id_impl() const noexcept
{
    return "core.main_structure";
}

std::string_view
MainTemplate::
get_template_impl() const noexcept
{
    // The template uses Mustache syntax:
    // - {{{variable}}} for unescaped variable substitution
    // - {{#section}}...{{/section}} for conditional rendering
    // - {{>partial}} for partial template inclusion
    //
    // For arithmetic operators, the TemplateOrchestrator accumulates all
    // operator renderings into a single "arithmetic_binary_operators" partial.
    // We use a dummy array with one element to trick Mustache into rendering
    // the partial exactly once (rather than looping over each operator).
    static constexpr std::string_view tmpl = R"(
{{#namespace_open}}
{{{.}}}{{/namespace_open}}
/**
 * @brief Strong type wrapper for {{{underlying_type}}}
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: {{{desc.kind}}}
 * - type_namespace: {{{desc.type_namespace}}}
 * - type_name: {{{desc.type_name}}}
 * - description: {{{desc.description}}}
 * - default_value: "{{{desc.default_value}}}"
 */
{{{desc.kind}}} {{{full_class_name}}}
: private atlas::strong_type_tag<{{{class_name}}}>
{
{{#has_default_value}}
    {{{underlying_type}}} {{{value}}} = static_cast<{{{underlying_type}}}>{{{default_initializer}}};
{{/has_default_value}}
{{^has_default_value}}
    {{{underlying_type}}} {{{value}}};
{{/has_default_value}}

{{#public_specifier}}
{{{.}}}
{{/public_specifier}}
    using atlas_value_type = {{{underlying_type}}};
{{#has_constraint}}
{{#is_bounded}}
    struct atlas_bounds
    {
        using value_type = atlas_value_type;
        static {{{const_expr}}}value_type min() noexcept {
            return value_type({{{bounded_min}}});
        }
        static {{{const_expr}}}value_type max() noexcept {
            return value_type({{{bounded_max}}});
        }
        static {{{const_expr}}}char const * message() noexcept {
            return "{{{constraint_message}}}";
        }
    };
{{/is_bounded}}
    using atlas_constraint = atlas::constraints::{{{constraint_type}}}{{{constraint_template_args}}};
{{/has_constraint}}
{{#constants}}
{{>constant_declarations}}
{{/constants}}

{{#delete_default_constructor}}
    {{{class_name}}}() = delete;
{{/delete_default_constructor}}
{{^delete_default_constructor}}
    {{{const_expr}}}explicit {{{class_name}}}() = default;
{{/delete_default_constructor}}

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<{{{underlying_type}}}, ArgTs...>::value,
            bool>::type = true>
    {{{const_expr}}}explicit {{{class_name}}}(ArgTs && ... args)
    : {{{value}}}(std::forward<ArgTs>(args)...)
    {{#has_constraint}}
    {
        if (not atlas::constraints::check<{{{class_name}}}>({{{value}}})) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: " +
                atlas::constraints::detail::format_value({{{value}}}) +
                " violates constraint: {{{constraint_message}}}");
        }
    }
    {{/has_constraint}}
    {{^has_constraint}}
    { }
    {{/has_constraint}}
    {{#template_assignment_operator}}
    {{>template_assignment_operator}}
    {{/template_assignment_operator}}

    /**
     * Access to immediate underlying value via ADL.
     */
    friend {{{const_expr}}}{{{underlying_type}}} const & atlas_value_for({{{class_name}}} const & self) noexcept {
        return self.{{{value}}};
    }
    friend {{{const_expr}}}{{{underlying_type}}} & atlas_value_for({{{class_name}}} & self) noexcept {
        return self.{{{value}}};
    }
    friend {{{const_expr}}}auto atlas_value_for({{{class_name}}} && self) noexcept
        -> typename std::enable_if<
            std::is_move_constructible<{{{underlying_type}}}>::value,
            {{{underlying_type}}}>::type
    {
        return std::move(self.{{{value}}});
    }
    {{#explicit_cast_operators}}
    {{>explicit_cast_operator}}
    {{/explicit_cast_operators}}
    {{#implicit_cast_operators}}
    {{>implicit_cast_operator}}
    {{/implicit_cast_operators}}
    {{#bool_operator}}
    {{>bool_operator}}
    {{/bool_operator}}
    {{#indirection_operator}}
    {{>indirection_operator}}
    {{/indirection_operator}}
    {{#addressof_operators}}
    {{>addressof_operators}}
    {{/addressof_operators}}
    {{#arrow_operator}}
    {{>arrow_operator}}
    {{/arrow_operator}}
    {{#nullary}}
    {{>nullary}}
    {{/nullary}}
    {{#callable}}
    {{>callable}}
    {{/callable}}
    {{#subscript_operator}}
    {{>subscript_operator}}
    {{/subscript_operator}}
    {{#iterator_support_member}}
    {{>iterator_support_member}}
    {{/iterator_support_member}}
    {{#forwarded_memfns}}
    {{>forwarded_memfn}}
    {{/forwarded_memfns}}
    {{#unary_operators}}
    {{>unary_operators}}
    {{/unary_operators}}
    {{#logical_not_operator}}
    {{>logical_not_operator}}
    {{/logical_not_operator}}
    {{#logical_operators}}
    {{>logical_operator}}
    {{/logical_operators}}
    {{#increment_operators}}
    {{>increment_operator}}
    {{/increment_operators}}
    {{#arithmetic_binary_operators}}
    {{>arithmetic_binary_operators}}
    {{/arithmetic_binary_operators}}
    {{#spaceship_operator}}
    {{>spaceship_operator}}
    {{/spaceship_operator}}
    {{#defaulted_equality_operator}}
    {{>defaulted_equality_operator}}
    {{/defaulted_equality_operator}}
    {{#relational_operators}}
    {{>relational_operator}}
    {{/relational_operators}}
    {{#ostream_operator}}
    {{>ostream_operator}}
    {{/ostream_operator}}
    {{#istream_operator}}
    {{>istream_operator}}
    {{/istream_operator}}
};
{{#constants}}

{{>constants}}
{{/constants}}
{{#namespace_close}}
{{{.}}}{{/namespace_close}}
{{#hash_specialization}}
{{>hash_specialization}}
{{/hash_specialization}}
{{#formatter_specialization}}
{{>formatter_specialization}}
{{/formatter_specialization}}
)";

    return tmpl;
}

bool
MainTemplate::
should_apply_impl(ClassInfo const &) const noexcept
{
    return true;
}

boost::json::object
MainTemplate::
prepare_variables_impl(ClassInfo const & info) const
{
    // Convert ClassInfo to JSON
    auto vars = info.to_json();

    // CRITICAL FIX: The TemplateOrchestrator accumulates all arithmetic
    // operator renderings into a single "arithmetic_binary_operators" partial
    // string. Each individual operator template (AdditionOperator,
    // SubtractionOperator, etc.) determines whether it applies and contributes
    // its rendering to the accumulated partial.
    //
    // The main template uses:
    // {{#arithmetic_binary_operators}}{{>partial}}{{/arithmetic_binary_operators}}
    //
    // If we leave arithmetic_binary_operators as an array with N elements
    // (e.g., ["+", "-", "*", "/"]), Mustache will LOOP over the array and
    // render the partial N times, causing duplicate definitions.
    //
    // Solution: ALWAYS replace the array with a single-element dummy array.
    // This causes Mustache to render the accumulated partial exactly once.
    // The dummy element's fields are irrelevant since the partial contains
    // pre-rendered code.
    //
    // This fix applies to ALL arithmetic modes (Default, Checked, Saturating,
    // Wrapping) because the orchestrator accumulates the partial in all cases.
    if (not info.arithmetic_binary_operators.empty()) {
        // Create a dummy array with one element to trigger partial rendering
        // once
        boost::json::array dummy;
        boost::json::object dummy_obj;
        dummy_obj["op"] = "_"; // Placeholder, not used in pre-rendered partial
        dummy.push_back(dummy_obj);
        vars["arithmetic_binary_operators"] = dummy;
    }

    // Apply the same fix for relational operators
    // Template uses:
    // {{#relational_operators}}{{>relational_operator}}{{/relational_operators}}
    // The partial contains pre-accumulated code for ALL relational operators
    if (not info.relational_operators.empty()) {
        boost::json::array dummy;
        boost::json::object dummy_obj;
        dummy_obj["op"] = "_"; // Placeholder, not used in pre-rendered partial
        dummy.push_back(dummy_obj);
        vars["relational_operators"] = dummy;
    }

    // Apply the same fix for forwarded member functions
    // Template uses:
    // {{#forwarded_memfns}}{{>forwarded_memfn}}{{/forwarded_memfns}} The
    // partial contains pre-accumulated code for ALL forwarded member functions
    if (not info.forwarded_memfns.empty()) {
        boost::json::array dummy;
        boost::json::object dummy_obj;
        dummy_obj["memfn_name"] =
            "_"; // Placeholder, not used in pre-rendered partial
        dummy.push_back(dummy_obj);
        vars["forwarded_memfns"] = dummy;
    }

    // Apply the same fix for explicit cast operators
    // Template uses:
    // {{#explicit_cast_operators}}{{>explicit_cast_operator}}{{/explicit_cast_operators}}
    // The partial contains pre-accumulated code for ALL explicit cast operators
    if (not info.explicit_cast_operators.empty()) {
        boost::json::array dummy;
        boost::json::object dummy_obj;
        dummy_obj["cast_type"] =
            "_"; // Placeholder, not used in pre-rendered partial
        dummy.push_back(dummy_obj);
        vars["explicit_cast_operators"] = dummy;
    }

    // Apply the same fix for implicit cast operators
    // Template uses:
    // {{#implicit_cast_operators}}{{>implicit_cast_operator}}{{/implicit_cast_operators}}
    // The partial contains pre-accumulated code for ALL implicit cast operators
    if (not info.implicit_cast_operators.empty()) {
        boost::json::array dummy;
        boost::json::object dummy_obj;
        dummy_obj["cast_type"] =
            "_"; // Placeholder, not used in pre-rendered partial
        dummy.push_back(dummy_obj);
        vars["implicit_cast_operators"] = dummy;
    }

    // Apply the same fix for increment operators
    // Template uses:
    // {{#increment_operators}}{{>increment_operator}}{{/increment_operators}}
    // The IncrementOperatorsTemplate::render_impl() loops over all operators
    // and accumulates them into a single pre-rendered partial string.
    // The dummy array triggers Mustache to render the partial exactly once.
    if (not info.increment_operators.empty()) {
        boost::json::array dummy;
        boost::json::object dummy_obj;
        dummy_obj["op"] = "_"; // Placeholder, not used in pre-rendered partial
        dummy.push_back(dummy_obj);
        vars["increment_operators"] = dummy;
    }

    // Apply the same fix for unary operators
    // Template uses:
    // {{#unary_operators}}{{>unary_operators}}{{/unary_operators}} The
    // UnaryOperatorsTemplate::render_impl() loops over all operators and
    // accumulates them into a single pre-rendered partial string. The dummy
    // array triggers Mustache to render the partial exactly once.
    if (not info.unary_operators.empty()) {
        boost::json::array dummy;
        boost::json::object dummy_obj;
        dummy_obj["op"] = "_"; // Placeholder, not used in pre-rendered partial
        dummy.push_back(dummy_obj);
        vars["unary_operators"] = dummy;
    }

    // Apply the same fix for logical operators
    // Template uses:
    // {{#logical_operators}}{{>logical_operator}}{{/logical_operators}} The
    // partial contains pre-accumulated code for ALL logical operators
    if (not info.logical_operators.empty()) {
        boost::json::array dummy;
        boost::json::object dummy_obj;
        dummy_obj["op"] = "_"; // Placeholder, not used in pre-rendered partial
        dummy.push_back(dummy_obj);
        vars["logical_operators"] = dummy;
    }

    return vars;
}

std::set<std::string>
MainTemplate::
required_includes_impl() const noexcept
{
    // The main template doesn't need any additional includes.
    // Feature-specific templates (hash, formatter, etc.) will add their own.
    return {};
}

// ============================================================================
// Self-Registration
// ============================================================================

namespace {

/**
 * Self-registering instance of MainTemplate
 *
 * This static instance registers the MainTemplate with the TemplateRegistry
 * during static initialization (before main() starts).
 *
 * The TemplateRegistrar RAII helper ensures the template is registered
 * exactly once, using the singleton registry pattern.
 *
 * STATIC INITIALIZATION SAFETY:
 * The TemplateRegistrar depends on TemplateRegistry::instance(), which
 * uses the initialization-on-first-use idiom (a.k.a. Meyers' Singleton):
 * the registry is a function-local static variable, ensuring it's
 * initialized before first use regardless of translation unit ordering.
 * This guarantees safe registration even in the presence of the static
 * initialization order fiasco.
 */
TemplateRegistrar<MainTemplate> register_main_template;

} // anonymous namespace

} // namespace wjh::atlas::generation
