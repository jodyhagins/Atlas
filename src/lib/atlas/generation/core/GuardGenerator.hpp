// ----------------------------------------------------------------------
// Copyright 2025 Jody Hagins
// Distributed under the MIT Software License
// See accompanying file LICENSE or copy at
// https://opensource.org/licenses/MIT
// ----------------------------------------------------------------------
#ifndef WJH_ATLAS_9E8D7C6B5A4F3E2D1C0B9A8E7D6C5B4A
#define WJH_ATLAS_9E8D7C6B5A4F3E2D1C0B9A8E7D6C5B4A

#include "atlas/StrongTypeGenerator.hpp"

#include <string>

namespace wjh::atlas::generation {

/**
 * @brief Generates header guards and notice banners for strong type code
 *
 * The GuardGenerator provides utilities for creating unique header guards
 * based on type names and content hashes, as well as standardized notice
 * banners for generated code.
 *
 * Design philosophy:
 * - Guards are content-addressable: include SHA1 hash of generated code
 * - Guards are namespace-aware: incorporate fully qualified type names
 * - Banners are consistent: reference Atlas Strong Type Generator
 * - All functions are static: no state management required
 *
 * Example usage:
 * @code
 * StrongTypeDescription desc = ...;
 * std::string code = generate_strong_type_code(desc);
 *
 * std::string guard = GuardGenerator::make_guard(desc, code);
 * std::string banner = GuardGenerator::make_notice_banner();
 *
 * output << "#ifndef " << guard << "\n"
 *        << "#define " << guard << "\n"
 *        << banner
 *        << code
 *        << "#endif // " << guard << "\n";
 * @endcode
 */
class GuardGenerator
{
public:
    /**
     * @brief Generate the standard "DO NOT EDIT" notice banner
     *
     * Creates a multi-line comment banner that warns users not to directly
     * edit generated files. The banner includes:
     * - Visual separator lines (====== and ------)
     * - "DO NOT EDIT THIS FILE DIRECTLY" warnings
     * - Generator name and version from codegen::version_string
     * - Project URL (https://github.com/jodyhagins/Atlas)
     *
     * The banner is identical across all generated files to maintain
     * consistency and professional appearance.
     *
     * @return String containing the formatted notice banner
     *
     * @throws None - This function is effectively noexcept. The banner is
     *         cached in a static variable and built only once on first call.
     *         If banner construction fails during static initialization, it
     *         would result in program termination (not a catchable exception).
     *
     * Example output:
     * @code
     * // ======================================================================
     * // NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
     * // ----------------------------------------------------------------------
     * //
     * // DO NOT EDIT THIS FILE DIRECTLY.
     * //
     * // This source file has been generated by Atlas Strong Type Generator
     * v0.1.0
     * // https://github.com/jodyhagins/Atlas
     * //
     * // DO NOT EDIT THIS FILE DIRECTLY.
     * //
     * // ----------------------------------------------------------------------
     * // NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
     * // ======================================================================
     * @endcode
     */
    [[nodiscard]]
    static std::string make_notice_banner();

    /**
     * @brief Generate a unique header guard for generated code
     *
     * Creates a header guard identifier that is:
     * - Unique: Incorporates SHA1 hash of the generated code
     * - Namespace-aware: Includes the fully qualified type name
     * - Customizable: Respects desc.guard_prefix, guard_separator, and
     * upcase_guard
     * - Macro-safe: Strips colons from namespaces
     *
     * Guard generation algorithm:
     * 1. Start with guard_prefix (or derive from type_namespace + type_name)
     * 2. Append guard_separator
     * 3. Append SHA1 hash of code (computed via get_sha1)
     * 4. Convert to uppercase if upcase_guard is true
     *
     * The guard format ensures:
     * - No conflicts between types with same name in different namespaces
     * - No conflicts when type definition changes (due to content hash)
     * - Valid C++ macro identifiers (no :: in final guard)
     *
     * @param desc Strong type description with guard configuration
     * @param code The generated code to hash (determines uniqueness)
     * @return Header guard identifier (e.g.,
     * "MY_NAMESPACE_MYTYPE_A7B3C9D2...")
     *
     * @throws std::bad_alloc if string allocation fails during guard
     * construction
     * @throws May propagate exceptions from get_sha1() if SHA computation fails
     *
     * Example:
     * @code
     * StrongTypeDescription desc;
     * desc.type_namespace = "acme::util";
     * desc.type_name = "UserId";
     * desc.guard_prefix = "";          // Empty = auto-generate
     * desc.guard_separator = "_";
     * desc.upcase_guard = true;
     * std::string code = "...generated code...";
     *
     * std::string guard = GuardGenerator::make_guard(desc, code);
     * // Result: "ACME_UTIL_USERID_9A8B7C6D5E4F..." (with SHA1 hash)
     * @endcode
     *
     * @note The SHA1 hash ensures the guard changes if the generated code
     *       changes, preventing stale include guard conflicts during
     *       development.
     *
     * @see wjh::atlas::get_sha1() for hash computation
     */
    [[nodiscard]]
    static std::string make_guard(
        StrongTypeDescription const & desc,
        std::string const & code);
};

} // namespace wjh::atlas::generation

#endif // WJH_ATLAS_9E8D7C6B5A4F3E2D1C0B9A8E7D6C5B4A
