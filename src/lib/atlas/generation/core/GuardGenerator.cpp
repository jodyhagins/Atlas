// ----------------------------------------------------------------------
// Copyright 2025 Jody Hagins
// Distributed under the MIT Software License
// See accompanying file LICENSE or copy at
// https://opensource.org/licenses/MIT
// ----------------------------------------------------------------------
#include "GuardGenerator.hpp"

#include "atlas/SHA1Hasher.hpp"
#include "atlas/version.hpp"

#include <algorithm>
#include <cctype>
#include <sstream>
#include <string>
#include <string_view>

namespace wjh::atlas::generation {

// Helper to strip leading and trailing colons from a string_view
static constexpr std::string_view
strip_namespace_colons(std::string_view sv) noexcept
{
    // Strip leading colons
    while (not sv.empty() && sv.front() == ':') {
        sv.remove_prefix(1);
    }

    // Strip trailing colons
    while (not sv.empty() && sv.back() == ':') {
        sv.remove_suffix(1);
    }

    return sv;
}

std::string
GuardGenerator::
make_notice_banner()
{
    // Cache the banner - it's always the same, so build it once
    static std::string const banner = []() {
        // The banner is split into two parts to avoid including the leading
        // newline in the final output (note the +1 offset when outputting b1)
        static constexpr char const b1[] = R"(
// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v)";

        std::ostringstream oss;
        // Skip the leading newline by starting at b1 + 1
        oss << (b1 + 1) << codegen::version_string << R"(
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================
)";
        return oss.str();
    }();

    return banner;
}

std::string
GuardGenerator::
make_guard(StrongTypeDescription const & desc, std::string const & code)
{
    std::string result;

    if (not desc.guard_prefix.empty()) {
        // Use explicit prefix if provided
        result = desc.guard_prefix;
    } else {
        // Auto-generate prefix from type_namespace and type_name
        // Strip colons from namespaces to make valid macro identifiers
        char prev = '\0';

        // Build qualified name: namespace::type_name
        std::string qualified_name;
        // Reserve approximate capacity: namespace + "::" + type_name
        qualified_name.reserve(
            desc.type_namespace.size() + 2 + desc.type_name.size());
        qualified_name += strip_namespace_colons(desc.type_namespace);
        qualified_name += "::";
        qualified_name += strip_namespace_colons(desc.type_name);

        // Reserve capacity for result (approximate: qualified name + separator
        // + hash) SHA1 hash is 40 characters
        result.reserve(
            qualified_name.size() + desc.guard_separator.size() + 40);

        // Now iterate and replace :: with separator
        for (char c : qualified_name) {
            // Replace :: with guard_separator
            // This converts "namespace::Type" to "namespace_Type"
            if (c == ':') {
                // Only add separator if previous char wasn't also a colon
                // (handles the "::" case to emit single separator)
                if (prev != ':') {
                    result += desc.guard_separator;
                }
            } else {
                result += c;
            }
            prev = c;
        }
    }

    // Append separator and SHA1 hash of the generated code
    result += desc.guard_separator;
    result += get_sha1(code);

    // Convert to uppercase if requested
    if (desc.upcase_guard) {
        std::transform(
            result.begin(),
            result.end(),
            result.begin(),
            [](unsigned char c) {
                return static_cast<char>(std::toupper(static_cast<int>(c)));
            });
    }

    return result;
}

} // namespace wjh::atlas::generation
