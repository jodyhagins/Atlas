// ----------------------------------------------------------------------
// Copyright 2025 Jody Hagins
// Distributed under the MIT Software License
// See accompanying file LICENSE or copy at
// https://opensource.org/licenses/MIT
// ----------------------------------------------------------------------
#include "AtlasUtilities.hpp"
#include "StrongTypeGenerator.hpp"
#include "version.hpp"

#include <boost/describe.hpp>
#include <boost/json/src.hpp>
#include <boost/mustache.hpp>
#include <boost/uuid/detail/sha1.hpp>

#include <algorithm>
#include <array>
#include <filesystem>
#include <map>
#include <set>
#include <sstream>
#include <string>
#include <string_view>

#include <iostream>

namespace wjh::atlas { inline namespace v1 {


BOOST_DESCRIBE_STRUCT(
    StrongTypeDescription,
    (),
    (kind,
     type_namespace,
     type_name,
     description,
     default_value,
     guard_prefix,
     guard_separator,
     upcase_guard,
     generate_iterators,
     generate_formatter))

namespace {

// Print warnings to stderr with optional color
void
print_warnings(std::vector<StrongTypeGenerator::Warning> const & warnings)
{
    if (warnings.empty()) {
        return;
    }

    bool use_color = supports_color(fileno(stderr));

    std::cerr << "\n";
    if (use_color) {
        std::cerr << color::red << "Warnings:" << color::reset << "\n";
        for (auto const & w : warnings) {
            std::cerr << "  " << color::yellow << w.type_name << ": "
                << w.message << color::reset << "\n";
        }
    } else {
        std::cerr << "Warnings:\n";
        for (auto const & w : warnings) {
            std::cerr << "  " << w.type_name << ": " << w.message << "\n";
        }
    }
    std::cerr << std::endl;
}

std::string
get_sha1(std::string const & s)
{
    boost::uuids::detail::sha1 sha1;
    sha1.process_bytes(s.data(), s.size());
    boost::uuids::detail::sha1::digest_type hash;
    sha1.get_digest(hash);

    std::string result;
    for (unsigned int x : hash) {
        char buffer[64];
        snprintf(buffer, sizeof(buffer), "%08x", x);
        result += buffer;
    }
    return result;
}

std::string
make_notice_banner()
{
    static constexpr char const b1[] = R"(
// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v)";
    std::ostringstream banner;
    banner << (b1 + 1) << codegen::version_string << R"(
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================
)";
    return banner.str();
}

auto strong_template = R"({{{includes}}}{{#namespace_open}}
{{{.}}}{{/namespace_open}}
/**
 * @brief Strong type wrapper for {{{underlying_type}}}
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: {{{desc.kind}}}
 * - type_namespace: {{{desc.type_namespace}}}
 * - type_name: {{{desc.type_name}}}
 * - description: {{{desc.description}}}
 * - default_value: "{{{desc.default_value}}}"
 */
{{{desc.kind}}} {{{full_class_name}}}
: private atlas::strong_type_tag
{
{{#has_default_value}}
    {{{underlying_type}}} value{{{default_initializer}}};
{{/has_default_value}}
{{^has_default_value}}
    {{{underlying_type}}} value;
{{/has_default_value}}

{{#public_specifier}}
{{{.}}}
{{/public_specifier}}
    using atlas_value_type = {{{underlying_type}}};

    {{{const_expr}}}explicit {{{class_name}}}() = default;
    {{{const_expr}}}{{{class_name}}}({{{class_name}}} const &) = default;
    {{{const_expr}}}{{{class_name}}}({{{class_name}}} &&) = default;
    {{{const_expr}}}{{{class_name}}} & operator = ({{{class_name}}} const &) = default;
    {{{const_expr}}}{{{class_name}}} & operator = ({{{class_name}}} &&) = default;
    {{{const_expr}}}~{{{class_name}}}() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<{{{underlying_type}}}, ArgTs...>::value,
            bool>::type = true>
    {{{const_expr}}}explicit {{{class_name}}}(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }
    {{#template_assignment_operator}}
    {{>template_assignment_operator}}
    {{/template_assignment_operator}}

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    {{{const_expr}}}explicit operator {{{underlying_type}}} const & () const { return value; }
    {{{const_expr}}}explicit operator {{{underlying_type}}} & () { return value; }
    {{#explicit_cast_operators}}
    {{>explicit_cast_operator}}
    {{/explicit_cast_operators}}
    {{#implicit_cast_operators}}
    {{>implicit_cast_operator}}
    {{/implicit_cast_operators}}
    {{#bool_operator}}
    {{>bool_operator}}
    {{/bool_operator}}
    {{#indirection_operator}}
    {{>indirection_operator}}
    {{/indirection_operator}}
    {{#addressof_operators}}
    {{>addressof_operators}}
    {{/addressof_operators}}
    {{#nullary}}
    {{>nullary}}
    {{/nullary}}
    {{#callable}}
    {{>callable}}
    {{/callable}}
    {{#subscript_operator}}
    {{>subscript_operator}}
    {{/subscript_operator}}
    {{#iterator_support_member}}
    {{>iterator_support_member}}
    {{/iterator_support_member}}
    {{#unary_operators}}
    {{>unary_operators}}
    {{/unary_operators}}
    {{#logical_not_operator}}
    {{>logical_not_operator}}
    {{/logical_not_operator}}
    {{#logical_operators}}
    {{>logical_operator}}
    {{/logical_operators}}
    {{#increment_operators}}
    {{>increment_operator}}
    {{/increment_operators}}
    {{#arithmetic_binary_operators}}
    {{>arithmetic_binary_operators}}
    {{/arithmetic_binary_operators}}
    {{#spaceship_operator}}
    {{>spaceship_operator}}
    {{/spaceship_operator}}
    {{#defaulted_equality_operator}}
    {{>defaulted_equality_operator}}
    {{/defaulted_equality_operator}}
    {{#relational_operators}}
    {{>relational_operator}}
    {{/relational_operators}}
    {{#ostream_operator}}
    {{>ostream_operator}}
    {{/ostream_operator}}
    {{#istream_operator}}
    {{>istream_operator}}
    {{/istream_operator}}
};
{{#namespace_close}}
{{{.}}}{{/namespace_close}}
{{#hash_specialization}}
{{>hash_specialization}}
{{/hash_specialization}}
{{#formatter_specialization}}
{{>formatter_specialization}}
{{/formatter_specialization}}
)";

constexpr char addressof_operators[] = R"(
    /**
     * Access a pointer to the wrapped object.
     */
    {{{const_expr}}}{{{underlying_type}}} const * operator {{{op}}} () const
    noexcept
    {
        return std::addressof(value);
    }
    {{{const_expr}}}{{{underlying_type}}} * operator {{{op}}} ()
    noexcept
    {
        return std::addressof(value);
    }
)";

constexpr char relational_operator[] = R"(
    /**
     * Is @p lhs.value {{{op}}} @p rhs.value?
     */
    friend {{{const_expr}}}bool operator {{{op}}} (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const&>() {{{op}}} std::declval<{{{underlying_type}}} const&>()))
    {
        return lhs.value {{{op}}} rhs.value;
    }
)";

constexpr char arithmetic_binary_operators[] = R"(
    /**
     * Apply {{{op}}} assignment to the wrapped objects.
     */
    friend {{{const_expr}}}{{{class_name}}} & operator {{{op}}}= (
        {{{class_name}}} & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}}&>() {{{op}}}= std::declval<{{{underlying_type}}} const&>()))
    {
        lhs.value {{{op}}}= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator {{{op}}} to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}} operator {{{op}}} (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(lhs {{{op}}}= rhs))
    {
        lhs {{{op}}}= rhs;
        return lhs;
    }
)";

constexpr char logical_operator[] = R"(
    /**
     * Apply the binary logical operator {{{op}}} to the wrapped object.
     *
     * @note  General advice is to NOT overload these operators.
     * One of the reasons is that short-circuit is no longer available.
     * Proceed with caution.
     */
    friend {{{const_expr}}}bool operator {{{op}}} (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const&>() {{{op}}} std::declval<{{{underlying_type}}} const&>()))
    {
        return lhs.value {{{op}}} rhs.value;
    }
)";

constexpr char unary_operators[] = R"(
    /**
     * Apply the unary {{{op}}} operator to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}} operator {{{op}}} ({{{class_name}}} const & t)
    noexcept(
        noexcept({{{op}}} std::declval<{{{underlying_type}}} const&>()) &&
        std::is_nothrow_assignable<
            {{{underlying_type}}}&,
            decltype({{{op}}} std::declval<{{{underlying_type}}} const&>())>::value)
    {
        auto result = t;
        result.value = {{{op}}} t.value;
        return result;
    }
)";

constexpr char increment_operator[] = R"(
    /**
     * Apply the prefix {{{op}}} operator to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}} &
    operator {{{op}}} ({{{class_name}}} & t)
    noexcept(noexcept({{{op}}}std::declval<{{{underlying_type}}}&>()))
    {
        {{{op}}}t.value;
        return t;
    }
    /**
     * Apply the postfix {{{op}}} operator to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}}
    operator {{{op}}} ({{{class_name}}} & t, int)
    noexcept(
        std::is_nothrow_copy_constructible<{{{underlying_type}}}>::value &&
        noexcept({{{op}}}std::declval<{{{underlying_type}}}&>()))
    {
        auto result = t;
        {{{op}}}t.value;
        return result;
    }
)";

constexpr char bool_operator_template[] = R"(
    /**
     * Return the result of casting the wrapped object to bool.
     */
    {{{const_expr}}}explicit operator bool () const
    noexcept(noexcept(static_cast<bool>(
        std::declval<{{{underlying_type}}} const&>())))
    {
        return static_cast<bool>(value);
    }
)";

constexpr char explicit_cast_operator_template[] = R"(
    /**
     * Explicit cast to {{{cast_type}}}
     */
    {{{const_expr}}}explicit operator {{{cast_type}}}() const
    noexcept(noexcept(static_cast<{{{cast_type}}}>(
        std::declval<{{{underlying_type}}} const&>())))
    {
        return static_cast<{{{cast_type}}}>(value);
    }
)";

constexpr char implicit_cast_operator_template[] = R"(
    /**
     * Implicit cast to {{{cast_type}}}
     */
    {{{const_expr}}}operator {{{cast_type}}}() const
    noexcept(noexcept(static_cast<{{{cast_type}}}>(
        std::declval<{{{underlying_type}}} const&>())))
    {
        return static_cast<{{{cast_type}}}>(value);
    }
)";

constexpr char indirection_operator_template[] = R"(
    /**
     * The indirection operator provides a reference to the wrapped object.
     */
    {{{const_expr}}}{{{underlying_type}}} const & operator * () const
    noexcept
    {
        return value;
    }
    {{{const_expr}}}{{{underlying_type}}} & operator * ()
    noexcept
    {
        return value;
    }
)";

constexpr char nullary_template[] = R"(
    /**
     * A nullary call operator that returns access to the wrapped type.
     */
    {{{const_expr}}}{{{underlying_type}}} const & operator () () const
    noexcept
    {
        return value;
    }
    {{{const_expr}}}{{{underlying_type}}} & operator () ()
    noexcept
    {
        return value;
    }
)";

constexpr char callable_template[] = R"(
    /**
     * A call operator that takes an invocable, which is then invoked with the
     * wrapped object.
     */
#if defined(__cpp_lib_invoke) && __cpp_lib_invoke >= 201411L
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv) const
    noexcept(noexcept(std::invoke(std::forward<InvocableT>(inv), value)))
    -> decltype(std::invoke(std::forward<InvocableT>(inv), value))
    {
        return std::invoke(std::forward<InvocableT>(inv), value);
    }
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv)
    noexcept(noexcept(std::invoke(std::forward<InvocableT>(inv), value)))
    -> decltype(std::invoke(std::forward<InvocableT>(inv), value))
    {
        return std::invoke(std::forward<InvocableT>(inv), value);
    }
#else
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv) const
    noexcept(noexcept(std::forward<InvocableT>(inv)(value)))
    -> decltype(std::forward<InvocableT>(inv)(value))
    {
        return std::forward<InvocableT>(inv)(value);
    }
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv)
    noexcept(noexcept(std::forward<InvocableT>(inv)(value)))
    -> decltype(std::forward<InvocableT>(inv)(value))
    {
        return std::forward<InvocableT>(inv)(value);
    }
#endif
)";

constexpr char logical_not_template[] = R"(
    /**
     * Apply the unary logical not operator to the wrapped object.
     */
    friend {{{const_expr}}}bool operator not ({{{class_name}}} const & t)
    noexcept(noexcept(not std::declval<{{{underlying_type}}} const&>()))
    {
        return not t.value;
    }
)";

constexpr char spaceship_operator_template[] = R"(
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend {{{const_expr}}}auto operator <=> (
        {{{class_name}}} const &,
        {{{class_name}}} const &) = default;
)";

constexpr char defaulted_equality_operator_template[] = R"(
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend {{{const_expr}}}bool operator == (
        {{{class_name}}} const &,
        {{{class_name}}} const &) = default;
)";

constexpr char ostream_operator_template[] = R"(
    /**
     * Insert the wrapped object into an ostream.
     */
    friend std::ostream & operator << (
        std::ostream & strm,
        {{{class_name}}} const & t)
    {
        return strm << t.value;
    }
)";

constexpr char istream_operator_template[] = R"(
    /**
     * Extract the wrapped object from an istream.
     */
    friend std::istream & operator >> (
        std::istream & strm,
        {{{class_name}}} & t)
    {
        return strm >> t.value;
    }
)";

constexpr char hash_specialization_template[] = R"(
/**
 * @brief std::hash specialization for {{{full_qualified_name}}}
 *
 * Delegates to std::hash of the underlying type {{{underlying_type}}}
 */
template <>
struct std::hash<{{{full_qualified_name}}}>
{
    ATLAS_NODISCARD
    {{{hash_const_expr}}}std::size_t operator () ({{{full_qualified_name}}} const & t) const
    noexcept(
        noexcept(std::hash<{{{underlying_type}}}>{}(
            std::declval<{{{underlying_type}}} const &>())))
    {
        return std::hash<{{{underlying_type}}}>{}(
            static_cast<{{{underlying_type}}} const &>(t));
    }
};
)";

constexpr char formatter_specialization_template[] = R"(
/**
 * @brief std::formatter specialization for {{{full_qualified_name}}}
 *
 * Enables use with std::format and std::print in C++20 and later:
 *   std::format("{}", strong_type_instance)
 *
 * This specialization is only available when std::format is available
 * (checked via __cpp_lib_format >= 202110L). Delegates formatting to the
 * underlying type {{{underlying_type}}}
 */
#if defined(__cpp_lib_format) && __cpp_lib_format >= 202110L
template <>
struct std::formatter<{{{full_qualified_name}}}> : std::formatter<{{{underlying_type}}}>
{
    auto format({{{full_qualified_name}}} const & t, std::format_context & ctx) const
    {
        return std::formatter<{{{underlying_type}}}>::format(
            static_cast<{{{underlying_type}}} const &>(t), ctx);
    }
};
#endif // defined(__cpp_lib_format) && __cpp_lib_format >= 202110L
)";

constexpr char subscript_operator_template[] = R"(
    /**
     * Subscript operator that forwards to the wrapped object.
     */
#if __cpp_multidimensional_subscript >= 202110L
    template <typename ArgT, typename... ArgTs>
    {{{const_expr}}}decltype(auto) operator [] (ArgT && arg, ArgTs && ... args)
    noexcept(noexcept(value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...]))
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
    template <typename ArgT, typename... ArgTs>
    {{{const_expr}}}decltype(auto) operator [] (ArgT && arg, ArgTs && ... args) const
    noexcept(noexcept(value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...]))
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
#else
    template <typename ArgT>
    {{{const_expr}}}auto operator [] (ArgT && arg)
    noexcept(noexcept(value[std::forward<ArgT>(arg)]))
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
    template <typename ArgT>
    {{{const_expr}}}auto operator [] (ArgT && arg) const
    noexcept(noexcept(value[std::forward<ArgT>(arg)]))
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
#endif
)";

constexpr char iterator_support_template[] = R"(
    /**
     * Iterator type aliases for container-like interface.
     */
    using iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<{{{underlying_type}}}&>()));
    using const_iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<{{{underlying_type}}} const&>()));
    using value_type = typename std::remove_reference<decltype(
        *atlas::atlas_detail::begin_(
            std::declval<{{{underlying_type}}}&>()))>::type;

    /**
     * Member functions for iterator access.
     * Enables both explicit calls (e.g., s.begin()) and range-based for loops.
     * Uses ADL-enabled helpers that work in decltype/noexcept contexts.
     */
    {{{const_expr}}}auto begin()
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    {{{const_expr}}}auto end()
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    {{{const_expr}}}auto begin() const
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    {{{const_expr}}}auto end() const
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }
)";

constexpr char template_assignment_operator_template[] = R"(
    /**
     * @brief Template assignment operator
     *
     * Allows assignment from any type that is assignable to the underlying type.
     * This provides convenience while maintaining type safety through SFINAE.
     *
     * Example:
     *   StrongType s{"initial"};
     *   s = "new value";        // Works if assignable
     *   s = std::string("foo"); // Works if assignable
     *   s = 42;                 // Rejected if not assignable
     *
     * Note: constexpr is applied only in C++14 and later because in C++11,
     * constexpr non-static member functions are implicitly const.
     */
#if defined(__cpp_concepts) && __cpp_concepts >= 201907L
    template <typename T>
      requires (std::assignable_from<{{{underlying_type}}}&, T> &&
                not std::same_as<std::decay_t<T>, {{{class_name}}}>)
#else
    template <typename T,
        typename std::enable_if<
            std::is_assignable<{{{underlying_type}}}&, T>::value &&
            not std::is_same<typename std::decay<T>::type, {{{class_name}}}>::value,
            int>::type = 0>
#endif
#if __cplusplus >= 201402L
    {{{const_expr}}}{{{class_name}}}& operator=(T&& t)
#else
    {{{class_name}}}& operator=(T&& t)
#endif
    noexcept(noexcept(std::declval<{{{underlying_type}}}&>() = std::declval<T>()))
    {
        value = std::forward<T>(t);
        return *this;
    }
)";

struct Operator
{
    std::string_view op;

    explicit Operator(std::string_view op_)
    : op(op_)
    { }

    friend bool operator < (Operator const & x, Operator const & y)
    {
        return x.op < y.op;
    }
};
BOOST_DESCRIBE_STRUCT(Operator, (), (op))

struct CastOperator
{
    std::string cast_type;

    explicit CastOperator(std::string cast_type_)
    : cast_type(std::move(cast_type_))
    { }
};
BOOST_DESCRIBE_STRUCT(CastOperator, (), (cast_type))

struct ClassInfo
{
    std::string class_namespace;
    std::string namespace_open;
    std::string namespace_close;
    std::string full_class_name;
    std::string class_name;
    std::string underlying_type;
    std::vector<Operator> arithmetic_binary_operators;
    std::vector<Operator> unary_operators;
    std::string indirection_operator;
    std::vector<Operator> addressof_operators;
    bool spaceship_operator = false;
    bool defaulted_equality_operator = false;
    std::vector<Operator> relational_operators;
    std::vector<Operator> increment_operators;
    bool ostream_operator = false;
    bool istream_operator = false;
    std::string bool_operator;
    bool nullary = false;
    bool callable = false;
    std::string public_specifier;
    bool logical_not_operator = false;
    std::vector<Operator> logical_operators;
    std::vector<std::string> includes_vec; // for processing
    std::map<std::string, std::string> include_guards; // header -> condition
    std::string includes; // final rendered includes for mustache
    bool hash_specialization = false;
    bool formatter_specialization = false;
    std::string full_qualified_name;
    bool subscript_operator = false;
    bool has_default_value = false;
    std::string default_initializer = "{}";
    std::string const_expr = "constexpr ";
    std::string hash_const_expr = "constexpr ";
    bool iterator_support_member = false;
    bool template_assignment_operator = false;
    std::vector<CastOperator> explicit_cast_operators;
    std::vector<CastOperator> implicit_cast_operators;
    StrongTypeDescription desc;
};
BOOST_DESCRIBE_STRUCT(
    ClassInfo,
    (),
    (class_namespace,
     namespace_open,
     namespace_close,
     full_class_name,
     class_name,
     underlying_type,
     arithmetic_binary_operators,
     unary_operators,
     indirection_operator,
     addressof_operators,
     spaceship_operator,
     defaulted_equality_operator,
     relational_operators,
     ostream_operator,
     istream_operator,
     bool_operator,
     nullary,
     callable,
     public_specifier,
     logical_not_operator,
     logical_operators,
     includes,
     increment_operators,
     hash_specialization,
     formatter_specialization,
     full_qualified_name,
     subscript_operator,
     has_default_value,
     default_initializer,
     const_expr,
     hash_const_expr,
     iterator_support_member,
     template_assignment_operator,
     explicit_cast_operators,
     implicit_cast_operators,
     desc))

constexpr auto arithmetic_binary_op_tags = std::to_array<std::string_view>(
    {"+", "-", "*", "/", "%", "&", "|", "^", "<<", ">>", "+*", "-*"});
constexpr auto arithmetic_unary_operators = std::to_array<std::string_view>(
    {"u+", "u-", "u~", "~"});
constexpr auto relational_operators = std::to_array<std::string_view>(
    {"==", "!=", "<=", ">=", "<", ">"});

constexpr bool
is_arithmetic_binary_operator(std::string_view sv)
{
    return std::find(
               arithmetic_binary_op_tags.begin(),
               arithmetic_binary_op_tags.end(),
               sv) != arithmetic_binary_op_tags.end();
}

constexpr bool
is_arithmetic_unary_operator(std::string_view sv)
{
    return std::find(
               arithmetic_unary_operators.begin(),
               arithmetic_unary_operators.end(),
               sv) != arithmetic_unary_operators.end();
}

constexpr bool
is_relational_operator(std::string_view sv)
{
    return std::find(
               relational_operators.begin(),
               relational_operators.end(),
               sv) != relational_operators.end();
}

// Default predicate for strip - checks if character is whitespace
struct IsSpacePred
{
    bool operator () (unsigned char u) const
    {
        return std::isspace(static_cast<int>(u));
    }
};

// Check for redundant operators when spaceship is present
void
check_for_redundant_operators(
    bool has_spaceship,
    bool has_equality_ops,
    bool has_relational_ops,
    ClassInfo const & info,
    std::vector<StrongTypeGenerator::Warning> * warnings)
{
    if (not has_spaceship || not warnings) {
        return;
    }

    auto type_name = info.class_namespace.empty()
        ? info.full_class_name
        : info.class_namespace + "::" + info.full_class_name;

    if (has_equality_ops) {
        warnings->push_back(
            {.message = "Operator '<=>' makes '==' and '!=' redundant. "
                        "Consider removing '==' and '!=' from the description.",
             .type_name = type_name});
    }

    if (has_relational_ops) {
        warnings->push_back(
            {.message =
                 "Operator '<=>' makes '<', '<=', '>', '>=' redundant. "
                 "Consider removing these operators from the description.",
             .type_name = type_name});
    }
}

template <typename PredT = IsSpacePred>
std::string_view
strip(std::string_view sv, PredT pred = PredT{})
{
    auto result = sv;
    while (not result.empty() &&
           pred(static_cast<unsigned char>(result.front())))
    {
        result.remove_prefix(1);
    }
    while (not result.empty() &&
           pred(static_cast<unsigned char>(result.back())))
    {
        result.remove_suffix(1);
    }
    return result;
}

std::vector<std::string_view>
split(std::string_view sv, char sep)
{
    std::vector<std::string_view> components;
    while (not sv.empty()) {
        while (not sv.empty() && std::isspace(sv.front())) {
            sv.remove_prefix(1);
        }
        auto n = std::min(sv.find(sep), sv.size());
        components.push_back(strip(sv.substr(0, n)));
        sv.remove_prefix(std::min(n + 1, sv.size()));
    }
    return components;
}

inline constexpr auto stripns = [](auto sv) {
    return strip(sv, [](unsigned char c) { return c == ':'; });
};

// Parse cast<Type>, explicit_cast<Type>, or implicit_cast<Type> syntax
// Returns the type name if valid cast syntax, empty string otherwise
std::string
parse_cast_syntax(std::string_view token, bool & is_implicit)
{
    constexpr std::string_view prefix_implicit = "implicit_cast<";
    constexpr std::string_view prefix_explicit = "explicit_cast<";
    constexpr std::string_view prefix_cast = "cast<";

    // Determine which prefix matches (check longest first)
    std::string_view prefix;
    if (token.starts_with(prefix_implicit)) {
        is_implicit = true;
        prefix = prefix_implicit;
    } else if (token.starts_with(prefix_explicit)) {
        is_implicit = false;
        prefix = prefix_explicit;
    } else if (token.starts_with(prefix_cast)) {
        is_implicit = false;
        prefix = prefix_cast;
    } else {
        // Not a cast operator
        return "";
    }

    // Extract type between < and >
    auto start = prefix.length();
    auto end = token.find_last_of('>');
    if (end == std::string_view::npos || end <= start) {
        throw std::invalid_argument(
            "Invalid " + std::string(prefix.substr(0, prefix.length() - 1)) +
            "> syntax: " + std::string(token));
    }
    return std::string(strip(token.substr(start, end - start)));
}

// Expand nested namespaces for C++11 compatibility
// Input: "foo::bar::baz"
// Returns: {opening: "namespace foo {\nnamespace bar {\nnamespace baz {",
//           closing: "} // namespace baz\n} // namespace bar\n} // namespace
//           foo"}
std::pair<std::string, std::string>
expand_namespace(std::string const & ns)
{
    if (ns.empty()) {
        return {"", ""};
    }

    // Split namespace by "::"
    std::vector<std::string> parts;
    std::string_view sv = ns;
    while (not sv.empty()) {
        auto pos = sv.find("::");
        if (pos == std::string_view::npos) {
            parts.emplace_back(sv);
            break;
        }
        parts.emplace_back(sv.substr(0, pos));
        sv.remove_prefix(pos + 2);
    }

    // Build opening
    std::string opening;
    for (auto const & part : parts) {
        opening += "namespace ";
        opening += part;
        opening += " {\n";
    }

    // Build closing (in reverse order)
    std::string closing;
    for (auto it = parts.rbegin(); it != parts.rend(); ++it) {
        closing += "} // namespace ";
        closing += *it;
        closing += "\n";
    }

    return {opening, closing};
}

ClassInfo
parse(
    StrongTypeDescription const & desc,
    std::vector<StrongTypeGenerator::Warning> * warnings)
{
    ClassInfo info;
    info.desc = desc;
    info.class_namespace = stripns(desc.type_namespace);

    // Expand nested namespaces for C++11 compatibility
    auto [ns_open, ns_close] = expand_namespace(info.class_namespace);
    info.namespace_open = ns_open;
    info.namespace_close = ns_close;

    info.full_class_name = stripns(desc.type_name);
    info.class_name = [&] {
        if (auto n = info.full_class_name.rfind(':');
            n < info.full_class_name.size())
        {
            return info.full_class_name.substr(n + 1);
        }
        return info.full_class_name;
    }();
    if (desc.kind == "class") {
        info.public_specifier = "public:";
    } else if (desc.kind != "struct") {
        throw std::invalid_argument("kind must be either class or struct");
    }

    // Track which operators are specified for redundancy detection
    bool has_spaceship = false;
    bool has_equality_ops = false;
    bool has_relational_ops = false;

    for (auto s : split(desc.description, ';')) {
        if (s.starts_with("strong ")) {
            s.remove_prefix(7);
            info.underlying_type = s;
        } else {
            for (auto sv : split(s, ',')) {
                if (sv.empty()) {
                    continue; // Skip empty tokens from trailing commas
                }

                bool recognized = false;

                if (is_arithmetic_binary_operator(sv)) {
                    recognized = true;
                    if (sv.size() > 1u && sv[1] == '*') {
                        sv.remove_suffix(1);
                        info.arithmetic_binary_operators.emplace_back(sv);
                        info.unary_operators.emplace_back(sv);
                    } else {
                        info.arithmetic_binary_operators.emplace_back(sv);
                    }
                }
                if (is_arithmetic_unary_operator(sv)) {
                    recognized = true;
                    if (sv.size() > 1u) {
                        sv.remove_prefix(1);
                    }
                    info.unary_operators.emplace_back(sv);
                } else if (sv == "!" || sv == "not") {
                    recognized = true;
                    info.logical_not_operator = true;
                } else if (sv == "||" || sv == "or") {
                    recognized = true;
                    info.logical_operators.emplace_back("or");
                } else if (sv == "&&" || sv == "and") {
                    recognized = true;
                    info.logical_operators.emplace_back("and");
                } else if (sv == "++" || sv == "--") {
                    recognized = true;
                    info.increment_operators.emplace_back(sv);
                } else if (sv == "@") {
                    recognized = true;
                    info.indirection_operator = indirection_operator_template;
                } else if (sv == "&of") {
                    recognized = true;
                    info.addressof_operators.emplace_back("&");
                    info.includes_vec.push_back("<memory>");
                } else if (sv == "->") {
                    recognized = true;
                    info.addressof_operators.emplace_back(sv);
                    info.includes_vec.push_back("<memory>");
                } else if (sv == "<=>") {
                    recognized = true;
                    has_spaceship = true;
                    info.spaceship_operator = true;
                    info.includes_vec.push_back("<compare>");
                } else if (is_relational_operator(sv)) {
                    recognized = true;
                    if (sv == "==" || sv == "!=") {
                        has_equality_ops = true;
                    } else {
                        has_relational_ops = true;
                    }
                    info.relational_operators.emplace_back(sv);
                } else if (sv == "out") {
                    recognized = true;
                    info.ostream_operator = true;
                    info.includes_vec.push_back("<ostream>");
                } else if (sv == "in") {
                    recognized = true;
                    info.istream_operator = true;
                    info.includes_vec.push_back("<istream>");
                } else if (sv == "bool") {
                    recognized = true;
                    info.bool_operator = bool_operator_template;
                } else if (sv == "()") {
                    recognized = true;
                    info.nullary = true;
                } else if (sv == "(&)") {
                    recognized = true;
                    info.callable = true;
                    info.includes_vec.push_back("<utility>");
                    info.includes_vec.push_back("<functional>");
                } else if (sv == "[]") {
                    recognized = true;
                    info.subscript_operator = true;
                } else if (sv == "hash") {
                    recognized = true;
                    info.hash_specialization = true;
                    info.includes_vec.push_back("<functional>");
                } else if (sv == "no-constexpr-hash") {
                    recognized = true;
                    info.hash_specialization = true;
                    info.hash_const_expr = "";
                    info.includes_vec.push_back("<functional>");
                } else if (sv == "iterable") {
                    recognized = true;
                    info.desc.generate_iterators = true;
                } else if (sv == "fmt") {
                    recognized = true;
                    info.desc.generate_formatter = true;
                    info.includes_vec.push_back("<format>");
                    info.include_guards["<format>"] =
                        "defined(__cpp_lib_format) && __cpp_lib_format >= "
                        "202110L";
                } else if (sv == "assign") {
                    recognized = true;
                    info.desc.generate_template_assignment = true;
                    info.includes_vec.push_back("<concepts>");
                    info.include_guards["<concepts>"] =
                        "defined(__cpp_concepts) && __cpp_concepts >= 201907L";
                } else if (sv == "no-constexpr") {
                    recognized = true;
                    info.const_expr = "";
                    info.hash_const_expr = "";
                } else if (sv.starts_with('#')) {
                    recognized = true;
                    auto str = std::string(strip(sv.substr(1)));
                    for (auto & c : str) {
                        if (c == '\'') {
                            c = '"';
                        }
                    }
                    info.includes_vec.push_back(std::move(str));
                }

                // Try to parse as cast operator
                if (not recognized) {
                    bool is_implicit = false;
                    std::string cast_type = parse_cast_syntax(sv, is_implicit);

                    if (not cast_type.empty()) {
                        recognized = true;
                        if (is_implicit) {
                            info.desc.implicit_casts.push_back(
                                std::move(cast_type));
                        } else {
                            info.desc.explicit_casts.push_back(
                                std::move(cast_type));
                        }
                    }
                }

                if (not recognized) {
                    throw std::invalid_argument(
                        "Unrecognized operator or option in description: '" +
                        std::string(sv) + "'");
                }
            }
        }
    }

    // Check for redundant operators with spaceship
    check_for_redundant_operators(
        has_spaceship,
        has_equality_ops,
        has_relational_ops,
        info,
        warnings);

    // Handle spaceship operator + equality operator defaulting
    if (has_spaceship) {
        // If spaceship is alone (no other relational operators), auto-generate
        // defaulted operator==
        if (not has_equality_ops && not has_relational_ops) {
            info.defaulted_equality_operator = true;
        }
        // If spaceship is with equality operators (== or !=), use defaulted
        // operator== instead of hand-written
        else if (has_equality_ops)
        {
            info.defaulted_equality_operator = true;
            // Remove == and != from relational_operators since we'll use
            // defaulted version
            info.relational_operators.erase(
                std::remove_if(
                    info.relational_operators.begin(),
                    info.relational_operators.end(),
                    [](auto const & op) {
                        return op.op == "==" || op.op == "!=";
                    }),
                info.relational_operators.end());
        }
    }

    // Handle default_value from the StrongTypeDescription
    if (not desc.default_value.empty()) {
        info.has_default_value = true;
        info.default_initializer = "{" + desc.default_value + "}";
    }

    // Try to deduce some of the standard header file locations
    std::vector<std::pair<std::string_view, std::string_view>> equals = {
        {"std::any", "<any>"},
        {"std::string", "<string>"},
        {"std::string_view", "<string_view>"},
        {"std::regex", "<regex>"},
        {"std::condition_variable", "<condition_variable>"},
        {"std::condition_variable_any", "<condition_variable>"},
        {"std::latch", "<latch>"},
        {"std::mutex", "<mutex>"},
        {"std::recursive_mutex", "<mutex>"},
        {"std::timed_mutex", "<mutex>"},
        {"std::recursive_timed_mutex", "<mutex>"},
        {"std::shared_mutex", "<shared_mutex>"},
        {"std::shared_timed_mutex", "<shared_mutex>"},
        {"std::binary_semaphore", "<semaphore>"},
        {"std::stop_token", "<stop_token>"},
        {"std::stop_source", "<stop_token>"},
        {"std::thread", "<thread>"},
        {"std::jthread", "<thread>"},
        {"std::thread_id", "<thread>"},
    };
    if (auto i = std::find_if(
            equals.begin(),
            equals.end(),
            [&](auto const & p) { return p.first == info.underlying_type; });
        i != equals.end())
    {
        info.includes_vec.emplace_back(i->second);
    }
    std::vector<std::pair<std::string_view, std::string_view>> starts_with = {
        {"std::bitset<", "<bitset>"},
        {"std::chrono::", "<chrono>"},
        {"std::optional<", "<optional>"},
        {"std::tuple<", "<tuple>"},
        {"std::variant<", "<variant>"},
        {"std::basic_string<", "<string>"},
        {"std::basic_string_view<", "<string>"},
        {"std::array<", "<array>"},
        {"std::deque<", "<deque>"},
        {"std::list<", "<list>"},
        {"std::map<", "<map>"},
        {"std::queue<", "<queue>"},
        {"std::set<", "<set>"},
        {"std::span<", "<span>"},
        {"std::unordered_map<", "<unordered_map>"},
        {"std::unordered_set<", "<unordered_set>"},
        {"std::vector<", "<vector>"},
        {"std::filesystem::<", "<filesystem>"},
        {"std::basic_regex<", "<regex>"},
        {"std::atomic<", "<atomic>"},
        {"std::atomic_", "<atomic>"},
        {"std::barrier<", "<barrier>"},
        {"std::counting_semaphore<", "<semaphore>"},
        {"std::stop_callback<", "<stop_token>"},
    };
    if (auto i = std::find_if(
            starts_with.begin(),
            starts_with.end(),
            [&](auto const & p) {
                return info.underlying_type.starts_with(p.first);
            });
        i != starts_with.end())
    {
        info.includes_vec.emplace_back(i->second);
    }

    // Add standard includes that are always needed
    info.includes_vec.push_back("<type_traits>");
    info.includes_vec.push_back("<utility>");

    // Sort and uniquify the includes vector
    std::sort(info.includes_vec.begin(), info.includes_vec.end());
    info.includes_vec.erase(
        std::unique(info.includes_vec.begin(), info.includes_vec.end()),
        info.includes_vec.end());
    info.includes_vec.erase(
        std::find(
            info.includes_vec.begin(),
            info.includes_vec.end(),
            "<version>"),
        info.includes_vec.end());

    // Build the final includes string with guards
    std::ostringstream includes_stream;
    for (auto const & include : info.includes_vec) {
        auto guard_it = info.include_guards.find(include);
        if (guard_it != info.include_guards.end()) {
            includes_stream << "#if " << guard_it->second << '\n';
            includes_stream << "#include " << include << '\n';
            includes_stream << "#endif // " << guard_it->second << '\n';
        } else {
            includes_stream << "#include " << include << '\n';
        }
    }
    info.includes = includes_stream.str();
    for (auto * c :
         {&info.arithmetic_binary_operators,
          &info.unary_operators,
          &info.addressof_operators,
          &info.relational_operators,
          &info.logical_operators,
          &info.increment_operators})
    {
        std::sort(c->begin(), c->end());
    }

    // Build fully qualified name for hash and formatter specializations
    if (info.hash_specialization || info.desc.generate_formatter) {
        if (not info.class_namespace.empty()) {
            info.full_qualified_name = info.class_namespace +
                "::" + info.full_class_name;
        } else {
            info.full_qualified_name = info.full_class_name;
        }
    }

    // Enable iterator support if requested
    if (info.desc.generate_iterators) {
        info.iterator_support_member = true;
    }

    // Enable formatter specialization if requested
    if (info.desc.generate_formatter) {
        info.formatter_specialization = true;
    }

    // Enable template assignment operator if requested
    if (info.desc.generate_template_assignment) {
        info.template_assignment_operator = true;
    }

    // Populate cast operator vectors
    // Filter out explicit casts that are also in implicit casts
    // (implicit cast supersedes explicit cast for the same type)
    for (auto const & cast_type : info.desc.explicit_casts) {
        if (std::find(
                info.desc.implicit_casts.begin(),
                info.desc.implicit_casts.end(),
                cast_type) == info.desc.implicit_casts.end())
        {
            info.explicit_cast_operators.emplace_back(cast_type);
        }
    }

    for (auto const & cast_type : info.desc.implicit_casts) {
        info.implicit_cast_operators.emplace_back(cast_type);
    }

    return info;
}

std::string
render_code(ClassInfo const & info)
{
    std::stringstream strm;
    boost::mustache::render(
        strong_template,
        strm,
        info,
        {{"arithmetic_binary_operators", arithmetic_binary_operators},
         {"unary_operators", unary_operators},
         {"addressof_operators", addressof_operators},
         {"relational_operator", relational_operator},
         {"logical_operator", logical_operator},
         {"bool_operator", bool_operator_template},
         {"explicit_cast_operator", explicit_cast_operator_template},
         {"implicit_cast_operator", implicit_cast_operator_template},
         {"indirection_operator", indirection_operator_template},
         {"nullary", nullary_template},
         {"callable", callable_template},
         {"subscript_operator", subscript_operator_template},
         {"iterator_support_member", iterator_support_template},
         {"template_assignment_operator",
          template_assignment_operator_template},
         {"logical_not_operator", logical_not_template},
         {"spaceship_operator", spaceship_operator_template},
         {"defaulted_equality_operator", defaulted_equality_operator_template},
         {"ostream_operator", ostream_operator_template},
         {"istream_operator", istream_operator_template},
         {"increment_operator", increment_operator},
         {"hash_specialization", hash_specialization_template},
         {"formatter_specialization", formatter_specialization_template}});
    return strm.str();
}

std::string
make_guard(StrongTypeDescription const & desc, std::string const & code)
{
    std::string result;
    if (not desc.guard_prefix.empty()) {
        result = desc.guard_prefix;
    } else {
        char prev = '\0';
        for (char c : [&] {
                 auto r = std::string(stripns(desc.type_namespace));
                 r += "::";
                 r += stripns(desc.type_name);
                 return r;
             }())
        {
            if (c == ':') {
                if (prev != ':') {
                    result += desc.guard_separator;
                }
            } else {
                result += c;
            }
            prev = c;
        }
    }
    result += desc.guard_separator;
    result += get_sha1(code);
    if (desc.upcase_guard) {
        std::transform(
            result.begin(),
            result.end(),
            result.begin(),
            [](unsigned char c) { return std::toupper(c); });
    }
    return result;
}

} // anonymous namespace

std::string
StrongTypeGenerator::
operator () (StrongTypeDescription const & desc)
{
    auto const info = parse(desc, &warnings_);
    auto const code = render_code(info);
    auto const guard = make_guard(desc, code);
    std::stringstream strm;
    strm << "#ifndef " << guard << '\n'
        << "#define " << guard << "\n\n"
        << make_notice_banner() << '\n'
        << R"(#if __has_include(<version>)
#include <version>
#endif)" << '\n'
        << preamble() << code << "#endif // " << guard << '\n';
    return strm.str();
}

std::string
generate_strong_types_file(
    std::vector<StrongTypeDescription> const & descriptions,
    std::string const & guard_prefix,
    std::string const & guard_separator,
    bool upcase_guard)
{
    std::set<std::string> all_includes;
    std::map<std::string, std::string> all_guards;
    std::ostringstream combined_code;
    std::vector<StrongTypeGenerator::Warning> warnings;

    // Generate each type WITHOUT preamble, and collect includes
    for (auto const & desc : descriptions) {
        auto info = parse(desc, &warnings);

        // Collect includes and guards from this type
        for (auto const & include : info.includes_vec) {
            all_includes.insert(include);
        }
        for (auto const & [header, guard] : info.include_guards) {
            all_guards[header] = guard;
        }

        // Clear includes from info since we're hoisting them to the top
        info.includes.clear();

        // Generate just the type code (no preamble, no header guards, no
        // includes)
        combined_code << render_code(info);
    }

    // Output warnings to stderr
    print_warnings(warnings);

    // Generate header guard with SHA of combined content
    std::string content = combined_code.str();

    // Create a temporary description for guard generation
    StrongTypeDescription temp_desc{
        .kind = "struct",
        .type_namespace = "foo",
        .type_name = "Bar",
        .description = "string int; ->",
        .guard_prefix = guard_prefix,
        .guard_separator = guard_separator,
        .upcase_guard = upcase_guard};
    std::string guard = make_guard(temp_desc, content);

    // Build final output
    std::ostringstream output;

    // Add header guard first, then NOTICE banner
    output << "#ifndef " << guard << '\n'
        << "#define " << guard << "\n\n"
        << make_notice_banner() << '\n'
        << R"(#if __has_include(<version>)
#include <version>
#endif
)";

    // Remove <compare> from top-level includes since it's already
    // conditionally included in the preamble
    all_includes.erase("<compare>");
    all_includes.erase("<version>");

    // Add all unique includes with guards
    for (auto const & include : all_includes) {
        auto guard_it = all_guards.find(include);
        if (guard_it != all_guards.end()) {
            output << "#if " << guard_it->second << '\n';
            output << "#include " << include << '\n';
            output << "#endif\n";
        } else {
            output << "#include " << include << '\n';
        }
    }
    if (not all_includes.empty()) {
        output << '\n';
    }

    // Add strong_type_tag definition once for the entire file
    output << preamble();
    output << content << "#endif // " << guard << '\n';

    return output.str();
}

}} // namespace wjh::atlas::v1
