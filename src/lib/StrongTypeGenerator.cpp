// ----------------------------------------------------------------------
// Copyright 2025 Jody Hagins
// Distributed under the MIT Software License
// See accompanying file LICENSE or copy at
// https://opensource.org/licenses/MIT
// ----------------------------------------------------------------------
#include "AtlasUtilities.hpp"
#include "StrongTypeGenerator.hpp"
#include "version.hpp"

#include <boost/describe.hpp>
#include <boost/json/src.hpp>
#include <boost/mustache.hpp>
#include <boost/uuid/detail/sha1.hpp>

#include <algorithm>
#include <array>
#include <filesystem>
#include <map>
#include <set>
#include <sstream>
#include <string>
#include <string_view>

#include <iostream>

namespace wjh::atlas { inline namespace v1 {


BOOST_DESCRIBE_STRUCT(
    StrongTypeDescription,
    (),
    (kind,
     type_namespace,
     type_name,
     description,
     default_value,
     guard_prefix,
     guard_separator,
     upcase_guard,
     generate_iterators,
     generate_formatter,
     cpp_standard))

namespace {

// Print warnings to stderr with optional color
void
print_warnings(std::vector<StrongTypeGenerator::Warning> const & warnings)
{
    if (warnings.empty()) {
        return;
    }

    bool use_color = supports_color(fileno(stderr));

    std::cerr << "\n";
    if (use_color) {
        std::cerr << color::red << "Warnings:" << color::reset << "\n";
        for (auto const & w : warnings) {
            std::cerr << "  " << color::yellow << w.type_name << ": "
                << w.message << color::reset << "\n";
        }
    } else {
        std::cerr << "Warnings:\n";
        for (auto const & w : warnings) {
            std::cerr << "  " << w.type_name << ": " << w.message << "\n";
        }
    }
    std::cerr << std::endl;
}

std::string
get_sha1(std::string const & s)
{
    boost::uuids::detail::sha1 sha1;
    sha1.process_bytes(s.data(), s.size());
    boost::uuids::detail::sha1::digest_type hash;
    sha1.get_digest(hash);

    std::string result;
    for (unsigned int x : hash) {
        char buffer[64];
        snprintf(buffer, sizeof(buffer), "%08x", x);
        result += buffer;
    }
    return result;
}

std::string
make_notice_banner()
{
    static constexpr char const b1[] = R"(
// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v)";
    std::ostringstream banner;
    banner << (b1 + 1) << codegen::version_string << R"(
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================
)";
    return banner.str();
}

auto strong_template = R"(
{{#namespace_open}}
{{{.}}}{{/namespace_open}}
/**
 * @brief Strong type wrapper for {{{underlying_type}}}
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: {{{desc.kind}}}
 * - type_namespace: {{{desc.type_namespace}}}
 * - type_name: {{{desc.type_name}}}
 * - description: {{{desc.description}}}
 * - default_value: "{{{desc.default_value}}}"
 */
{{{desc.kind}}} {{{full_class_name}}}
: private atlas::strong_type_tag
{
{{#has_default_value}}
    {{{underlying_type}}} value{{{default_initializer}}};
{{/has_default_value}}
{{^has_default_value}}
    {{{underlying_type}}} value;
{{/has_default_value}}

{{#public_specifier}}
{{{.}}}
{{/public_specifier}}
    using atlas_value_type = {{{underlying_type}}};
{{#has_constraint}}
    using atlas_constraint = atlas::constraints::{{{constraint_type}}}{{{constraint_template_args}}};
{{/has_constraint}}
{{#constants}}
{{>constant_declarations}}
{{/constants}}

    {{{const_expr}}}explicit {{{class_name}}}() = default;
    {{{const_expr}}}{{{class_name}}}({{{class_name}}} const &) = default;
    {{{const_expr}}}{{{class_name}}}({{{class_name}}} &&) = default;
    {{{const_expr}}}{{{class_name}}} & operator = ({{{class_name}}} const &) = default;
    {{{const_expr}}}{{{class_name}}} & operator = ({{{class_name}}} &&) = default;
    {{{const_expr}}}~{{{class_name}}}() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<{{{underlying_type}}}, ArgTs...>::value,
            bool>::type = true>
    {{{const_expr}}}explicit {{{class_name}}}(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...){{#has_constraint}}
    {
        if (!atlas_constraint::check(value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: {{{constraint_message}}}");
        }
    }{{/has_constraint}}{{^has_constraint}}
    { }{{/has_constraint}}
    {{#template_assignment_operator}}
    {{>template_assignment_operator}}
    {{/template_assignment_operator}}

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    {{{const_expr}}}explicit operator {{{underlying_type}}} const & () const { return value; }
    {{{const_expr}}}explicit operator {{{underlying_type}}} & () { return value; }
    {{#explicit_cast_operators}}
    {{>explicit_cast_operator}}
    {{/explicit_cast_operators}}
    {{#implicit_cast_operators}}
    {{>implicit_cast_operator}}
    {{/implicit_cast_operators}}
    {{#bool_operator}}
    {{>bool_operator}}
    {{/bool_operator}}
    {{#indirection_operator}}
    {{>indirection_operator}}
    {{/indirection_operator}}
    {{#addressof_operators}}
    {{>addressof_operators}}
    {{/addressof_operators}}
    {{#arrow_operator}}
    {{>arrow_operator}}
    {{/arrow_operator}}
    {{#nullary}}
    {{>nullary}}
    {{/nullary}}
    {{#callable}}
    {{>callable}}
    {{/callable}}
    {{#subscript_operator}}
    {{>subscript_operator}}
    {{/subscript_operator}}
    {{#iterator_support_member}}
    {{>iterator_support_member}}
    {{/iterator_support_member}}
    {{#forwarded_memfns}}
    {{>forwarded_memfn}}
    {{/forwarded_memfns}}
    {{#unary_operators}}
    {{>unary_operators}}
    {{/unary_operators}}
    {{#logical_not_operator}}
    {{>logical_not_operator}}
    {{/logical_not_operator}}
    {{#logical_operators}}
    {{>logical_operator}}
    {{/logical_operators}}
    {{#increment_operators}}
    {{>increment_operator}}
    {{/increment_operators}}
    {{#arithmetic_binary_operators}}
    {{>arithmetic_binary_operators}}
    {{/arithmetic_binary_operators}}
    {{#spaceship_operator}}
    {{>spaceship_operator}}
    {{/spaceship_operator}}
    {{#defaulted_equality_operator}}
    {{>defaulted_equality_operator}}
    {{/defaulted_equality_operator}}
    {{#relational_operators}}
    {{>relational_operator}}
    {{/relational_operators}}
    {{#ostream_operator}}
    {{>ostream_operator}}
    {{/ostream_operator}}
    {{#istream_operator}}
    {{>istream_operator}}
    {{/istream_operator}}
};
{{#constants}}

{{>constants}}
{{/constants}}
{{#namespace_close}}
{{{.}}}{{/namespace_close}}
{{#hash_specialization}}
{{>hash_specialization}}
{{/hash_specialization}}
{{#formatter_specialization}}
{{>formatter_specialization}}
{{/formatter_specialization}}
)";

// Template for constant declarations inside the class
// Use 'static const' (not constexpr) because type is incomplete at this point
constexpr char constant_declarations_template[] = R"(
    static const {{{class_name}}} {{{name}}};
)";

// Template for constant definitions after the class
// Use 'inline constexpr' to make them usable in constexpr contexts
// This is standard-compliant: declare as 'const', define as 'constexpr'
constexpr char constants_template[] = R"(
inline {{{const_qualifier}}}{{{full_qualified_name}}} {{{full_qualified_name}}}::{{{name}}} = {{{full_qualified_name}}}({{{value}}});
)";

constexpr char addressof_operators[] = R"(
    /**
     * Access a pointer to the wrapped object.
     */
    {{{const_expr}}}{{{underlying_type}}} const * operator {{{op}}} () const
    noexcept
    {
        return std::addressof(value);
    }
    {{{const_expr}}}{{{underlying_type}}} * operator {{{op}}} ()
    noexcept
    {
        return std::addressof(value);
    }
)";

constexpr char arrow_operator_template[] = R"(
    /**
     * Arrow operator - forwards to wrapped type if it's a pointer or
     * pointer-like, otherwise returns pointer to wrapped value.
     *
     * pointer types: returns the pointer itself (built-in -> handles the rest)
     * pointer-like types (smart pointers): returns value.operator->()
     * other types: returns &value
     */
    template <typename T = atlas::atlas_detail::const_>
    {{{const_expr}}}auto operator -> () const
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    template <typename T = atlas::atlas_detail::mutable_>
    {{{const_expr}}}auto operator -> ()
    -> decltype(atlas::atlas_detail::arrow_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::arrow_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }
)";

constexpr char relational_operator[] = R"(
    /**
     * Is @p lhs.value {{{op}}} @p rhs.value?
     */
    friend {{{const_expr}}}bool operator {{{op}}} (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const&>() {{{op}}} std::declval<{{{underlying_type}}} const&>()))
    {
        return lhs.value {{{op}}} rhs.value;
    }
)";

constexpr char arithmetic_binary_operators[] = R"__(
    /**
     * Apply {{{op}}} assignment to the wrapped objects.
     */
    friend {{{const_expr}}}{{{class_name}}} & operator {{{op}}}= (
        {{{class_name}}} & lhs,
        {{{class_name}}} const & rhs)
{{^has_constraint}}
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunevaluated-expression"
#endif
    noexcept(noexcept(std::declval<{{{underlying_type}}} &>() {{{op}}}= std::declval<{{{underlying_type}}} const &>()))
#if defined(__clang__)
#pragma clang diagnostic pop
#endif
{{/has_constraint}}
    {
        lhs.value {{{op}}}= rhs.value;
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
    /**
     * Apply the binary operator {{{op}}} to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}} operator {{{op}}} (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(lhs {{{op}}}= rhs))
    {
        lhs {{{op}}}= rhs;
        return lhs;
    }
)__";

constexpr char checked_addition[] = R"__(
    /**
     * @brief Checked addition - throws on overflow
     * @throws atlas::CheckedOverflowError if result would overflow
     * @throws atlas::CheckedUnderflowError if result would underflow (signed only)
     */
    friend {{{class_name}}} operator + (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
    {
        lhs.value = atlas::atlas_detail::checked_add(
            lhs.value,
            rhs.value,
            "{{{full_qualified_name}}}: addition overflow",
            "{{{full_qualified_name}}}: addition underflow");
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
)__";

constexpr char checked_subtraction[] = R"__(
    /**
     * @brief Checked subtraction - throws on overflow/underflow
     * @throws atlas::CheckedOverflowError if result would overflow
     * @throws atlas::CheckedUnderflowError if result would underflow
     */
    friend {{{class_name}}} operator - (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
    {
        lhs.value = atlas::atlas_detail::checked_sub(
            lhs.value,
            rhs.value,
            "{{{full_qualified_name}}}: subtraction overflow",
            "{{{full_qualified_name}}}: subtraction underflow");
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
)__";

constexpr char checked_multiplication[] = R"__(
    /**
     * @brief Checked multiplication - throws on overflow
     * @throws atlas::CheckedOverflowError if result would overflow
     * @throws atlas::CheckedUnderflowError if result would underflow (signed only)
     */
    friend {{{class_name}}} operator * (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
    {
        lhs.value = atlas::atlas_detail::checked_mul(
            lhs.value,
            rhs.value,
            "{{{full_qualified_name}}}: multiplication overflow",
            "{{{full_qualified_name}}}: multiplication underflow");
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
)__";

constexpr char checked_division[] = R"__(
    /**
     * @brief Checked division - throws on division by zero and overflow
     * @throws atlas::CheckedDivisionByZeroError if divisor is zero
     * @throws atlas::CheckedOverflowError if result would overflow (INT_MIN / -1)
     */
    friend {{{class_name}}} operator / (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
    {
        lhs.value = atlas::atlas_detail::checked_div(
            lhs.value,
            rhs.value,
            "{{{full_qualified_name}}}: division by zero",
            "{{{full_qualified_name}}}: division overflow (INT_MIN / -1)");
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
)__";

constexpr char checked_modulo[] = R"__(
    /**
     * @brief Checked modulo - throws on division by zero
     * @throws atlas::CheckedDivisionByZeroError if divisor is zero
     * @note Modulo is only defined for integral types
     */
    friend {{{class_name}}} operator % (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
    {
        lhs.value = atlas::atlas_detail::checked_mod(
            lhs.value,
            rhs.value,
            "{{{full_qualified_name}}}: modulo by zero");
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
)__";

constexpr char saturating_addition[] = R"__(
    /**
     * @brief Saturating addition - clamps to type limits
     * @note noexcept - overflow/underflow clamps to limits instead of throwing
     */
    friend {{{class_name}}} operator + (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
{{^has_constraint}}
    noexcept
{{/has_constraint}}
    {
        lhs.value = atlas::atlas_detail::saturating_add(lhs.value, rhs.value);
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
)__";

constexpr char saturating_subtraction[] = R"__(
    /**
     * @brief Saturating subtraction - clamps to type limits
     * @note noexcept - overflow/underflow clamps to limits instead of throwing
     */
    friend {{{class_name}}} operator - (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
{{^has_constraint}}
    noexcept
{{/has_constraint}}
    {
        lhs.value = atlas::atlas_detail::saturating_sub(lhs.value, rhs.value);
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
)__";

constexpr char saturating_multiplication[] = R"__(
    /**
     * @brief Saturating multiplication - clamps to type limits
     * @note noexcept - overflow/underflow clamps to limits instead of throwing
     */
    friend {{{class_name}}} operator * (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
{{^has_constraint}}
    noexcept
{{/has_constraint}}
    {
        lhs.value = atlas::atlas_detail::saturating_mul(lhs.value, rhs.value);
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
)__";

constexpr char saturating_division[] = R"__(
    /**
     * @brief Saturating division - clamps to type limits
     * @note noexcept - overflow/underflow clamps to limits instead of throwing
     */
    friend {{{class_name}}} operator / (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
{{^has_constraint}}
    noexcept
{{/has_constraint}}
    {
        lhs.value = atlas::atlas_detail::saturating_div(lhs.value, rhs.value);
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
)__";

constexpr char saturating_remainder[] = R"__(
    /**
     * @brief Saturating remainder - returns 0 for undefined operations
     * @note noexcept - modulo by zero returns 0 instead of throwing
     * @note Modulo is only defined for integral types
     */
    friend {{{class_name}}} operator % (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
{{^has_constraint}}
    noexcept
{{/has_constraint}}
    {
        lhs.value = atlas::atlas_detail::saturating_rem(lhs.value, rhs.value);
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
)__";

constexpr char wrapping_arithmetic[] = R"__(
    /**
     * @brief Wrapping arithmetic - explicit, well-defined overflow
     * @note Marked noexcept - overflow is intentional and well-defined
     * @note Uses unsigned arithmetic to avoid UB for signed integer overflow
     * @note Only available for integral types
     */
    friend {{{class_name}}} operator {{{op}}} (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
{{^has_constraint}}
    noexcept
{{/has_constraint}}
    {
        static_assert(std::is_integral<{{{underlying_type}}}>::value,
                      "Wrapping arithmetic is only supported for integral types");
        using unsigned_type = typename std::make_unsigned<{{{underlying_type}}}>::type;
        lhs.value = static_cast<{{{underlying_type}}}>(
            static_cast<unsigned_type>(lhs.value) {{{op}}}
            static_cast<unsigned_type>(rhs.value)
        );
{{#has_constraint}}
        if (!atlas_constraint::check(lhs.value)) {
            throw atlas::ConstraintError(
                "{{{class_name}}}: arithmetic result violates constraint ({{{constraint_message}}})");
        }
{{/has_constraint}}
        return lhs;
    }
)__";

constexpr char logical_operator[] = R"(
    /**
     * Apply the binary logical operator {{{op}}} to the wrapped object.
     *
     * @note  General advice is to NOT overload these operators.
     * One of the reasons is that short-circuit is no longer available.
     * Proceed with caution.
     */
    friend {{{const_expr}}}bool operator {{{op}}} (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const&>() {{{op}}} std::declval<{{{underlying_type}}} const&>()))
    {
        return lhs.value {{{op}}} rhs.value;
    }
)";

constexpr char unary_operators[] = R"(
    /**
     * Apply the unary {{{op}}} operator to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}} operator {{{op}}} ({{{class_name}}} const & t)
    noexcept(
        noexcept({{{op}}} std::declval<{{{underlying_type}}} const&>()) &&
        std::is_nothrow_assignable<
            {{{underlying_type}}}&,
            decltype({{{op}}} std::declval<{{{underlying_type}}} const&>())>::value)
    {
        auto result = t;
        result.value = {{{op}}} t.value;
        return result;
    }
)";

constexpr char increment_operator[] = R"(
    /**
     * Apply the prefix {{{op}}} operator to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}} &
    operator {{{op}}} ({{{class_name}}} & t)
    noexcept(noexcept({{{op}}}std::declval<{{{underlying_type}}}&>()))
    {
        {{{op}}}t.value;
        return t;
    }
    /**
     * Apply the postfix {{{op}}} operator to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}}
    operator {{{op}}} ({{{class_name}}} & t, int)
    noexcept(
        std::is_nothrow_copy_constructible<{{{underlying_type}}}>::value &&
        noexcept({{{op}}}std::declval<{{{underlying_type}}}&>()))
    {
        auto result = t;
        {{{op}}}t.value;
        return result;
    }
)";

constexpr char bool_operator_template[] = R"(
    /**
     * Return the result of casting the wrapped object to bool.
     */
    {{{const_expr}}}explicit operator bool () const
    noexcept(noexcept(static_cast<bool>(
        std::declval<{{{underlying_type}}} const&>())))
    {
        return static_cast<bool>(value);
    }
)";

constexpr char explicit_cast_operator_template[] = R"(
    /**
     * Explicit cast to {{{cast_type}}}
     */
    {{{const_expr}}}explicit operator {{{cast_type}}}() const
    noexcept(noexcept(static_cast<{{{cast_type}}}>(
        std::declval<{{{underlying_type}}} const&>())))
    {
        return static_cast<{{{cast_type}}}>(value);
    }
)";

constexpr char implicit_cast_operator_template[] = R"(
    /**
     * Implicit cast to {{{cast_type}}}
     */
    {{{const_expr}}}operator {{{cast_type}}}() const
    noexcept(noexcept(static_cast<{{{cast_type}}}>(
        std::declval<{{{underlying_type}}} const&>())))
    {
        return static_cast<{{{cast_type}}}>(value);
    }
)";

constexpr char indirection_operator_template[] = R"(
    /**
     * Dereference operator - forwards to wrapped type's operator* if available,
     * otherwise returns reference to wrapped value.
     *
     * Pointer types: dereferences the pointer (returns *ptr)
     * Pointer-like types (smart pointers, iterators, optional): returns *value
     * Other types: returns reference to value (fallback)
     */
    template <typename T = atlas::atlas_detail::const_>
    {{{const_expr}}}auto operator * () const
    -> decltype(atlas::atlas_detail::star_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<1>{}))
    {
        return atlas::atlas_detail::star_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<1>{});
    }

    template <typename T = atlas::atlas_detail::mutable_>
    {{{const_expr}}}auto operator * ()
    -> decltype(atlas::atlas_detail::star_impl<T>(
        value,
        atlas::atlas_detail::PriorityTag<10>{}))
    {
        return atlas::atlas_detail::star_impl<T>(
            value,
            atlas::atlas_detail::PriorityTag<10>{});
    }
)";

constexpr char nullary_template[] = R"(
    /**
     * A nullary call operator that returns access to the wrapped type.
     */
    {{{const_expr}}}{{{underlying_type}}} const & operator () () const
    noexcept
    {
        return value;
    }
    {{{const_expr}}}{{{underlying_type}}} & operator () ()
    noexcept
    {
        return value;
    }
)";

constexpr char callable_template[] = R"(
    /**
     * A call operator that takes an invocable, which is then invoked with the
     * wrapped object.
     */
#if defined(__cpp_lib_invoke) && __cpp_lib_invoke >= 201411L
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv) const
    noexcept(noexcept(std::invoke(std::forward<InvocableT>(inv), value)))
    -> decltype(std::invoke(std::forward<InvocableT>(inv), value))
    {
        return std::invoke(std::forward<InvocableT>(inv), value);
    }
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv)
    noexcept(noexcept(std::invoke(std::forward<InvocableT>(inv), value)))
    -> decltype(std::invoke(std::forward<InvocableT>(inv), value))
    {
        return std::invoke(std::forward<InvocableT>(inv), value);
    }
#else
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv) const
    noexcept(noexcept(std::forward<InvocableT>(inv)(value)))
    -> decltype(std::forward<InvocableT>(inv)(value))
    {
        return std::forward<InvocableT>(inv)(value);
    }
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv)
    noexcept(noexcept(std::forward<InvocableT>(inv)(value)))
    -> decltype(std::forward<InvocableT>(inv)(value))
    {
        return std::forward<InvocableT>(inv)(value);
    }
#endif
)";

constexpr char logical_not_template[] = R"(
    /**
     * Apply the unary logical not operator to the wrapped object.
     */
    friend {{{const_expr}}}bool operator not ({{{class_name}}} const & t)
    noexcept(noexcept(not std::declval<{{{underlying_type}}} const&>()))
    {
        return not t.value;
    }
)";

constexpr char spaceship_operator_template[] = R"(
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend {{{const_expr}}}auto operator <=> (
        {{{class_name}}} const &,
        {{{class_name}}} const &) = default;
#else
    /**
     * Comparison operators (C++17 fallback for spaceship operator).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend {{{const_expr}}}bool operator < (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const &>() <
        std::declval<{{{underlying_type}}} const &>()))
    {
        return lhs.value < rhs.value;
    }

    friend {{{const_expr}}}bool operator <= (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const &>() <=
        std::declval<{{{underlying_type}}} const &>()))
    {
        return lhs.value <= rhs.value;
    }

    friend {{{const_expr}}}bool operator > (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const &>() >
        std::declval<{{{underlying_type}}} const &>()))
    {
        return lhs.value > rhs.value;
    }

    friend {{{const_expr}}}bool operator >= (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const &>() >=
        std::declval<{{{underlying_type}}} const &>()))
    {
        return lhs.value >= rhs.value;
    }
#endif
)";

constexpr char defaulted_equality_operator_template[] = R"(
#if defined(__cpp_impl_three_way_comparison) && \
    __cpp_impl_three_way_comparison >= 201907L
    /**
     * The default equality comparison operator.
     * Provided with spaceship operator for optimal performance.
     */
    friend {{{const_expr}}}bool operator == (
        {{{class_name}}} const &,
        {{{class_name}}} const &) = default;
#else
    /**
     * Equality comparison operators (C++17 fallback).
     * In C++20+, these are synthesized from operator<=>.
     */
    friend {{{const_expr}}}bool operator == (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const &>() ==
        std::declval<{{{underlying_type}}} const &>()))
    {
        return lhs.value == rhs.value;
    }

    friend {{{const_expr}}}bool operator != (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const &>() !=
        std::declval<{{{underlying_type}}} const &>()))
    {
        return lhs.value != rhs.value;
    }
#endif
)";

constexpr char ostream_operator_template[] = R"(
    /**
     * Insert the wrapped object into an ostream.
     */
    friend std::ostream & operator << (
        std::ostream & strm,
        {{{class_name}}} const & t)
    {
        return strm << t.value;
    }
)";

constexpr char istream_operator_template[] = R"(
    /**
     * Extract the wrapped object from an istream.
     */
    friend std::istream & operator >> (
        std::istream & strm,
        {{{class_name}}} & t)
    {
        return strm >> t.value;
    }
)";

constexpr char hash_specialization_template[] = R"(
/**
 * @brief std::hash specialization for {{{full_qualified_name}}}
 *
 * Delegates to std::hash of the underlying type {{{underlying_type}}}
 */
template <>
struct std::hash<{{{full_qualified_name}}}>
{
    ATLAS_NODISCARD
    {{{hash_const_expr}}}std::size_t operator () ({{{full_qualified_name}}} const & t) const
    noexcept(
        noexcept(std::hash<{{{underlying_type}}}>{}(
            std::declval<{{{underlying_type}}} const &>())))
    {
        return std::hash<{{{underlying_type}}}>{}(
            static_cast<{{{underlying_type}}} const &>(t));
    }
};
)";

constexpr char formatter_specialization_template[] = R"(
/**
 * @brief std::formatter specialization for {{{full_qualified_name}}}
 *
 * Enables use with std::format and std::print in C++20 and later:
 *   std::format("{}", strong_type_instance)
 *
 * This specialization is only available when std::format is available
 * (checked via __cpp_lib_format >= 202110L). Delegates formatting to the
 * underlying type {{{underlying_type}}}
 */
#if defined(__cpp_lib_format) && __cpp_lib_format >= 202110L
template <>
struct std::formatter<{{{full_qualified_name}}}> : std::formatter<{{{underlying_type}}}>
{
    auto format({{{full_qualified_name}}} const & t, std::format_context & ctx) const
    {
        return std::formatter<{{{underlying_type}}}>::format(
            static_cast<{{{underlying_type}}} const &>(t), ctx);
    }
};
#endif // defined(__cpp_lib_format) && __cpp_lib_format >= 202110L
)";

constexpr char subscript_operator_template[] = R"(
    /**
     * Subscript operator that forwards to the wrapped object.
     */
#if __cpp_multidimensional_subscript >= 202110L
    template <typename ArgT, typename... ArgTs>
    {{{const_expr}}}decltype(auto) operator [] (ArgT && arg, ArgTs && ... args)
    noexcept(noexcept(value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...]))
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
    template <typename ArgT, typename... ArgTs>
    {{{const_expr}}}decltype(auto) operator [] (ArgT && arg, ArgTs && ... args) const
    noexcept(noexcept(value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...]))
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
#else
    template <typename ArgT>
    {{{const_expr}}}auto operator [] (ArgT && arg)
    noexcept(noexcept(value[std::forward<ArgT>(arg)]))
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
    template <typename ArgT>
    {{{const_expr}}}auto operator [] (ArgT && arg) const
    noexcept(noexcept(value[std::forward<ArgT>(arg)]))
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
#endif
)";

constexpr char iterator_support_template[] = R"(
    /**
     * Iterator type aliases for container-like interface.
     */
    using iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<{{{underlying_type}}}&>()));
    using const_iterator = decltype(atlas::atlas_detail::begin_(
        std::declval<{{{underlying_type}}} const&>()));
    using value_type = typename std::remove_reference<decltype(
        *atlas::atlas_detail::begin_(
            std::declval<{{{underlying_type}}}&>()))>::type;

    /**
     * Member functions for iterator access.
     * Enables both explicit calls (e.g., s.begin()) and range-based for loops.
     * Uses ADL-enabled helpers that work in decltype/noexcept contexts.
     */
    {{{const_expr}}}auto begin()
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    {{{const_expr}}}auto end()
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }

    {{{const_expr}}}auto begin() const
    noexcept(noexcept(atlas::atlas_detail::begin_(value)))
    -> decltype(atlas::atlas_detail::begin_(value))
    {
        return atlas::atlas_detail::begin_(value);
    }

    {{{const_expr}}}auto end() const
    noexcept(noexcept(atlas::atlas_detail::end_(value)))
    -> decltype(atlas::atlas_detail::end_(value))
    {
        return atlas::atlas_detail::end_(value);
    }
)";

constexpr char template_assignment_operator_template[] = R"(
    /**
     * @brief Template assignment operator
     *
     * Allows assignment from any type that is assignable to the underlying type.
     * This provides convenience while maintaining type safety through SFINAE.
     *
     * Example:
     *   StrongType s{"initial"};
     *   s = "new value";        // Works if assignable
     *   s = std::string("foo"); // Works if assignable
     *   s = 42;                 // Rejected if not assignable
     *
     * Note: constexpr is applied only in C++14 and later because in C++11,
     * constexpr non-static member functions are implicitly const.
     */
#if defined(__cpp_concepts) && __cpp_concepts >= 201907L
    template <typename T>
      requires (std::assignable_from<{{{underlying_type}}}&, T> &&
                not std::same_as<std::decay_t<T>, {{{class_name}}}>)
#else
    template <typename T,
        typename std::enable_if<
            std::is_assignable<{{{underlying_type}}}&, T>::value &&
            not std::is_same<typename std::decay<T>::type, {{{class_name}}}>::value,
            int>::type = 0>
#endif
#if __cplusplus >= 201402L
    {{{const_expr}}}{{{class_name}}}& operator=(T&& t)
#else
    {{{class_name}}}& operator=(T&& t)
#endif
    noexcept(noexcept(std::declval<{{{underlying_type}}}&>() = std::declval<T>()))
    {
        value = std::forward<T>(t);
        return *this;
    }
)";

constexpr char forwarded_memfn_template[] = R"(
    /**
     * @brief Forward {{memfn_name}} to wrapped object{{#alias_name}} (aliased as {{alias_name}}){{/alias_name}}{{#return_type}},
     * wrapping return value in {{return_type}}{{/return_type}}
     *
     * This member function forwards all calls to the underlying type's
     * {{memfn_name}} member function, preserving const-correctness,
     * noexcept specifications, and perfect forwarding.
{{#const_only}}     * Only const overloads are generated.
{{/const_only}}{{#return_type}}     * Return value is wrapped in {{return_type}} (requires {{return_type}} to be
     * constructible from the memfn's return type).
{{/return_type}}     */
{{^const_only}}#if defined(__cpp_explicit_this_parameter) && __cpp_explicit_this_parameter >= 202110L
    // C++23 deducing this - single elegant overload
    template <typename Self, typename... Args>
    {{const_expr}}auto {{#alias_name}}{{alias_name}}{{/alias_name}}{{^alias_name}}{{memfn_name}}{{/alias_name}}(this Self&& self, Args&&... args){{#return_type}}
    -> {{return_type}}{{/return_type}}{{^return_type}}
    noexcept(noexcept(std::forward<Self>(self).value.{{memfn_name}}(std::forward<Args>(args)...)))
    -> decltype(std::forward<Self>(self).value.{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}}
    {
        return {{#return_type}}{{return_type}}{{/return_type}}{{^return_type}}std::forward<Self>(self).value.{{memfn_name}}(std::forward<Args>(args)...){{/return_type}}{{#return_type}}(std::forward<Self>(self).value.{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}};
    }
#else
{{/const_only}}    // C++11-20: ref-qualified overloads (or just const for const-only)
{{#generate_const_no_ref}}
    template <typename... Args>
    {{const_expr}}auto {{#alias_name}}{{alias_name}}{{/alias_name}}{{^alias_name}}{{memfn_name}}{{/alias_name}}(Args&&... args) const{{#return_type}}
    -> {{return_type}}{{/return_type}}{{^return_type}}
    noexcept(noexcept(value.{{memfn_name}}(std::forward<Args>(args)...)))
    -> decltype(value.{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}}
    {
        return {{#return_type}}{{return_type}}{{/return_type}}{{^return_type}}value.{{memfn_name}}(std::forward<Args>(args)...){{/return_type}}{{#return_type}}(value.{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}};
    }
{{/generate_const_no_ref}}

{{#generate_const_lvalue}}
    template <typename... Args>
    {{const_expr}}auto {{#alias_name}}{{alias_name}}{{/alias_name}}{{^alias_name}}{{memfn_name}}{{/alias_name}}(Args&&... args) const &{{#return_type}}
    -> {{return_type}}{{/return_type}}{{^return_type}}
    noexcept(noexcept(value.{{memfn_name}}(std::forward<Args>(args)...)))
    -> decltype(value.{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}}
    {
        return {{#return_type}}{{return_type}}{{/return_type}}{{^return_type}}value.{{memfn_name}}(std::forward<Args>(args)...){{/return_type}}{{#return_type}}(value.{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}};
    }
{{/generate_const_lvalue}}

{{#generate_const_rvalue}}
    template <typename... Args>
    {{const_expr}}auto {{#alias_name}}{{alias_name}}{{/alias_name}}{{^alias_name}}{{memfn_name}}{{/alias_name}}(Args&&... args) const &&{{#return_type}}
    -> {{return_type}}{{/return_type}}{{^return_type}}
    noexcept(noexcept(std::move(value).{{memfn_name}}(std::forward<Args>(args)...)))
    -> decltype(std::move(value).{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}}
    {
        return {{#return_type}}{{return_type}}{{/return_type}}{{^return_type}}std::move(value).{{memfn_name}}(std::forward<Args>(args)...){{/return_type}}{{#return_type}}(std::move(value).{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}};
    }
{{/generate_const_rvalue}}

{{#generate_nonconst_lvalue}}
    template <typename... Args>
    {{const_expr}}auto {{#alias_name}}{{alias_name}}{{/alias_name}}{{^alias_name}}{{memfn_name}}{{/alias_name}}(Args&&... args) &{{#return_type}}
    -> {{return_type}}{{/return_type}}{{^return_type}}
    noexcept(noexcept(value.{{memfn_name}}(std::forward<Args>(args)...)))
    -> decltype(value.{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}}
    {
        return {{#return_type}}{{return_type}}{{/return_type}}{{^return_type}}value.{{memfn_name}}(std::forward<Args>(args)...){{/return_type}}{{#return_type}}(value.{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}};
    }
{{/generate_nonconst_lvalue}}

{{#generate_nonconst_rvalue}}
    template <typename... Args>
    {{const_expr}}auto {{#alias_name}}{{alias_name}}{{/alias_name}}{{^alias_name}}{{memfn_name}}{{/alias_name}}(Args&&... args) &&{{#return_type}}
    -> {{return_type}}{{/return_type}}{{^return_type}}
    noexcept(noexcept(std::move(value).{{memfn_name}}(std::forward<Args>(args)...)))
    -> decltype(std::move(value).{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}}
    {
        return {{#return_type}}{{return_type}}{{/return_type}}{{^return_type}}std::move(value).{{memfn_name}}(std::forward<Args>(args)...){{/return_type}}{{#return_type}}(std::move(value).{{memfn_name}}(std::forward<Args>(args)...)){{/return_type}};
    }
{{/generate_nonconst_rvalue}}
{{^const_only}}#endif
{{/const_only}})";

struct Operator
{
    std::string op;

    explicit Operator(std::string_view op_)
    : op(op_)
    { }

    friend bool operator < (Operator const & x, Operator const & y)
    {
        return x.op < y.op;
    }
};
BOOST_DESCRIBE_STRUCT(Operator, (), (op))

struct CastOperator
{
    std::string cast_type;

    explicit CastOperator(std::string cast_type_)
    : cast_type(std::move(cast_type_))
    { }
};
BOOST_DESCRIBE_STRUCT(CastOperator, (), (cast_type))

struct Constant
{
    std::string name;
    std::string value;

    Constant(std::string name_, std::string value_)
    : name(std::move(name_))
    , value(std::move(value_))
    { }
};
BOOST_DESCRIBE_STRUCT(Constant, (), (name, value))

struct ForwardedMemfn
{
    std::string memfn_name;
    std::string alias_name; // Empty if no alias
    std::string return_type; // Empty if no return type transformation
    bool const_only = false;
    // Flags for template rendering
    bool cpp23_or_later = false;
    bool generate_const_no_ref = false; // Just const (no ref qualifier)
    bool generate_const_lvalue = true;
    bool generate_const_rvalue = true;
    bool generate_nonconst_lvalue = true;
    bool generate_nonconst_rvalue = true;

    ForwardedMemfn() = default;

    ForwardedMemfn(
        std::string memfn_name_,
        std::string alias_name_ = "",
        bool const_only_ = false,
        std::string return_type_ = "")
    : memfn_name(std::move(memfn_name_))
    , alias_name(std::move(alias_name_))
    , return_type(std::move(return_type_))
    , const_only(const_only_)
    { }
};
BOOST_DESCRIBE_STRUCT(
    ForwardedMemfn,
    (),
    (memfn_name,
     alias_name,
     return_type,
     const_only,
     cpp23_or_later,
     generate_const_no_ref,
     generate_const_lvalue,
     generate_const_rvalue,
     generate_nonconst_lvalue,
     generate_nonconst_rvalue))

enum class ArithmeticMode
{
    Default, // Normal unchecked arithmetic
    Checked, // Throw on overflow
    Saturating, // Clamp to bounds
    Wrapping // Explicit wraparound
};
BOOST_DESCRIBE_ENUM(ArithmeticMode, Default, Checked, Saturating, Wrapping)

struct ClassInfo
{
    std::string class_namespace;
    std::string namespace_open;
    std::string namespace_close;
    std::string full_class_name;
    std::string class_name;
    std::string underlying_type;
    std::vector<Operator> arithmetic_binary_operators;
    std::vector<Operator> unary_operators;
    bool indirection_operator = false;
    std::vector<Operator> addressof_operators;
    bool arrow_operator = false;
    bool spaceship_operator = false;
    bool defaulted_equality_operator = false;
    std::vector<Operator> relational_operators;
    std::vector<Operator> increment_operators;
    bool ostream_operator = false;
    bool istream_operator = false;
    std::string bool_operator;
    bool nullary = false;
    bool callable = false;
    std::string public_specifier;
    bool logical_not_operator = false;
    std::vector<Operator> logical_operators;
    std::vector<std::string> includes_vec; // for processing
    std::map<std::string, std::string> include_guards; // header -> condition
    bool hash_specialization = false;
    bool formatter_specialization = false;
    std::string full_qualified_name;
    bool subscript_operator = false;
    bool has_default_value = false;
    std::string default_initializer = "{}";
    std::string const_expr = "constexpr ";
    std::string hash_const_expr = "constexpr ";
    bool iterator_support_member = false;
    bool template_assignment_operator = false;
    std::vector<CastOperator> explicit_cast_operators;
    std::vector<CastOperator> implicit_cast_operators;
    std::vector<Constant> constants;
    std::vector<ForwardedMemfn> forwarded_memfns;
    std::string const_qualifier = "constexpr ";
    int cpp_standard = 11;
    ArithmeticMode arithmetic_mode = ArithmeticMode::Default;
    StrongTypeDescription desc;

    // Constraint fields
    bool has_constraint = false;
    std::string constraint_type;
    std::map<std::string, std::string> constraint_params;
    std::string constraint_message;
    std::string constraint_template_args;
};
BOOST_DESCRIBE_STRUCT(
    ClassInfo,
    (),
    (class_namespace,
     namespace_open,
     namespace_close,
     full_class_name,
     class_name,
     underlying_type,
     arithmetic_binary_operators,
     unary_operators,
     indirection_operator,
     addressof_operators,
     arrow_operator,
     spaceship_operator,
     defaulted_equality_operator,
     relational_operators,
     ostream_operator,
     istream_operator,
     bool_operator,
     nullary,
     callable,
     public_specifier,
     logical_not_operator,
     logical_operators,
     increment_operators,
     hash_specialization,
     formatter_specialization,
     full_qualified_name,
     subscript_operator,
     has_default_value,
     default_initializer,
     const_expr,
     hash_const_expr,
     iterator_support_member,
     template_assignment_operator,
     explicit_cast_operators,
     implicit_cast_operators,
     constants,
     forwarded_memfns,
     const_qualifier,
     cpp_standard,
     arithmetic_mode,
     desc,
     has_constraint,
     constraint_type,
     constraint_params,
     constraint_message,
     constraint_template_args))

constexpr auto arithmetic_binary_op_tags = std::to_array<std::string_view>(
    {"+", "-", "*", "/", "%", "&", "|", "^", "<<", ">>", "+*", "-*"});
constexpr auto arithmetic_unary_operators = std::to_array<std::string_view>(
    {"u+", "u-", "u~", "~"});
constexpr auto relational_operators = std::to_array<std::string_view>(
    {"==", "!=", "<=", ">=", "<", ">"});

constexpr bool
is_arithmetic_binary_operator(std::string_view sv)
{
    return std::find(
               arithmetic_binary_op_tags.begin(),
               arithmetic_binary_op_tags.end(),
               sv) != arithmetic_binary_op_tags.end();
}

constexpr bool
is_arithmetic_unary_operator(std::string_view sv)
{
    return std::find(
               arithmetic_unary_operators.begin(),
               arithmetic_unary_operators.end(),
               sv) != arithmetic_unary_operators.end();
}

constexpr bool
is_relational_operator(std::string_view sv)
{
    return std::find(
               relational_operators.begin(),
               relational_operators.end(),
               sv) != relational_operators.end();
}

// Local utility functions for StrongTypeGenerator
namespace {

// Default predicate for strip - checks if character is whitespace
struct IsSpacePred
{
    bool operator () (unsigned char u) const
    {
        return std::isspace(static_cast<int>(u));
    }
};

template <typename PredT = IsSpacePred>
std::string_view
strip(std::string_view sv, PredT pred = PredT{})
{
    auto result = sv;
    while (not result.empty() &&
           pred(static_cast<unsigned char>(result.front())))
    {
        result.remove_prefix(1);
    }
    while (not result.empty() &&
           pred(static_cast<unsigned char>(result.back())))
    {
        result.remove_suffix(1);
    }
    return result;
}

std::vector<std::string_view>
split(std::string_view sv, char sep)
{
    std::vector<std::string_view> components;
    while (not sv.empty()) {
        while (not sv.empty() && std::isspace(sv.front())) {
            sv.remove_prefix(1);
        }
        auto n = std::min(sv.find(sep), sv.size());
        components.push_back(strip(sv.substr(0, n)));
        sv.remove_prefix(std::min(n + 1, sv.size()));
    }
    return components;
}

inline constexpr auto stripns = [](auto sv) {
    return strip(sv, [](unsigned char c) { return c == ':'; });
};

} // anonymous namespace

// Check for redundant operators when spaceship is present
void
check_for_redundant_operators(
    bool has_spaceship,
    bool has_equality_ops,
    bool has_relational_ops,
    ClassInfo const & info,
    std::vector<StrongTypeGenerator::Warning> * warnings)
{
    if (not has_spaceship || not warnings) {
        return;
    }

    auto type_name = info.class_namespace.empty()
        ? info.full_class_name
        : info.class_namespace + "::" + info.full_class_name;

    if (has_equality_ops) {
        warnings->push_back(
            {.message = "Operator '<=>' makes '==' and '!=' redundant. "
                        "Consider removing '==' and '!=' from the description.",
             .type_name = type_name});
    }

    if (has_relational_ops) {
        warnings->push_back(
            {.message =
                 "Operator '<=>' makes '<', '<=', '>', '>=' redundant. "
                 "Consider removing these operators from the description.",
             .type_name = type_name});
    }
}

// ============================================================================
// Forward Specification Parsing
// ============================================================================

/**
 * Result of parsing a forward specification like "size", "size:length",
 * "substr->Type", or "const"
 */
struct ForwardSpec
{
    std::string memfn_name = ""; // The actual memfn on the wrapped type
    std::string alias_name = ""; // Empty if no alias
    std::string return_type = ""; // Empty if no return type transformation
    bool is_const_marker = false; // True if this is the "const" keyword
};

/**
 * Parse a single forward specification string
 * Supports:
 *   - "memfn"                    : basic forwarding
 *   - "memfn:alias"              : forwarding with alias
 *   - "memfn->ReturnType"        : forwarding with return type transformation
 *   - "memfn:alias->ReturnType"  : forwarding with both alias and return type
 *   - "const"                    : marker for const-only forwarding
 */
ForwardSpec
parse_forward_spec(std::string const & forward_str)
{
    if (forward_str == "const") {
        return ForwardSpec{.is_const_marker = true};
    }

    // Local strip function
    auto strip_local = [](std::string_view sv) {
        while (not sv.empty() &&
               std::isspace(static_cast<unsigned char>(sv.front())))
        {
            sv.remove_prefix(1);
        }
        while (not sv.empty() &&
               std::isspace(static_cast<unsigned char>(sv.back())))
        {
            sv.remove_suffix(1);
        }
        return sv;
    };

    // First, check for return type transformation (->)
    std::string left_part = forward_str;
    std::string return_type;

    auto arrow_pos = forward_str.find("->");
    if (arrow_pos != std::string::npos) {
        // Check for multiple arrows (invalid)
        auto second_arrow = forward_str.find("->", arrow_pos + 2);
        if (second_arrow != std::string::npos) {
            throw std::invalid_argument(
                "Invalid forward return type syntax: '" + forward_str +
                "' (only one -> allowed)");
        }

        left_part = std::string(
            strip_local(std::string_view(forward_str).substr(0, arrow_pos)));
        return_type = std::string(
            strip_local(std::string_view(forward_str).substr(arrow_pos + 2)));

        if (left_part.empty()) {
            throw std::invalid_argument(
                "Invalid forward return type syntax: '" + forward_str +
                "' (missing memfn name before ->)");
        }

        if (return_type.empty()) {
            throw std::invalid_argument(
                "Invalid forward return type syntax: '" + forward_str +
                "' (missing return type after ->)");
        }
    }

    // Now check for alias (:) in the left part
    auto colon_pos = left_part.find(':');
    if (colon_pos != std::string::npos) {
        // Check for multiple colons (invalid)
        auto second_colon = left_part.find(':', colon_pos + 1);
        if (second_colon != std::string::npos) {
            throw std::invalid_argument(
                "Invalid forward alias syntax: '" + forward_str +
                "' (only one colon allowed in memfn:alias format)");
        }

        auto memfn = std::string(
            strip_local(std::string_view(left_part).substr(0, colon_pos)));
        auto alias = std::string(
            strip_local(std::string_view(left_part).substr(colon_pos + 1)));

        if (memfn.empty() || alias.empty()) {
            throw std::invalid_argument(
                "Invalid forward alias syntax: '" + forward_str +
                "' (format should be memfn:alias)");
        }

        return ForwardSpec{
            .memfn_name = memfn,
            .alias_name = alias,
            .return_type = return_type};
    }

    // No alias, just memfn (possibly with return type)
    return ForwardSpec{
        .memfn_name = left_part,
        .alias_name = "",
        .return_type = return_type};
}

// ============================================================================
// End of Forward Specification Parsing
// ============================================================================

// Parse cast<Type>, explicit_cast<Type>, or implicit_cast<Type> syntax
// Returns the type name if valid cast syntax, empty string otherwise
std::string
parse_cast_syntax(std::string_view token, bool & is_implicit)
{
    constexpr std::string_view prefix_implicit = "implicit_cast<";
    constexpr std::string_view prefix_explicit = "explicit_cast<";
    constexpr std::string_view prefix_cast = "cast<";

    // Determine which prefix matches (check longest first)
    std::string_view prefix;
    if (token.starts_with(prefix_implicit)) {
        is_implicit = true;
        prefix = prefix_implicit;
    } else if (token.starts_with(prefix_explicit)) {
        is_implicit = false;
        prefix = prefix_explicit;
    } else if (token.starts_with(prefix_cast)) {
        is_implicit = false;
        prefix = prefix_cast;
    } else {
        // Not a cast operator
        return "";
    }

    // Extract type between < and >
    auto start = prefix.length();
    auto end = token.find_last_of('>');
    if (end == std::string_view::npos || end <= start) {
        throw std::invalid_argument(
            "Invalid " + std::string(prefix.substr(0, prefix.length() - 1)) +
            "> syntax: " + std::string(token));
    }
    return std::string(strip(token.substr(start, end - start)));
}

// Expand nested namespaces for C++11 compatibility
// Input: "foo::bar::baz"
// Returns: {opening: "namespace foo {\nnamespace bar {\nnamespace baz {",
//           closing: "} // namespace baz\n} // namespace bar\n} // namespace
//           foo"}
std::pair<std::string, std::string>
expand_namespace(std::string const & ns)
{
    if (ns.empty()) {
        return {"", ""};
    }

    // Split namespace by "::"
    std::vector<std::string> parts;
    std::string_view sv = ns;
    while (not sv.empty()) {
        auto pos = sv.find("::");
        if (pos == std::string_view::npos) {
            parts.emplace_back(sv);
            break;
        }
        parts.emplace_back(sv.substr(0, pos));
        sv.remove_prefix(pos + 2);
    }

    // Build opening
    std::string opening;
    for (auto const & part : parts) {
        opening += "namespace ";
        opening += part;
        opening += " {\n";
    }

    // Build closing (in reverse order)
    std::string closing;
    for (auto it = parts.rbegin(); it != parts.rend(); ++it) {
        closing += "} // namespace ";
        closing += *it;
        closing += "\n";
    }

    return {opening, closing};
}

// Process forwarded memfns from description into ClassInfo
void
process_forwarded_memfns(ClassInfo & info)
{
    bool const_only = false;

    // Process each forward specification string from desc.forwarded_memfns
    // These can be either:
    // 1. Single items like "size", "size:length", "const" (from
    // parse_specification)
    // 2. Comma-separated lists like "size,empty,clear" (from separate forward=
    // lines)
    for (auto const & forward_str_raw : info.desc.forwarded_memfns) {
        // Validate that forward_str is not empty
        auto trimmed = strip(forward_str_raw);
        if (trimmed.empty()) {
            throw std::invalid_argument(
                "Empty forward= specification (forward= must be followed by "
                "memfn names)");
        }

        // The forward string might contain commas (from forward= lines in the
        // file) So we need to split by comma first IMPORTANT: Must store
        // trimmed as a string so the string_views from split() remain valid
        std::string trimmed_str(trimmed);
        for (auto memfn_spec_view : split(trimmed_str, ',')) {
            auto memfn_spec = std::string(strip(memfn_spec_view));

            if (memfn_spec.empty()) {
                continue; // Skip empty tokens
            }

            // Parse using our unified ForwardSpec parser
            ForwardSpec spec = parse_forward_spec(memfn_spec);

            // Check if it's the "const" marker
            if (spec.is_const_marker) {
                const_only = true;
                continue;
            }

            // It's a normal forward specification - create ForwardedMemfn
            ForwardedMemfn fm;
            fm.memfn_name = spec.memfn_name;
            fm.alias_name = spec.alias_name;
            fm.return_type = spec.return_type;
            fm.const_only = const_only;

            // Set template rendering flags based on const_only
            // Note: cpp23_or_later is not used anymore - we use feature test
            // macros instead
            if (fm.const_only) {
                // For const-only, just const (no ref qualifier) suffices
                fm.generate_const_no_ref = true;
                fm.generate_const_lvalue = false;
                fm.generate_const_rvalue = false;
                fm.generate_nonconst_lvalue = false;
                fm.generate_nonconst_rvalue = false;
            } else {
                // Generate all 4 ref-qualified overloads
                fm.generate_const_no_ref = false;
                fm.generate_const_lvalue = true;
                fm.generate_const_rvalue = true;
                fm.generate_nonconst_lvalue = true;
                fm.generate_nonconst_rvalue = true;
            }

            info.forwarded_memfns.push_back(std::move(fm));
        }
    }

    std::sort(
        info.forwarded_memfns.begin(),
        info.forwarded_memfns.end(),
        [](auto const & x, auto const & y) {
            auto const x_str = x.alias_name.empty() ? x.memfn_name
                                                    : x.alias_name;
            auto const y_str = y.alias_name.empty() ? y.memfn_name
                                                    : y.alias_name;
            return x_str < y_str;
        });
}

ClassInfo
parse(
    StrongTypeDescription const & desc,
    std::vector<StrongTypeGenerator::Warning> * warnings)
{
    ClassInfo info;
    info.desc = desc;
    info.cpp_standard = desc.cpp_standard;
    info.class_namespace = stripns(desc.type_namespace);

    // Expand nested namespaces for C++11 compatibility
    auto [ns_open, ns_close] = expand_namespace(info.class_namespace);
    info.namespace_open = ns_open;
    info.namespace_close = ns_close;

    info.full_class_name = stripns(desc.type_name);
    info.class_name = [&] {
        if (auto n = info.full_class_name.rfind(':');
            n < info.full_class_name.size())
        {
            return info.full_class_name.substr(n + 1);
        }
        return info.full_class_name;
    }();
    if (desc.kind == "class") {
        info.public_specifier = "public:";
    } else if (desc.kind != "struct") {
        throw std::invalid_argument("kind must be either class or struct");
    }

    // Track which operators are specified for redundancy detection
    bool has_spaceship = false;
    bool has_equality_ops = false;
    bool has_relational_ops = false;

    // Use unified parser to parse the description
    ParsedSpecification parsed_spec = parse_specification(desc.description);

    // Extract the underlying type from the parsed specification
    info.underlying_type = parsed_spec.first_part;

    // Convert forwards set to forwarded_memfns vector (for backward
    // compatibility) Note: We also need to handle forwarded_memfns that were
    // passed in via desc
    for (auto const & forward : parsed_spec.forwards) {
        // Each element in the set is a raw forward spec like "size",
        // "size:length", or "const" We'll collect them and process them later
        // in process_forwarded_memfns
        info.desc.forwarded_memfns.push_back(forward);
    }

    // Note: Any forwarded_memfns from the original desc (from separate
    // forward= lines in file) are already in desc.forwarded_memfns, so they'll
    // be processed later in process_forwarded_memfns

    // Track arithmetic modes to ensure mutual exclusion
    bool has_checked = false;
    bool has_saturating = false;
    bool has_wrapping = false;

    // Process all operators from the parsed specification
    for (auto const & op_str : parsed_spec.operators) {
        // Use string_view for compatibility with existing operator checking
        // functions
        std::string_view sv(op_str);

        if (sv.empty()) {
            continue; // Skip empty tokens
        }

        bool recognized = false;

        if (is_arithmetic_binary_operator(sv)) {
            recognized = true;
            if (sv.size() > 1u && sv[1] == '*') {
                sv.remove_suffix(1);
                info.arithmetic_binary_operators.emplace_back(sv);
                info.unary_operators.emplace_back(sv);
            } else {
                info.arithmetic_binary_operators.emplace_back(sv);
            }
        }
        if (is_arithmetic_unary_operator(sv)) {
            recognized = true;
            if (sv.size() > 1u) {
                sv.remove_prefix(1);
            }
            info.unary_operators.emplace_back(sv);
        } else if (sv == "!" || sv == "not") {
            recognized = true;
            info.logical_not_operator = true;
        } else if (sv == "||" || sv == "or") {
            recognized = true;
            info.logical_operators.emplace_back("or");
        } else if (sv == "&&" || sv == "and") {
            recognized = true;
            info.logical_operators.emplace_back("and");
        } else if (sv == "++" || sv == "--") {
            recognized = true;
            info.increment_operators.emplace_back(sv);
        } else if (sv == "@") {
            recognized = true;
            info.indirection_operator = true;
        } else if (sv == "&of") {
            recognized = true;
            info.addressof_operators.emplace_back("&");
            info.includes_vec.push_back("<memory>");
        } else if (sv == "->") {
            recognized = true;
            info.arrow_operator = true;
            info.includes_vec.push_back("<memory>");
        } else if (sv == "<=>") {
            recognized = true;
            has_spaceship = true;
            info.spaceship_operator = true;
            info.includes_vec.push_back("<compare>");
        } else if (is_relational_operator(sv)) {
            recognized = true;
            if (sv == "==" || sv == "!=") {
                has_equality_ops = true;
            } else {
                has_relational_ops = true;
            }
            info.relational_operators.emplace_back(sv);
        } else if (sv == "out") {
            recognized = true;
            info.ostream_operator = true;
            info.includes_vec.push_back("<ostream>");
        } else if (sv == "in") {
            recognized = true;
            info.istream_operator = true;
            info.includes_vec.push_back("<istream>");
        } else if (sv == "bool") {
            recognized = true;
            info.bool_operator = bool_operator_template;
        } else if (sv == "()") {
            recognized = true;
            info.nullary = true;
        } else if (sv == "(&)") {
            recognized = true;
            info.callable = true;
            info.includes_vec.push_back("<utility>");
            info.includes_vec.push_back("<functional>");
        } else if (sv == "[]") {
            recognized = true;
            info.subscript_operator = true;
        } else if (sv == "hash") {
            recognized = true;
            info.hash_specialization = true;
            info.includes_vec.push_back("<functional>");
        } else if (sv == "no-constexpr-hash") {
            recognized = true;
            info.hash_specialization = true;
            info.hash_const_expr = "";
            info.includes_vec.push_back("<functional>");
        } else if (sv == "iterable") {
            recognized = true;
            info.desc.generate_iterators = true;
        } else if (sv == "fmt") {
            recognized = true;
            info.desc.generate_formatter = true;
            info.includes_vec.push_back("<format>");
            info.include_guards["<format>"] =
                "defined(__cpp_lib_format) && __cpp_lib_format >= "
                "202110L";
        } else if (sv == "assign") {
            recognized = true;
            info.desc.generate_template_assignment = true;
            info.includes_vec.push_back("<concepts>");
            info.include_guards["<concepts>"] =
                "defined(__cpp_concepts) && __cpp_concepts >= 201907L";
        } else if (sv == "no-constexpr") {
            recognized = true;
            info.const_expr = "";
            info.hash_const_expr = "";
        } else if (sv == "checked") {
            recognized = true;
            has_checked = true;
            info.arithmetic_mode = ArithmeticMode::Checked;
            info.includes_vec.push_back("<limits>");
            info.includes_vec.push_back("<stdexcept>");
            // Note: <cmath> reserved for future checked arithmetic
            // implementation
            info.includes_vec.push_back("<cmath>");
        } else if (sv == "saturating") {
            recognized = true;
            has_saturating = true;
            info.arithmetic_mode = ArithmeticMode::Saturating;
            info.includes_vec.push_back("<limits>");
            // Note: <cmath> reserved for future saturating arithmetic
            // implementation
            info.includes_vec.push_back("<cmath>");
        } else if (sv == "wrapping") {
            recognized = true;
            has_wrapping = true;
            info.arithmetic_mode = ArithmeticMode::Wrapping;
        } else if (sv == "positive") {
            recognized = true;
            info.has_constraint = true;
            info.constraint_type = "positive";
            info.constraint_message = "value must be positive (> 0)";
        } else if (sv == "non_negative") {
            recognized = true;
            info.has_constraint = true;
            info.constraint_type = "non_negative";
            info.constraint_message = "value must be non-negative (>= 0)";
        } else if (sv.starts_with('#')) {
            recognized = true;
            auto str = std::string(strip(sv.substr(1)));
            for (auto & c : str) {
                if (c == '\'') {
                    c = '"';
                }
            }
            info.includes_vec.push_back(std::move(str));
        } else if (sv.starts_with("c++") || sv.starts_with("C++")) {
            recognized = true;
            try {
                info.cpp_standard = parse_cpp_standard(sv);
                info.desc.cpp_standard = info.cpp_standard;
            } catch (std::invalid_argument const & e) {
                throw std::invalid_argument(
                    "Invalid C++ standard in description: " +
                    std::string(e.what()));
            }
        }

        // Try to parse as cast operator
        if (not recognized) {
            bool is_implicit = false;
            std::string cast_type = parse_cast_syntax(sv, is_implicit);

            if (not cast_type.empty()) {
                recognized = true;
                if (is_implicit) {
                    info.desc.implicit_casts.push_back(std::move(cast_type));
                } else {
                    info.desc.explicit_casts.push_back(std::move(cast_type));
                }
            }
        }

        if (not recognized) {
            throw std::invalid_argument(
                "Unrecognized operator or option in description: '" +
                std::string(sv) + "'");
        }
    }

    // Validate arithmetic mode mutual exclusion
    if (has_checked + has_saturating + has_wrapping > 1) {
        throw std::invalid_argument("Cannot specify multiple arithmetic modes "
                                    "(checked, saturating, wrapping)");
    }

    // Set constraint template arguments if constraint is present
    if (info.has_constraint && not info.constraint_type.empty()) {
        info.constraint_template_args = "<" + info.underlying_type + ">";
    }

    // Check for redundant operators with spaceship
    check_for_redundant_operators(
        has_spaceship,
        has_equality_ops,
        has_relational_ops,
        info,
        warnings);

    // Handle spaceship operator + equality operator defaulting
    if (has_spaceship) {
        // If spaceship is alone (no other relational operators), auto-generate
        // defaulted operator==
        if (not has_equality_ops && not has_relational_ops) {
            info.defaulted_equality_operator = true;
        }
        // If spaceship is with equality operators (== or !=), use defaulted
        // operator== instead of hand-written
        else if (has_equality_ops)
        {
            info.defaulted_equality_operator = true;
            // Remove == and != from relational_operators since we'll use
            // defaulted version
            info.relational_operators.erase(
                std::remove_if(
                    info.relational_operators.begin(),
                    info.relational_operators.end(),
                    [](auto const & op) {
                        return op.op == "==" || op.op == "!=";
                    }),
                info.relational_operators.end());
        }
    }

    // Handle default_value from the StrongTypeDescription
    if (not desc.default_value.empty()) {
        info.has_default_value = true;
        info.default_initializer = "{" + desc.default_value + "}";
    }

    // Try to deduce some of the standard header file locations
    std::vector<std::pair<std::string_view, std::string_view>> equals = {
        {"std::any", "<any>"},
        {"std::string", "<string>"},
        {"std::string_view", "<string_view>"},
        {"std::regex", "<regex>"},
        {"std::condition_variable", "<condition_variable>"},
        {"std::condition_variable_any", "<condition_variable>"},
        {"std::latch", "<latch>"},
        {"std::mutex", "<mutex>"},
        {"std::recursive_mutex", "<mutex>"},
        {"std::timed_mutex", "<mutex>"},
        {"std::recursive_timed_mutex", "<mutex>"},
        {"std::shared_mutex", "<shared_mutex>"},
        {"std::shared_timed_mutex", "<shared_mutex>"},
        {"std::binary_semaphore", "<semaphore>"},
        {"std::stop_token", "<stop_token>"},
        {"std::stop_source", "<stop_token>"},
        {"std::thread", "<thread>"},
        {"std::jthread", "<thread>"},
        {"std::thread_id", "<thread>"},
    };
    if (auto i = std::find_if(
            equals.begin(),
            equals.end(),
            [&](auto const & p) { return p.first == info.underlying_type; });
        i != equals.end())
    {
        info.includes_vec.emplace_back(i->second);
    }
    std::vector<std::pair<std::string_view, std::string_view>> starts_with = {
        {"std::bitset<", "<bitset>"},
        {"std::chrono::", "<chrono>"},
        {"std::optional<", "<optional>"},
        {"std::tuple<", "<tuple>"},
        {"std::variant<", "<variant>"},
        {"std::basic_string<", "<string>"},
        {"std::basic_string_view<", "<string>"},
        {"std::array<", "<array>"},
        {"std::deque<", "<deque>"},
        {"std::forward_list<", "<forward_list>"},
        {"std::list<", "<list>"},
        {"std::map<", "<map>"},
        {"std::multimap<", "<map>"},
        {"std::multiset<", "<set>"},
        {"std::priority_queue<", "<queue>"},
        {"std::queue<", "<queue>"},
        {"std::set<", "<set>"},
        {"std::span<", "<span>"},
        {"std::stack<", "<stack>"},
        {"std::unordered_map<", "<unordered_map>"},
        {"std::unordered_multimap<", "<unordered_map>"},
        {"std::unordered_multiset<", "<unordered_set>"},
        {"std::unordered_set<", "<unordered_set>"},
        {"std::vector<", "<vector>"},
        {"std::filesystem::", "<filesystem>"},
        {"std::basic_regex<", "<regex>"},
        {"std::atomic<", "<atomic>"},
        {"std::atomic_", "<atomic>"},
        {"std::barrier<", "<barrier>"},
        {"std::counting_semaphore<", "<semaphore>"},
        {"std::stop_callback<", "<stop_token>"},
        {"std::shared_ptr<", "<memory>"},
        {"std::unique_ptr<", "<memory>"},
        {"std::weak_ptr<", "<memory>"},
        {"std::function<", "<functional>"},
        {"std::hash<", "<functional>"},
        {"std::pair<", "<utility>"},
        {"std::expected<", "<expected>"},
    };
    if (auto i = std::find_if(
            starts_with.begin(),
            starts_with.end(),
            [&](auto const & p) {
                return info.underlying_type.starts_with(p.first);
            });
        i != starts_with.end())
    {
        info.includes_vec.emplace_back(i->second);
    }

    // Add standard includes that are always needed
    info.includes_vec.push_back("<type_traits>");
    info.includes_vec.push_back("<utility>");

    // Sort and uniquify the includes vector
    std::sort(info.includes_vec.begin(), info.includes_vec.end());
    info.includes_vec.erase(
        std::unique(info.includes_vec.begin(), info.includes_vec.end()),
        info.includes_vec.end());
    info.includes_vec.erase(
        std::find(
            info.includes_vec.begin(),
            info.includes_vec.end(),
            "<version>"),
        info.includes_vec.end());

    // Sort operator vectors
    for (auto * c :
         {&info.arithmetic_binary_operators,
          &info.unary_operators,
          &info.addressof_operators,
          &info.relational_operators,
          &info.logical_operators,
          &info.increment_operators})
    {
        std::sort(c->begin(), c->end());
    }

    // Build fully qualified name for hash, formatter specializations,
    // constants, and checked arithmetic
    if (info.hash_specialization || info.desc.generate_formatter ||
        not info.desc.constants.empty() ||
        info.arithmetic_mode == ArithmeticMode::Checked)
    {
        if (not info.class_namespace.empty()) {
            info.full_qualified_name = info.class_namespace +
                "::" + info.full_class_name;
        } else {
            info.full_qualified_name = info.full_class_name;
        }
    }

    // Enable iterator support if requested
    if (info.desc.generate_iterators) {
        info.iterator_support_member = true;
    }

    // Enable formatter specialization if requested
    if (info.desc.generate_formatter) {
        info.formatter_specialization = true;
    }

    // Enable template assignment operator if requested
    if (info.desc.generate_template_assignment) {
        info.template_assignment_operator = true;
    }

    // Populate cast operator vectors
    // Filter out explicit casts that are also in implicit casts
    // (implicit cast supersedes explicit cast for the same type)
    for (auto const & cast_type : info.desc.explicit_casts) {
        if (std::find(
                info.desc.implicit_casts.begin(),
                info.desc.implicit_casts.end(),
                cast_type) == info.desc.implicit_casts.end())
        {
            info.explicit_cast_operators.emplace_back(cast_type);
        }
    }

    for (auto const & cast_type : info.desc.implicit_casts) {
        info.implicit_cast_operators.emplace_back(cast_type);
    }

    // Populate constants vector from description
    for (auto const & [name, value] : info.desc.constants) {
        info.constants.emplace_back(name, value);
    }

    // Process forwarded memfns from description
    process_forwarded_memfns(info);

    // Set const_qualifier based on no-constexpr option
    // If no-constexpr is set, use "const " instead of "constexpr "
    if (info.const_expr.empty()) {
        info.const_qualifier = "const ";
    } else {
        info.const_qualifier = "constexpr ";
    }

    return info;
}

// Helper struct for rendering arithmetic operators with specific op value
// This struct contains all ClassInfo fields plus the op field for mustache
// rendering
struct ClassInfoWithOp
{
    std::string class_namespace;
    std::string namespace_open;
    std::string namespace_close;
    std::string full_class_name;
    std::string class_name;
    std::string underlying_type;
    std::string full_qualified_name;
    std::string const_expr;
    std::string op; // The operator being rendered
    bool has_constraint = false;
    std::string constraint_type;
    std::string constraint_message;
    std::string constraint_template_args;

    explicit ClassInfoWithOp(ClassInfo const & info, std::string op_)
    : class_namespace(info.class_namespace)
    , namespace_open(info.namespace_open)
    , namespace_close(info.namespace_close)
    , full_class_name(info.full_class_name)
    , class_name(info.class_name)
    , underlying_type(info.underlying_type)
    , full_qualified_name(info.full_qualified_name)
    , const_expr(info.const_expr)
    , op(std::move(op_))
    , has_constraint(info.has_constraint)
    , constraint_type(info.constraint_type)
    , constraint_message(info.constraint_message)
    , constraint_template_args(info.constraint_template_args)
    { }
};
BOOST_DESCRIBE_STRUCT(
    ClassInfoWithOp,
    (),
    (class_namespace,
     namespace_open,
     namespace_close,
     full_class_name,
     class_name,
     underlying_type,
     full_qualified_name,
     const_expr,
     op,
     has_constraint,
     constraint_type,
     constraint_message,
     constraint_template_args))

// Helper function to select arithmetic template based on mode and operator
std::string_view
select_arithmetic_template(ArithmeticMode mode, std::string const & op)
{
    if (mode == ArithmeticMode::Checked) {
        if (op == "+") {
            return checked_addition;
        }
        if (op == "-") {
            return checked_subtraction;
        }
        if (op == "*") {
            return checked_multiplication;
        }
        if (op == "/") {
            return checked_division;
        }
        if (op == "%") {
            return checked_modulo;
        }
    } else if (mode == ArithmeticMode::Saturating) {
        if (op == "+") {
            return saturating_addition;
        }
        if (op == "-") {
            return saturating_subtraction;
        }
        if (op == "*") {
            return saturating_multiplication;
        }
        if (op == "/") {
            return saturating_division;
        }
        if (op == "%") {
            return saturating_remainder;
        }
    } else if (mode == ArithmeticMode::Wrapping) {
        // Wrapping doesn't make sense for division/modulo
        if (op == "/" || op == "%") {
            // Fall back to default (which will likely error or be rejected)
            return arithmetic_binary_operators;
        }
        // All other operators use the same wrapping template
        return wrapping_arithmetic;
    }

    // Default: use standard arithmetic_binary_operators template
    return arithmetic_binary_operators;
}

std::string
render_code(ClassInfo const & info)
{
    // For checked, saturating, and wrapping arithmetic modes, we need to render
    // each operator separately with its specific template. For other modes, use
    // the standard rendering.
    if ((info.arithmetic_mode == ArithmeticMode::Checked ||
         info.arithmetic_mode == ArithmeticMode::Saturating ||
         info.arithmetic_mode == ArithmeticMode::Wrapping) &&
        not info.arithmetic_binary_operators.empty())
    {
        // Render arithmetic operators separately with mode-specific templates
        std::stringstream arithmetic_ops_strm;

        for (auto const & op : info.arithmetic_binary_operators) {
            auto template_str = select_arithmetic_template(
                info.arithmetic_mode,
                op.op);
            ClassInfoWithOp context{info, op.op};
            boost::mustache::render(
                std::string(template_str),
                arithmetic_ops_strm,
                context,
                {});
        }

        // Create modified info without arithmetic operators for main template
        ClassInfo info_modified = info;
        info_modified.arithmetic_binary_operators.clear();

        // Render main template
        std::stringstream main_strm;
        boost::mustache::render(
            strong_template,
            main_strm,
            info_modified,
            {{"arithmetic_binary_operators", arithmetic_binary_operators},
             {"unary_operators", unary_operators},
             {"addressof_operators", addressof_operators},
             {"arrow_operator", arrow_operator_template},
             {"relational_operator", relational_operator},
             {"logical_operator", logical_operator},
             {"bool_operator", bool_operator_template},
             {"explicit_cast_operator", explicit_cast_operator_template},
             {"implicit_cast_operator", implicit_cast_operator_template},
             {"indirection_operator", indirection_operator_template},
             {"nullary", nullary_template},
             {"callable", callable_template},
             {"subscript_operator", subscript_operator_template},
             {"iterator_support_member", iterator_support_template},
             {"template_assignment_operator",
              template_assignment_operator_template},
             {"logical_not_operator", logical_not_template},
             {"spaceship_operator", spaceship_operator_template},
             {"defaulted_equality_operator",
              defaulted_equality_operator_template},
             {"ostream_operator", ostream_operator_template},
             {"istream_operator", istream_operator_template},
             {"increment_operator", increment_operator},
             {"hash_specialization", hash_specialization_template},
             {"formatter_specialization", formatter_specialization_template},
             {"constant_declarations", constant_declarations_template},
             {"constants", constants_template + 1},
             {"forwarded_memfn", forwarded_memfn_template}});

        // Insert arithmetic operators code into the class body
        std::string result = main_strm.str();
        std::string arith_ops_code = arithmetic_ops_strm.str();

        // Find insertion point: look for the increment_operators section marker
        // or logical operators, or unary operators, or the class closing
        size_t insert_pos = std::string::npos;

        // Try to find increment operators section
        insert_pos = result.find("    friend");

        if (insert_pos == std::string::npos) {
            // No friend functions yet, insert before closing brace
            insert_pos = result.find("};\n");
        }

        if (insert_pos != std::string::npos) {
            result.insert(insert_pos, arith_ops_code);
        }

        return result;
    }

    // Standard rendering for non-checked modes
    std::stringstream strm;
    boost::mustache::render(
        strong_template,
        strm,
        info,
        {{"arithmetic_binary_operators", arithmetic_binary_operators},
         {"unary_operators", unary_operators},
         {"addressof_operators", addressof_operators},
         {"arrow_operator", arrow_operator_template},
         {"relational_operator", relational_operator},
         {"logical_operator", logical_operator},
         {"bool_operator", bool_operator_template},
         {"explicit_cast_operator", explicit_cast_operator_template},
         {"implicit_cast_operator", implicit_cast_operator_template},
         {"indirection_operator", indirection_operator_template},
         {"nullary", nullary_template},
         {"callable", callable_template},
         {"subscript_operator", subscript_operator_template},
         {"iterator_support_member", iterator_support_template},
         {"template_assignment_operator",
          template_assignment_operator_template},
         {"logical_not_operator", logical_not_template},
         {"spaceship_operator", spaceship_operator_template},
         {"defaulted_equality_operator", defaulted_equality_operator_template},
         {"ostream_operator", ostream_operator_template},
         {"istream_operator", istream_operator_template},
         {"increment_operator", increment_operator},
         {"hash_specialization", hash_specialization_template},
         {"formatter_specialization", formatter_specialization_template},
         {"constant_declarations", constant_declarations_template},
         {"constants", constants_template + 1},
         {"forwarded_memfn", forwarded_memfn_template}});
    return strm.str();
}

std::string
make_guard(StrongTypeDescription const & desc, std::string const & code)
{
    std::string result;
    if (not desc.guard_prefix.empty()) {
        result = desc.guard_prefix;
    } else {
        char prev = '\0';
        for (char c : [&] {
                 auto r = std::string(stripns(desc.type_namespace));
                 r += "::";
                 r += stripns(desc.type_name);
                 return r;
             }())
        {
            if (c == ':') {
                if (prev != ':') {
                    result += desc.guard_separator;
                }
            } else {
                result += c;
            }
            prev = c;
        }
    }
    result += desc.guard_separator;
    result += get_sha1(code);
    if (desc.upcase_guard) {
        std::transform(
            result.begin(),
            result.end(),
            result.begin(),
            [](unsigned char c) { return std::toupper(c); });
    }
    return result;
}

} // anonymous namespace

std::string
StrongTypeGenerator::
operator () (StrongTypeDescription const & desc)
{
    auto const info = parse(desc, &warnings_);
    auto const code = render_code(info);
    auto const guard = make_guard(desc, code);

    // Collect all includes: user includes + preamble includes
    PreambleOptions preamble_opts{
        .include_arrow_operator_traits = info.arrow_operator,
        .include_dereference_operator_traits = info.indirection_operator,
        .include_checked_helpers =
            (info.arithmetic_mode == ArithmeticMode::Checked),
        .include_saturating_helpers =
            (info.arithmetic_mode == ArithmeticMode::Saturating),
        .include_constraints = info.has_constraint};

    auto preamble_includes = get_preamble_includes(preamble_opts);

    // Merge with user includes from info
    std::set<std::string> all_includes_set(
        info.includes_vec.begin(),
        info.includes_vec.end());
    all_includes_set.insert(preamble_includes.begin(), preamble_includes.end());

    // Remove <version> and <compare> as they're handled separately
    all_includes_set.erase("<version>");
    all_includes_set.erase("<compare>");

    // Build the includes string with guards
    std::ostringstream includes_stream;
    for (auto const & include : all_includes_set) {
        auto guard_it = info.include_guards.find(include);
        if (guard_it != info.include_guards.end()) {
            includes_stream << "#if " << guard_it->second << '\n';
            includes_stream << "#include " << include << '\n';
            includes_stream << "#endif // " << guard_it->second << '\n';
        } else {
            includes_stream << "#include " << include << '\n';
        }
    }

    std::stringstream strm;
    strm << "#ifndef " << guard << '\n'
        << "#define " << guard << "\n\n"
        << generate_cpp_standard_assertion(info.cpp_standard)
        << make_notice_banner() << '\n'
        << R"(#if __has_include(<version>)
#include <version>
#endif
)" << includes_stream.str()
        << '\n'
        << preamble(preamble_opts) << code << "#endif // " << guard << '\n';
    return strm.str();
}

std::string
generate_strong_types_file(
    std::vector<StrongTypeDescription> const & descriptions,
    std::string const & guard_prefix,
    std::string const & guard_separator,
    bool upcase_guard)
{
    std::set<std::string> all_includes;
    std::map<std::string, std::string> all_guards;
    std::ostringstream combined_code;
    std::vector<StrongTypeGenerator::Warning> warnings;
    bool any_arrow_operator = false;
    bool any_indirection_operator = false;
    bool any_checked_arithmetic = false;
    bool any_saturating_arithmetic = false;
    bool any_constraints = false;
    int max_cpp_standard = 11;

    // Generate each type WITHOUT preamble, and collect includes
    for (auto const & desc : descriptions) {
        auto info = parse(desc, &warnings);

        // Track the maximum C++ standard across all types
        if (info.cpp_standard > max_cpp_standard) {
            max_cpp_standard = info.cpp_standard;
        }

        // Check if this type uses arrow operator
        if (info.arrow_operator) {
            any_arrow_operator = true;
        }

        // Check if this type uses indirection operator
        if (info.indirection_operator) {
            any_indirection_operator = true;
        }

        // Check if any type uses checked arithmetic
        if (info.arithmetic_mode == ArithmeticMode::Checked) {
            any_checked_arithmetic = true;
        }

        // Check if any type uses saturating arithmetic
        if (info.arithmetic_mode == ArithmeticMode::Saturating) {
            any_saturating_arithmetic = true;
        }

        // Check if any type uses constraints
        if (info.has_constraint) {
            any_constraints = true;
        }

        // Collect includes and guards from this type
        for (auto const & include : info.includes_vec) {
            all_includes.insert(include);
        }
        for (auto const & [header, guard] : info.include_guards) {
            all_guards[header] = guard;
        }

        // Generate just the type code (no preamble, no header guards, no
        // includes)
        combined_code << render_code(info);
    }

    // Output warnings to stderr
    print_warnings(warnings);

    // Generate header guard with SHA of combined content
    std::string content = combined_code.str();

    // Create a temporary description for guard generation
    StrongTypeDescription temp_desc{
        .kind = "struct",
        .type_namespace = "foo",
        .type_name = "Bar",
        .description = "string int; ->",
        .guard_prefix = guard_prefix,
        .guard_separator = guard_separator,
        .upcase_guard = upcase_guard};
    std::string guard = make_guard(temp_desc, content);

    // Add preamble includes to the collected includes
    PreambleOptions preamble_opts{
        .include_arrow_operator_traits = any_arrow_operator,
        .include_dereference_operator_traits = any_indirection_operator,
        .include_checked_helpers = any_checked_arithmetic,
        .include_saturating_helpers = any_saturating_arithmetic,
        .include_constraints = any_constraints};
    auto preamble_includes = get_preamble_includes(preamble_opts);
    for (auto const & include : preamble_includes) {
        all_includes.insert(include);
    }

    // Build final output
    std::ostringstream output;

    // Add header guard first, then static_assert, then NOTICE banner
    output << "#ifndef " << guard << '\n'
        << "#define " << guard << "\n\n"
        << generate_cpp_standard_assertion(max_cpp_standard)
        << make_notice_banner() << '\n'
        << R"(#if __has_include(<version>)
#include <version>
#endif
)";

    // Remove <compare> from top-level includes since it's already
    // conditionally included in the preamble
    all_includes.erase("<compare>");
    all_includes.erase("<version>");

    // Add all unique includes with guards
    for (auto const & include : all_includes) {
        auto guard_it = all_guards.find(include);
        if (guard_it != all_guards.end()) {
            output << "#if " << guard_it->second << '\n';
            output << "#include " << include << '\n';
            output << "#endif\n";
        } else {
            output << "#include " << include << '\n';
        }
    }
    if (not all_includes.empty()) {
        output << '\n';
    }

    // Add strong_type_tag definition once for the entire file
    output << preamble(preamble_opts);
    output << content << "#endif // " << guard << '\n';

    return output.str();
}

}} // namespace wjh::atlas::v1
