// ----------------------------------------------------------------------
// Copyright 2025 Jody Hagins
// Distributed under the MIT Software License
// See accompanying file LICENSE or copy at
// https://opensource.org/licenses/MIT
// ----------------------------------------------------------------------
#include "AtlasUtilities.hpp"
#include "StrongTypeGenerator.hpp"
#include "version.hpp"

#include <boost/describe.hpp>
#include <boost/json/src.hpp>
#include <boost/mustache.hpp>
#include <boost/uuid/detail/sha1.hpp>

#include <algorithm>
#include <array>
#include <filesystem>
#include <map>
#include <set>
#include <sstream>
#include <string>
#include <string_view>

#include <iostream>

namespace wjh::atlas { inline namespace v1 {


BOOST_DESCRIBE_STRUCT(
    StrongTypeDescription,
    (),
    (kind,
     type_namespace,
     type_name,
     description,
     default_value,
     guard_prefix,
     guard_separator,
     upcase_guard))

namespace {

std::string
get_sha1(std::string const & s)
{
    boost::uuids::detail::sha1 sha1;
    sha1.process_bytes(s.data(), s.size());
    boost::uuids::detail::sha1::digest_type hash;
    sha1.get_digest(hash);

    std::string result;
    for (unsigned int x : hash) {
        char buffer[64];
        snprintf(buffer, sizeof(buffer), "%08x", x);
        result += buffer;
    }
    return result;
}

std::string
make_notice_banner()
{
    static constexpr char const b1[] = R"(
// ======================================================================
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ----------------------------------------------------------------------
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// This source file has been generated by Atlas Strong Type Generator v)";
    std::ostringstream banner;
    banner << (b1 + 1) << codegen::version_string << R"(
// https://github.com/jodyhagins/Atlas
//
// DO NOT EDIT THIS FILE DIRECTLY.
//
// ----------------------------------------------------------------------
// NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE  NOTICE
// ======================================================================
)";
    return banner.str();
}

auto strong_template = R"({{#includes}}
#include {{{.}}}
{{/includes}}
{{#namespace_open}}
{{{.}}}{{/namespace_open}}
/**
 * @brief Strong type wrapper for {{{underlying_type}}}
 *
 * Generated by Atlas Strong Type Generator.
 * Generation parameters:
 * - kind: {{{desc.kind}}}
 * - type_namespace: {{{desc.type_namespace}}}
 * - type_name: {{{desc.type_name}}}
 * - description: {{{desc.description}}}
 * - default_value: "{{{desc.default_value}}}"
 */
{{{desc.kind}}} {{{full_class_name}}}
: private atlas::strong_type_tag
{
{{#has_default_value}}
    {{{underlying_type}}} value{{{default_initializer}}};
{{/has_default_value}}
{{^has_default_value}}
    {{{underlying_type}}} value;
{{/has_default_value}}

{{#public_specifier}}
{{{.}}}
{{/public_specifier}}
    using atlas_value_type = {{{underlying_type}}};

    {{{const_expr}}}explicit {{{class_name}}}() = default;
    {{{const_expr}}}{{{class_name}}}({{{class_name}}} const &) = default;
    {{{const_expr}}}{{{class_name}}}({{{class_name}}} &&) = default;
    {{{const_expr}}}{{{class_name}}} & operator = ({{{class_name}}} const &) = default;
    {{{const_expr}}}{{{class_name}}} & operator = ({{{class_name}}} &&) = default;
    {{{const_expr}}}~{{{class_name}}}() = default;

    template <
        typename... ArgTs,
        typename std::enable_if<
            std::is_constructible<{{{underlying_type}}}, ArgTs...>::value,
            bool>::type = true>
    {{{const_expr}}}explicit {{{class_name}}}(ArgTs && ... args)
    : value(std::forward<ArgTs>(args)...)
    { }

    /**
     * The explicit cast operator provides a reference to the wrapped object.
     */
    {{{const_expr}}}explicit operator {{{underlying_type}}} const & () const { return value; }
    {{{const_expr}}}explicit operator {{{underlying_type}}} & () { return value; }
    {{#bool_operator}}
    {{>bool_operator}}
    {{/bool_operator}}
    {{#indirection_operator}}
    {{>indirection_operator}}
    {{/indirection_operator}}
    {{#addressof_operators}}
    {{>addressof_operators}}
    {{/addressof_operators}}
    {{#nullary}}
    {{>nullary}}
    {{/nullary}}
    {{#callable}}
    {{>callable}}
    {{/callable}}
    {{#subscript_operator}}
    {{>subscript_operator}}
    {{/subscript_operator}}
    {{#unary_operators}}
    {{>unary_operators}}
    {{/unary_operators}}
    {{#logical_not_operator}}
    {{>logical_not_operator}}
    {{/logical_not_operator}}
    {{#logical_operators}}
    {{>logical_operator}}
    {{/logical_operators}}
    {{#increment_operators}}
    {{>increment_operator}}
    {{/increment_operators}}
    {{#arithmetic_binary_operators}}
    {{>arithmetic_binary_operators}}
    {{/arithmetic_binary_operators}}
    {{#spaceship_operator}}
    {{>spaceship_operator}}
    {{/spaceship_operator}}
    {{#relational_operators}}
    {{>relational_operator}}
    {{/relational_operators}}
    {{#ostream_operator}}
    {{>ostream_operator}}
    {{/ostream_operator}}
    {{#istream_operator}}
    {{>istream_operator}}
    {{/istream_operator}}
};
{{#namespace_close}}
{{{.}}}{{/namespace_close}}
{{#hash_specialization}}
{{>hash_specialization}}
{{/hash_specialization}}
)";

constexpr char addressof_operators[] = R"(
    /**
     * Access a pointer to the wrapped object.
     */
    {{{const_expr}}}{{{underlying_type}}} const * operator {{{op}}} () const
    {
        return std::addressof(value);
    }
    {{{const_expr}}}{{{underlying_type}}} * operator {{{op}}} ()
    {
        return std::addressof(value);
    }
)";

constexpr char relational_operator[] = R"(
    /**
     * Is @p lhs.value {{{op}}} @p rhs.value?
     */
    friend {{{const_expr}}}bool operator {{{op}}} (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const&>() {{{op}}} std::declval<{{{underlying_type}}} const&>()))
    {
        return lhs.value {{{op}}} rhs.value;
    }
)";

constexpr char arithmetic_binary_operators[] = R"(
    /**
     * Apply {{{op}}} assignment to the wrapped objects.
     */
    friend {{{const_expr}}}{{{class_name}}} & operator {{{op}}}= (
        {{{class_name}}} & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}}&>() {{{op}}}= std::declval<{{{underlying_type}}} const&>()))
    {
        lhs.value {{{op}}}= rhs.value;
        return lhs;
    }
    /**
     * Apply the binary operator {{{op}}} to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}} operator {{{op}}} (
        {{{class_name}}} lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(lhs {{{op}}}= rhs))
    {
        lhs {{{op}}}= rhs;
        return lhs;
    }
)";

constexpr char logical_operator[] = R"(
    /**
     * Apply the binary logical operator {{{op}}} to the wrapped object.
     *
     * @note  General advice is to NOT overload these operators.
     * One of the reasons is that short-circuit is no longer available.
     * Proceed with caution.
     */
    friend {{{const_expr}}}bool operator {{{op}}} (
        {{{class_name}}} const & lhs,
        {{{class_name}}} const & rhs)
    noexcept(noexcept(std::declval<{{{underlying_type}}} const&>() {{{op}}} std::declval<{{{underlying_type}}} const&>()))
    {
        return lhs.value {{{op}}} rhs.value;
    }
)";

constexpr char unary_operators[] = R"(
    /**
     * Apply the unary {{{op}}} operator to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}} operator {{{op}}} ({{{class_name}}} const & t)
    noexcept(
        std::is_nothrow_copy_constructible<{{{class_name}}}>::value &&
        noexcept({{{op}}} std::declval<{{{underlying_type}}} const&>()) &&
        std::is_nothrow_assignable<
            {{{underlying_type}}}&,
            decltype({{{op}}} std::declval<{{{underlying_type}}} const&>())>::value)
    {
        auto result = t;
        result.value = {{{op}}} t.value;
        return result;
    }
)";

constexpr char increment_operator[] = R"(
    /**
     * Apply the prefix {{{op}}} operator to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}} & operator {{{op}}} ({{{class_name}}} & t)
    noexcept(noexcept({{{op}}}std::declval<{{{underlying_type}}}&>()))
    {
        {{{op}}}t.value;
        return t;
    }
    /**
     * Apply the postfix {{{op}}} operator to the wrapped object.
     */
    friend {{{const_expr}}}{{{class_name}}} operator {{{op}}} ({{{class_name}}} & t, int)
    noexcept(
        std::is_nothrow_copy_constructible<{{{class_name}}}>::value &&
        noexcept({{{op}}}std::declval<{{{underlying_type}}}&>()))
    {
        auto result = t;
        {{{op}}}t.value;
        return result;
    }
)";

constexpr char bool_operator_template[] = R"(
    /**
     * Return the result of casting the wrapped object to bool.
     */
    {{{const_expr}}}explicit operator bool () const
    noexcept(noexcept(static_cast<bool>(std::declval<{{{underlying_type}}} const&>())))
    {
        return static_cast<bool>(value);
    }
)";

constexpr char indirection_operator_template[] = R"(
    /**
     * The indirection operator provides a reference to the wrapped object.
     */
    {{{const_expr}}}{{{underlying_type}}} const & operator * () const
    noexcept
    {
        return value;
    }
    {{{const_expr}}}{{{underlying_type}}} & operator * ()
    noexcept
    {
        return value;
    }
)";

constexpr char nullary_template[] = R"(
    /**
     * A nullary call operator that returns access to the wrapped type.
     */
    {{{const_expr}}}{{{underlying_type}}} const & operator () () const
    noexcept
    {
        return value;
    }
    {{{const_expr}}}{{{underlying_type}}} & operator () ()
    noexcept
    {
        return value;
    }
)";

constexpr char callable_template[] = R"(
    /**
     * A call operator that takes an invocable, which is then invoked with the
     * wrapped object.
     */
#if defined(__cpp_lib_invoke) && __cpp_lib_invoke >= 201411L
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv) const
    noexcept(noexcept(std::invoke(std::forward<InvocableT>(inv), value)))
    -> decltype(std::invoke(std::forward<InvocableT>(inv), value))
    {
        return std::invoke(std::forward<InvocableT>(inv), value);
    }
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv)
    noexcept(noexcept(std::invoke(std::forward<InvocableT>(inv), value)))
    -> decltype(std::invoke(std::forward<InvocableT>(inv), value))
    {
        return std::invoke(std::forward<InvocableT>(inv), value);
    }
#else
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv) const
    noexcept(noexcept(std::forward<InvocableT>(inv)(value)))
    -> decltype(std::forward<InvocableT>(inv)(value))
    {
        return std::forward<InvocableT>(inv)(value);
    }
    template <typename InvocableT>
    {{{const_expr}}}auto operator () (InvocableT && inv)
    noexcept(noexcept(std::forward<InvocableT>(inv)(value)))
    -> decltype(std::forward<InvocableT>(inv)(value))
    {
        return std::forward<InvocableT>(inv)(value);
    }
#endif
)";

constexpr char logical_not_template[] = R"(
    /**
     * Apply the unary logical not operator to the wrapped object.
     */
    friend {{{const_expr}}}bool operator not ({{{class_name}}} const & t)
    noexcept(noexcept(not std::declval<{{{underlying_type}}} const&>()))
    {
        return not t.value;
    }
)";

constexpr char spaceship_operator_template[] = R"(
    /**
     * The default three-way comparison (spaceship) operator.
     */
    friend {{{const_expr}}}auto operator <=> (
        {{{class_name}}} const &,
        {{{class_name}}} const &) = default;
)";

constexpr char ostream_operator_template[] = R"(
    /**
     * Insert the wrapped object into an ostream.
     */
    friend std::ostream & operator << (
        std::ostream & strm,
        {{{class_name}}} const & t)
    {
        return strm << t.value;
    }
)";

constexpr char istream_operator_template[] = R"(
    /**
     * Extract the wrapped object from an istream.
     */
    friend std::istream & operator >> (
        std::istream & strm,
        {{{class_name}}} & t)
    {
        return strm >> t.value;
    }
)";

constexpr char hash_specialization_template[] = R"(
/**
 * @brief std::hash specialization for {{{full_qualified_name}}}
 *
 * Delegates to std::hash of the underlying type {{{underlying_type}}}
 */
template <>
struct std::hash<{{{full_qualified_name}}}>
{
    {{{hash_const_expr}}}std::size_t operator () ({{{full_qualified_name}}} const & t) const
    noexcept(
        noexcept(std::hash<{{{underlying_type}}}>{}(
            std::declval<{{{underlying_type}}} const &>())))
    {
        return std::hash<{{{underlying_type}}}>{}(
            static_cast<{{{underlying_type}}} const &>(t));
    }
};
)";

constexpr char subscript_operator_template[] = R"(
    /**
     * Subscript operator that forwards to the wrapped object.
     */
#if __cpp_multidimensional_subscript >= 202110L
    template <typename ArgT, typename... ArgTs>
    {{{const_expr}}}decltype(auto) operator [] (ArgT && arg, ArgTs && ... args)
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
    template <typename ArgT, typename... ArgTs>
    {{{const_expr}}}decltype(auto) operator [] (ArgT && arg, ArgTs && ... args) const
    {
        return value[std::forward<ArgT>(arg), std::forward<ArgTs>(args)...];
    }
#else
    template <typename ArgT>
    {{{const_expr}}}auto operator [] (ArgT && arg)
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
    template <typename ArgT>
    {{{const_expr}}}auto operator [] (ArgT && arg) const
    -> decltype(value[std::forward<ArgT>(arg)])
    {
        return value[std::forward<ArgT>(arg)];
    }
#endif
)";

struct Operator
{
    std::string_view op;

    explicit Operator(std::string_view op_)
    : op(op_)
    { }

    friend bool operator < (Operator const & x, Operator const & y)
    {
        return x.op < y.op;
    }
};
BOOST_DESCRIBE_STRUCT(Operator, (), (op))

struct ClassInfo
{
    std::string class_namespace;
    std::string namespace_open;
    std::string namespace_close;
    std::string full_class_name;
    std::string class_name;
    std::string underlying_type;
    std::vector<Operator> arithmetic_binary_operators;
    std::vector<Operator> unary_operators;
    std::string indirection_operator;
    std::vector<Operator> addressof_operators;
    bool spaceship_operator = false;
    std::vector<Operator> relational_operators;
    std::vector<Operator> increment_operators;
    bool ostream_operator = false;
    bool istream_operator = false;
    std::string bool_operator;
    bool nullary = false;
    bool callable = false;
    std::string public_specifier;
    bool logical_not_operator = false;
    std::vector<Operator> logical_operators;
    std::vector<std::string> includes;
    bool hash_specialization = false;
    std::string full_qualified_name;
    bool subscript_operator = false;
    bool has_default_value = false;
    std::string default_initializer = "{}";
    std::string const_expr = "constexpr ";
    std::string hash_const_expr = "constexpr ";
    StrongTypeDescription desc;
};
BOOST_DESCRIBE_STRUCT(
    ClassInfo,
    (),
    (class_namespace,
     namespace_open,
     namespace_close,
     full_class_name,
     class_name,
     underlying_type,
     arithmetic_binary_operators,
     unary_operators,
     indirection_operator,
     addressof_operators,
     spaceship_operator,
     relational_operators,
     ostream_operator,
     istream_operator,
     bool_operator,
     nullary,
     callable,
     public_specifier,
     logical_not_operator,
     logical_operators,
     includes,
     increment_operators,
     hash_specialization,
     full_qualified_name,
     subscript_operator,
     has_default_value,
     default_initializer,
     const_expr,
     hash_const_expr,
     desc))

constexpr auto arithmetic_binary_op_tags = std::to_array<std::string_view>(
    {"+", "-", "*", "/", "%", "&", "|", "^", "<<", ">>", "+*", "-*"});
constexpr auto arithmetic_unary_operators = std::to_array<std::string_view>(
    {"u+", "u-", "u~", "~"});
constexpr auto relational_operators = std::to_array<std::string_view>(
    {"==", "!=", "<=", ">=", "<", ">"});

constexpr bool
is_arithmetic_binary_operator(std::string_view sv)
{
    return std::find(
               arithmetic_binary_op_tags.begin(),
               arithmetic_binary_op_tags.end(),
               sv) != arithmetic_binary_op_tags.end();
}

constexpr bool
is_arithmetic_unary_operator(std::string_view sv)
{
    return std::find(
               arithmetic_unary_operators.begin(),
               arithmetic_unary_operators.end(),
               sv) != arithmetic_unary_operators.end();
}

constexpr bool
is_relational_operator(std::string_view sv)
{
    return std::find(
               relational_operators.begin(),
               relational_operators.end(),
               sv) != relational_operators.end();
}

// Default predicate for strip - checks if character is whitespace
struct IsSpacePred
{
    bool operator () (unsigned char u) const
    {
        return std::isspace(static_cast<int>(u));
    }
};

template <typename PredT = IsSpacePred>
std::string_view
strip(std::string_view sv, PredT pred = PredT{})
{
    auto result = sv;
    while (not result.empty() &&
           pred(static_cast<unsigned char>(result.front())))
    {
        result.remove_prefix(1);
    }
    while (not result.empty() &&
           pred(static_cast<unsigned char>(result.back())))
    {
        result.remove_suffix(1);
    }
    return result;
}

std::vector<std::string_view>
split(std::string_view sv, char sep)
{
    std::vector<std::string_view> components;
    while (not sv.empty()) {
        while (not sv.empty() && std::isspace(sv.front())) {
            sv.remove_prefix(1);
        }
        auto n = std::min(sv.find(sep), sv.size());
        components.push_back(strip(sv.substr(0, n)));
        sv.remove_prefix(std::min(n + 1, sv.size()));
    }
    return components;
}

inline constexpr auto stripns = [](auto sv) {
    return strip(sv, [](unsigned char c) { return c == ':'; });
};

// Expand nested namespaces for C++11 compatibility
// Input: "foo::bar::baz"
// Returns: {opening: "namespace foo {\nnamespace bar {\nnamespace baz {",
//           closing: "} // namespace baz\n} // namespace bar\n} // namespace
//           foo"}
std::pair<std::string, std::string>
expand_namespace(std::string const & ns)
{
    if (ns.empty()) {
        return {"", ""};
    }

    // Split namespace by "::"
    std::vector<std::string> parts;
    std::string_view sv = ns;
    while (not sv.empty()) {
        auto pos = sv.find("::");
        if (pos == std::string_view::npos) {
            parts.emplace_back(sv);
            break;
        }
        parts.emplace_back(sv.substr(0, pos));
        sv.remove_prefix(pos + 2);
    }

    // Build opening
    std::string opening;
    for (auto const & part : parts) {
        opening += "namespace ";
        opening += part;
        opening += " {\n";
    }

    // Build closing (in reverse order)
    std::string closing;
    for (auto it = parts.rbegin(); it != parts.rend(); ++it) {
        closing += "} // namespace ";
        closing += *it;
        closing += "\n";
    }

    return {opening, closing};
}

ClassInfo
parse(StrongTypeDescription const & desc)
{
    ClassInfo info;
    info.desc = desc;
    info.class_namespace = stripns(desc.type_namespace);

    // Expand nested namespaces for C++11 compatibility
    auto [ns_open, ns_close] = expand_namespace(info.class_namespace);
    info.namespace_open = ns_open;
    info.namespace_close = ns_close;

    info.full_class_name = stripns(desc.type_name);
    info.class_name = [&] {
        if (auto n = info.full_class_name.rfind(':');
            n < info.full_class_name.size())
        {
            return info.full_class_name.substr(n + 1);
        }
        return info.full_class_name;
    }();
    if (desc.kind == "class") {
        info.public_specifier = "public:";
    } else if (desc.kind != "struct") {
        throw std::invalid_argument("kind must be either class or struct");
    }

    for (auto s : split(desc.description, ';')) {
        if (s.starts_with("strong ")) {
            s.remove_prefix(7);
            info.underlying_type = s;
        } else {
            for (auto sv : split(s, ',')) {
                if (sv.empty()) {
                    continue; // Skip empty tokens from trailing commas
                }

                bool recognized = false;

                if (is_arithmetic_binary_operator(sv)) {
                    recognized = true;
                    if (sv.size() > 1u && sv[1] == '*') {
                        sv.remove_suffix(1);
                        info.arithmetic_binary_operators.emplace_back(sv);
                        info.unary_operators.emplace_back(sv);
                    } else {
                        info.arithmetic_binary_operators.emplace_back(sv);
                    }
                }
                if (is_arithmetic_unary_operator(sv)) {
                    recognized = true;
                    if (sv.size() > 1u) {
                        sv.remove_prefix(1);
                    }
                    info.unary_operators.emplace_back(sv);
                } else if (sv == "!" || sv == "not") {
                    recognized = true;
                    info.logical_not_operator = true;
                } else if (sv == "||" || sv == "or") {
                    recognized = true;
                    info.logical_operators.emplace_back("or");
                } else if (sv == "&&" || sv == "and") {
                    recognized = true;
                    info.logical_operators.emplace_back("and");
                } else if (sv == "++" || sv == "--") {
                    recognized = true;
                    info.increment_operators.emplace_back(sv);
                } else if (sv == "@") {
                    recognized = true;
                    info.indirection_operator = indirection_operator_template;
                } else if (sv == "&of") {
                    recognized = true;
                    info.addressof_operators.emplace_back("&");
                    info.includes.push_back("<memory>");
                } else if (sv == "->") {
                    recognized = true;
                    info.addressof_operators.emplace_back(sv);
                    info.includes.push_back("<memory>");
                } else if (sv == "<=>") {
                    recognized = true;
                    info.spaceship_operator = true;
                    info.includes.push_back("<compare>");
                } else if (is_relational_operator(sv)) {
                    recognized = true;
                    info.relational_operators.emplace_back(sv);
                } else if (sv == "out") {
                    recognized = true;
                    info.ostream_operator = true;
                    info.includes.push_back("<ostream>");
                } else if (sv == "in") {
                    recognized = true;
                    info.istream_operator = true;
                    info.includes.push_back("<istream>");
                } else if (sv == "bool") {
                    recognized = true;
                    info.bool_operator = bool_operator_template;
                } else if (sv == "()") {
                    recognized = true;
                    info.nullary = true;
                } else if (sv == "(&)") {
                    recognized = true;
                    info.callable = true;
                    info.includes.push_back("<utility>");
                    info.includes.push_back("<functional>");
                } else if (sv == "[]") {
                    recognized = true;
                    info.subscript_operator = true;
                } else if (sv == "hash") {
                    recognized = true;
                    info.hash_specialization = true;
                    info.includes.push_back("<functional>");
                } else if (sv == "no-constexpr-hash") {
                    recognized = true;
                    info.hash_specialization = true;
                    info.hash_const_expr = "";
                    info.includes.push_back("<functional>");
                } else if (sv == "no-constexpr") {
                    recognized = true;
                    info.const_expr = "";
                    info.hash_const_expr = "";
                } else if (sv.starts_with('#')) {
                    recognized = true;
                    auto str = std::string(strip(sv.substr(1)));
                    for (auto & c : str) {
                        if (c == '\'') {
                            c = '"';
                        }
                    }
                    info.includes.push_back(std::move(str));
                }

                if (not recognized) {
                    throw std::invalid_argument(
                        "Unrecognized operator or option in description: '" +
                        std::string(sv) + "'");
                }
            }
        }
    }

    // Handle default_value from the StrongTypeDescription
    if (not desc.default_value.empty()) {
        info.has_default_value = true;
        info.default_initializer = "{" + desc.default_value + "}";
    }

    // Try to deduce some of the standard header file locations
    std::vector<std::pair<std::string_view, std::string_view>> equals = {
        {"std::any", "<any>"},
        {"std::string", "<string>"},
        {"std::string_view", "<string_view>"},
        {"std::regex", "<regex>"},
        {"std::condition_variable", "<condition_variable>"},
        {"std::condition_variable_any", "<condition_variable>"},
        {"std::latch", "<latch>"},
        {"std::mutex", "<mutex>"},
        {"std::recursive_mutex", "<mutex>"},
        {"std::timed_mutex", "<mutex>"},
        {"std::recursive_timed_mutex", "<mutex>"},
        {"std::shared_mutex", "<shared_mutex>"},
        {"std::shared_timed_mutex", "<shared_mutex>"},
        {"std::binary_semaphore", "<semaphore>"},
        {"std::stop_token", "<stop_token>"},
        {"std::stop_source", "<stop_token>"},
        {"std::thread", "<thread>"},
        {"std::jthread", "<thread>"},
        {"std::thread_id", "<thread>"},
    };
    if (auto i = std::find_if(
            equals.begin(),
            equals.end(),
            [&](auto const & p) { return p.first == info.underlying_type; });
        i != equals.end())
    {
        info.includes.emplace_back(i->second);
    }
    std::vector<std::pair<std::string_view, std::string_view>> starts_with = {
        {"std::bitset<", "<bitset>"},
        {"std::chrono::", "<chrono>"},
        {"std::optional<", "<optional>"},
        {"std::tuple<", "<tuple>"},
        {"std::variant<", "<variant>"},
        {"std::basic_string<", "<string>"},
        {"std::basic_string_view<", "<string>"},
        {"std::array<", "<array>"},
        {"std::deque<", "<deque>"},
        {"std::list<", "<list>"},
        {"std::map<", "<map>"},
        {"std::queue<", "<queue>"},
        {"std::set<", "<set>"},
        {"std::span<", "<span>"},
        {"std::unordered_map<", "<unordered_map>"},
        {"std::unordered_set<", "<unordered_set>"},
        {"std::vector<", "<vector>"},
        {"std::filesystem::<", "<filesystem>"},
        {"std::basic_regex<", "<regex>"},
        {"std::atomic<", "<atomic>"},
        {"std::atomic_", "<atomic>"},
        {"std::barrier<", "<barrier>"},
        {"std::counting_semaphore<", "<semaphore>"},
        {"std::stop_callback<", "<stop_token>"},
    };
    if (auto i = std::find_if(
            starts_with.begin(),
            starts_with.end(),
            [&](auto const & p) {
                return info.underlying_type.starts_with(p.first);
            });
        i != starts_with.end())
    {
        info.includes.emplace_back(i->second);
    }

    // Add standard includes that are always needed
    info.includes.push_back("<type_traits>");
    info.includes.push_back("<utility>");

    std::sort(info.includes.begin(), info.includes.end());
    info.includes.erase(
        std::unique(info.includes.begin(), info.includes.end()),
        info.includes.end());
    for (auto * c :
         {&info.arithmetic_binary_operators,
          &info.unary_operators,
          &info.addressof_operators,
          &info.relational_operators,
          &info.logical_operators,
          &info.increment_operators})
    {
        std::sort(c->begin(), c->end());
    }

    // Build fully qualified name for hash specialization
    if (info.hash_specialization) {
        if (not info.class_namespace.empty()) {
            info.full_qualified_name = info.class_namespace +
                "::" + info.full_class_name;
        } else {
            info.full_qualified_name = info.full_class_name;
        }
    }

    return info;
}

std::string
render_code(ClassInfo const & info)
{
    std::stringstream strm;
    boost::mustache::render(
        strong_template,
        strm,
        info,
        {{"arithmetic_binary_operators", arithmetic_binary_operators},
         {"unary_operators", unary_operators},
         {"addressof_operators", addressof_operators},
         {"relational_operator", relational_operator},
         {"logical_operator", logical_operator},
         {"bool_operator", bool_operator_template},
         {"indirection_operator", indirection_operator_template},
         {"nullary", nullary_template},
         {"callable", callable_template},
         {"subscript_operator", subscript_operator_template},
         {"logical_not_operator", logical_not_template},
         {"spaceship_operator", spaceship_operator_template},
         {"ostream_operator", ostream_operator_template},
         {"istream_operator", istream_operator_template},
         {"increment_operator", increment_operator},
         {"hash_specialization", hash_specialization_template}});
    return strm.str();
}

std::string
make_guard(StrongTypeDescription const & desc, std::string const & code)
{
    std::string result;
    if (not desc.guard_prefix.empty()) {
        result = desc.guard_prefix;
    } else {
        char prev = '\0';
        for (char c : [&] {
                 auto r = std::string(stripns(desc.type_namespace));
                 r += "::";
                 r += stripns(desc.type_name);
                 return r;
             }())
        {
            if (c == ':') {
                if (prev != ':') {
                    result += desc.guard_separator;
                }
            } else {
                result += c;
            }
            prev = c;
        }
    }
    result += desc.guard_separator;
    result += get_sha1(code);
    if (desc.upcase_guard) {
        std::transform(
            result.begin(),
            result.end(),
            result.begin(),
            [](unsigned char c) { return std::toupper(c); });
    }
    return result;
}

} // anonymous namespace

std::string
StrongTypeGenerator::
operator () (StrongTypeDescription const & desc) const
{
    auto const info = parse(desc);
    auto const code = render_code(info);
    auto const guard = make_guard(desc, code);
    std::stringstream strm;
    strm << "#ifndef " << guard << '\n'
        << "#define " << guard << "\n\n"
        << make_notice_banner() << '\n'
        << preamble() << code << "#endif // " << guard << '\n';
    return strm.str();
}

std::string
generate_strong_types_file(
    std::vector<StrongTypeDescription> const & descriptions,
    std::string const & guard_prefix,
    std::string const & guard_separator,
    bool upcase_guard)
{
    std::set<std::string> all_includes;
    std::ostringstream combined_code;

    // Generate each type WITHOUT preamble, and collect includes
    for (auto const & desc : descriptions) {
        auto info = parse(desc);

        // Collect includes from this type
        for (auto const & include : info.includes) {
            all_includes.insert("#include " + include);
        }

        // Clear includes from info since we're hoisting them to the top
        info.includes.clear();

        // Generate just the type code (no preamble, no header guards, no
        // includes)
        combined_code << render_code(info);
    }

    // Generate header guard with SHA of combined content
    std::string content = combined_code.str();

    // Create a temporary description for guard generation
    StrongTypeDescription temp_desc{
        .kind = "struct",
        .type_namespace = "foo",
        .type_name = "Bar",
        .description = "string int; ->",
        .guard_prefix = guard_prefix,
        .guard_separator = guard_separator,
        .upcase_guard = upcase_guard};
    std::string guard = make_guard(temp_desc, content);

    // Build final output
    std::ostringstream output;

    // Add header guard first, then NOTICE banner
    output << "#ifndef " << guard << '\n'
        << "#define " << guard << "\n\n"
        << make_notice_banner() << '\n';

    // Remove <compare> from top-level includes since it's already
    // conditionally included in the preamble
    all_includes.erase("#include <compare>");

    // Add all unique includes (already sorted by std::set)
    for (auto const & include : all_includes) {
        output << include << '\n';
    }
    if (not all_includes.empty()) {
        output << '\n';
    }

    // Add strong_type_tag definition once for the entire file
    output << preamble();
    output << content << "#endif // " << guard << '\n';

    return output.str();
}

}} // namespace wjh::atlas::v1
